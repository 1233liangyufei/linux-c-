# 计算机原理

## 第一章 计算机的抽象与艺术

## 1.1 概述

计算 实验 理论科学研究三大方法

成功的程序员关心程序的性能

决定程序性能的因素

- 算法——数据结构、算法设计
- 创建程序并翻译为机器指令的软件——编译原理
- 计算机各部件执行效率——计算机原理、操作系统

本课：计算机组成结构

算法：决定源程序语句数量及执行io操作数量

程序语言、编译器和体系结构：决定每条程序语句对应的机器指令

处理器、存储器系统：决定指令的执行速度

io系统（硬件和操作系统）：决定io操作的执行速度

## 1.2 程序的表象之下

如何与计算机沟通

高级程序语言计算机无法理解

简单的软硬件层次化结构

- 隐藏低层次的是实现细节，简化各层次的用户的使用
- 每一层为上一层隐藏了自己的技术细节——抽象

硬件 系统软件 应用软件

系统软件：提供公共服务程序

**操作系统**

- 用户程序和硬件的接口，提供计算机的资源管理
- 功能：处理基本的输入输出功能、分配存储空间、为多个程序同时使用计算机提供支持

**编译器**

将高级语句翻译成汇编语句的程序

**汇编器**

汇编语言是一台计算机指令系统的符号化表示

汇编器将汇编语言中的符号指令翻译成计算机能够识别的二进制指令

**计算机的层次结构**

电路设计

数字系统设计

cpu 主存 io

编译器 操作系统

应用程序

计算机层次结构中，指令系统是软/硬件的交互面

isa:屏蔽硬件实现细节，简化程序员的使用

 不同用户工作在不同的层次，看到的计算机不一样

终端用户：应用程序层，如何使用应用程序

应用程序开发人员：程序设计语言层，使用编程语言编程

系统管理员：操作系统层，使用系统工具与命令

系统程序员：操作系统编译器开发人员：了解软硬件工作原理

分析

**如何使用计算机求解一个问题**

- 将问题求解通过输入设备告诉计算机
- 计算机调用相应的运算部件求解
- 将结果输出到输出设备

一个c语言的生命周期

**问题的高级语言描述**

高级语言 c java python go

sum.c

```c
#include<stdio.h>
int main(){
    nt c;
    18+40;
    printf("result is : %d\n",c);
}
```

预处理阶段

将# include内容插入到文本中

编译阶段

翻译为汇编

gcc -S sum sum.c

```
dw C equ//双字长变量C

mov A,12H;
ADD A,28H;
MOV C,A

```

16进制的12 28是十进制的18 40

高级语言源程序

编译器

汇编语言程序

汇编器

机器语言模块

**汇编到机器语言**

主存地址 指令或数据 说明

​		 D8       12H      取数 A   12H    向寄存器存数

​		05         28H       加法 A   A+28H

​		A3        30H       存数：30H  A  向主存存数

​		F4                       停机

​	

​		初始数据

​		3AH                   结果数据

编译汇编链接加载

二进制机器语言程序

硬盘中的可执行文件

**高级语言源程序**

编译

**汇编语言程序**

汇编

目标文件：**机器语言模块**  **库程序模块**

链接

**可执行文件**：**机器语言程序**

加载   操作系统调度或者boot指引

**存储器二进制机器指令流**

cpu 取指，译码，控制单元

**电路上电信号**

cpu运作   外设运作



**计算机内部工作流程**

逐条执行加载到内存的二进制机器指令流的过程

- 一条指令执行 两个操作阶段
  - 取指姐u但，cpu内存读取指令，程序计数器保存到被去除下一指令的地址，除非遇到挑战指令，否则pc一半在每次取指后增加一个增量（当前指令的字节数）

计算机系统基本执行结构

cpu与内存

PC 指令计数器

AR 地址寄存器

pc 00H

送AR 

pc+2

pc 02H

00H地址译码

D8H 12H

读数据

D8H送到指令译码单元

操作数到累加器

操作数到DR 

到累加器

1.3.1打开计算机机箱——冯诺伊曼架构

ENAIC

电子数字计算机

缺点：

开关和连接线设置指令程序，程序设计麻烦，低效

思考

程序存储在机器中，由它控制机器操作

**存储程序原理**

将事先设计好，用以描述计算机解题过程的程序如同数据一样，二进制形式存储在机器中，计算机工作时候自动高速从机器去除指令并加以执行

存储程序

不使用存数程序

计算器

- 数据指令都是人按键输入

操作在人脑而不是机器中

enaic修改电路类似于计算器按键

如果操作指令和数据被存放在存储器中

控制器自动取指令和数据，控制计算执行

**机器完全自动化**

计算机按照顺序自动执行

不同出入不同结果判断改变解题步骤

一个程序产生另外一个程序

播下了程序设计语言和人工智能种子



冯诺伊曼结构结构

输入

输出

存储

运算

控制

总线连接



非冯诺依曼模型

神经网络

生物计算机

量子计算机

## 1.3.2 打开计算机的机箱

电源

风扇

主板

内存条

光驱

硬盘

cpu

功能

- 执行程序
- 控制单元与数据通路
- 控制单元对指令译码，产生控制信号
- 数据通路：完成指令的执行
- 核心是alu+寄存器
- ALU执行算术，逻辑运算
- 寄存器：临时存放数据或控制信息：pc IR

存储器：仓库

功能：存储程序和数据

组成：层次化结构

- 内存：cache+mm
- cache：最近使用的数据和指令
- 主存：存放被启动的程序的部分数据和指令
- 外存：磁盘，固态，光盘，磁带

io

功能：信息输入输出

组成：io控制器,io设备

io控制器：控制外设工作，完成通信

io设备：输入输出信息

键盘，打印机，鼠标，显示器

总线：连接一块

电路板 集成电路 模块 逻辑单元 门电路

越深入，细节越多

隐藏起来，简洁模型

抽象 分层

## 1.4_1 评价计算机的性能

性能指标

- 响应时间
  - 执行时间，等待时间
- 吞吐率
  - 带宽
- 指令执行速度

功耗

如何定义计算机性能比另一个好？

民航客机：载客量、续航能力、巡航速度、运载能力

巡航速度

吞吐率

性价比

不同的标准不同的结果

x比y块？

不同的性能标准

- 完成单个计算任务的时间
  - 响应时间
  - 执行时间
  - 等待时延
- 单位时间完成的任务量
  - 吞吐率
  - 带宽

不同场景性能不同

- 吞吐率高的场合——多媒体应用
- 响应时间——事务处理系统
- 双高——ATM,文件服务器，web服务器

如何提高相应时间和增加吞吐率？

1. 处理机换更好的
2. 多个处理器分别处理，如万维网

加响应肯定加吞吐

加吞吐不一定加响应

如果有排队情况，加吞吐也可加响应

响应时间越来越小

性能：执行时间的倒数

 一个程序A10秒 B15秒

A是B1.5倍

比较计算机性能，响应时间来衡量

- 同样的工作量，完成时间短的性能好
- 处理器时间往往被多个程序共享使用，用户感觉到的程序执行时间不仅仅是程序真正执行的时间

系统响应时间（用户感觉的）

- cpu执行时间：cpu花费在程序执行的时间
  - 用户cpu时间：运行用户代码的时间
  - 系统cpu时间：执行用户程序而运行操作系统代码的时间
- 其他：io操作或其他cpu花在别的程序的时间

计算机系统性能！=cpu性能

- 系统性能：系统响应时间
- cpu性能：用户cpu时间

cpu真正执行用户程序的时间

## 1.4.2 cpu执行时间

度量cpu执行时间

一个程序cpu执行时间

执行一个程序需要的计算机基本时间单元的数量*基本时间单元

时钟周期

- 所有计算机都有一个固定频率的硬件时钟，决定各个因该你事件发生和执行的事件和顺序
- 硬件时钟产生的离散时间间隔称为时钟周期

时钟频率

- 时钟周期的倒数

时钟周期250ps,时钟频率为

1/（250*10-12）=0.25 * 10-9 =4*10^9=4GHz

cpu的主频就是时钟频率

cpu执行时间=程序的cpu时钟周期数*时钟周期时间

改进性能

- 时钟周期数
- 时钟频率

一个程序cpu时钟周期数=程序的指令数*每条指令平均周期数

每条指令平均周期数：CPI 

不同指令时钟周期不同

cpu时间= 指令数/程序 * CPI * 时钟周期时间



​                             指令数        CPI           时钟周期

算法与编程语言    Y    	    Y

编译程序                Y		Y

指令集体系结构    Y		Y		Y

计算机组成			       Y		Y

实现技术						  Y

乘法：指令集：提供乘法指令操作吗

​	    计算机组成：如何实现？乘法器？加法器+移位器？

​	    实现计数：材料，工艺，布线

单位

程序cpu执行时间 		程序执行的秒数

指令数 				  程序执行的指令数

CPI					每条指令平均时钟周期

时钟周期时间		      每个时钟周期秒数



相关性？

- 改isa减少了指令可能增加了时钟周期
- cpi减少可能增加时钟周期
- 缩短时钟周期可能增加了指令的条数
- 同一台机器同一问题，指令数少不一定块，其他可能慢

## 1.4.3三个例子

例子1 改变1个因素，影响另一个因素

一程序在4Ghz计算机A 10秒

设计一个时钟频率更高的B,执行时间6秒

提高时钟频率大致时钟周期数增加了1.2倍，计算机B的时钟频率

机器A  cpu时间频率4G    程序时钟周期数I   执行时间10秒

机器B			？？			    1.2I		6

cpu时间=时钟周期数/时钟频率=10s/4G

时钟频率=1.2* 10 * 4/6=8Ghz

机器B时钟频率是A两倍，速度却没有提升两倍

例子2

相同指令集，不同硬件

A   周期250ps。cpi 2.0

B           500	     1.2

cpu执行时间 = 指令数/程序* cpi *时钟周期

同样指令集，指令数一样

A = 指令数* CPI *时钟周期

   = 250*2I=500Ips

B=I*500 *1.2 = 600Ips

算法影响指令数 CPI 

算法决定源程序指令数

算法对快速指令的倾向性影响cpi，乘法比加法慢，浮点数比整数慢

编程语言

指令数 cpi

编程语言翻译为cpu指令，决定指令数

强支持数据抽象的语言要求简洁调用使用高cpi指令

编译器指令数 cpi

编译器决定指令翻译

指令集

指令数 时钟 cpi

完成功能需要的指令数，每条指令周期数和cou时钟频率

例三 不同代码段

编译器设计者在两个代序列上选择

A cpi 1 B cpi 2 C cpi 3

1   A 2 B1 C 2

2   A 4 B 1 C 1

A 5条指令 时钟 10 cpi2

B 6条指令 时钟 9   cpi1.5

同一基准程序在不同机器测运行时间，如何评价机器性能？

p1: A 1s B 10s

p2:A 1000s,B 100s

A B谁快

总执行时运行时间*出现频率



基准测试程序来预测机器实际负载的性能

# 第二章 指令系统

## 2.1指令系统概述

计算机的语言

普通人

应用程序员

汇编程序员

机器语言

二进制序列

指令

- 实现某个基本操作的命令

指令系统

计算机所有指令集合

软件层

编译 os 应用

硬件抽象 数字电路 数据通路 控制器 输入输出 指令

接口：指令系统

指令系统不是凭空而来

存储程序原理

指令/数据预先存放在计算机中

指令系统的设计？

设计原则

- 完备 该有的都有
- 有效  简洁，无歧义
- 规整 对称，均匀，一致
- 兼容性  前后都能用

兼容性：

- 上下兼任
- 前后兼容

指令系统包括

- 数据传输
- 输入输出
- 算术运算
- 逻辑运算
- 程序控制

指令系统设计派别

复杂cisc

大而全

vax-11

303指令

16寻址

9数据格式

操作符可变

每个指令执行时间长

- 系统复杂
- 指令周期长
- 各种指令访问寄存器
- 专用寄存器
- 微程序控制
- 难以编译优化产生高校代码

问题

- 研制周期长
- 难以保证正确，难以调试维护
- 机器时钟周期长，降低系统性能
- 效率低下
  - 20简单指令占比80
  - 占比20的复杂指令，占用80的控制寄存器容量

精简rics

john cock

小而精

1. 简化指令系统
2. 寄存器-寄存器方式工作
3. 指令周期段
4. 大量通用寄存器，减少访问内存次数
5. 组合逻辑电路控制，不用或少用微程序控制
6. 优化的编译系统，更好支持高级语言程序

伯克利 risc I

斯坦福 mips

ibm ibm  801

现代处理器大部分risc

x86为了兼容，保留cisc风格，借鉴了risc思想



## 2.2指令格式

指令是指挥计算机实现某个基本操作的命令

什么操作？ 操作吗

操作导对象？操作数

如何找到操作对象？寻址方式

操作吗 地址码

指令长度

1. 每条指令长度可以一样吗

指令长度

- 一条指令包括二进制代码位数
- 取决于操作码长度，操作地址长度和地址个数
  - 定长指令字：所有指令长度相同，向最长的指令对齐 risc 规整
  - 变长指令字：不同指令长度不同 cisc

每条指令操作码有几个？

一个 有效性：无歧义

具体的操作是怎样表示的？

一定的长度不同编码表示不同的操作

指令地址码几个？

0到多个 看操作码

零地址 op 堆栈

一地址 op a1 累加

二地址 op a1 a2 最常用

三地址 op a1 a2 a3 通用寄存器

多地址指令

地址码个数与性能和实现难度密切相关

## 2.3 如何找到操作数 寻址问题

地址如何编码？寻址方式决定

操作码 地址码

长度限制 给出逻辑地址 通过寻址找到物理地址

**为啥不直接把操作数放操作吗后面**，**就不寻址了**？

地址码位数有限，更大的操作数无法支持

**为什么不把操作数物理地址放进，就不需要寻址了**

地址吗位数有限，放不下多少操作数地址。

而且寄存器非常少。

以一个32位指令为例，操作码12位，地址码只有20位·，直接寻址空间只有2^20次，1MB的寻址空间

寄存器少，能放操作数非常少

无法满足我们的要求

寻址方式

- 扩大访存范围
- 提高访问数据的灵活与有效
- 支持软件计数发展，多道程序设计

寻址方式

- 寻找操作数
  - 操作对象寻找
- 寻指令
  - 下一条指令的地址
- 通常指代操作数寻址

指令寻址——简单

正常 pc增1

跳转：同操作数的地址



操作数寻址——复杂

- 操作数的来源：寄存器/外设/主存/虚存/栈顶
- 操作数据结构：位/字节/半字/字/双子/一维表

## 2.4 数据在计算机的表述

为什么二进制编码？

- 开关表示，物理器件简单
- 二进制，编码，计数，运算简单
- 逻辑命题对应，便于逻辑运算，方便使用逻辑电路实现

真值和机器数

- 机器数：0 1编码 计算机内部的 0 1 序列
- 真值：机器数真正的值，即：现实中带正负的数

数据在计算机内部如何表示？

整数/负数/整数/小数/逻辑数



数据表示

——能倍计算机硬件识别的数据类型

1. 可用计算硬件直接表示
2. 可以由计算机指令直接调用

数据表示和数据结构的关系

- 数据表示是研究硬件如何识别数据类型
- 数据结构是在数据表示基础上，如何计算机处理硬件不能直接识别的数据类型

数据的不同抽象

文字，图，表，声音等 用户级别

输入输出设备

程序员

二进制表示的各种数据

树图链表等结构化数据

系统设计者

指令能识别的基本类型

- 数值型数据
  - 二进制数
    - 整数
      - 无符号
      - 有符号
    - 实数 ：浮点数
  - 二进制编码的其他进制的数
- 非数值型数据
  - 逻辑数据
  - 西文字符和汉字

数据宽度

位 ：计算机存储处理传输最小单位

字节：二进制计量单位

​	 主存按字节编址，字节是最小可寻址单位

字 word 被处理信息的单位，度量数类型宽度

子长是cpu数据通路的宽度，等于cpu内部总线的宽度或运算器的位数或通用寄存器的宽度

字和字长的宽度可以一样，也可以不同，通常是字节的整数倍

intel386 字长32 字 16

常用数值数据

定点数、浮点数、十进制数

解决的问题：

- 整数与负数的表示
- 小数点的表示
- 零的表示
- 实数的表示

问题1 如何表示正负数

解决办法：设置符号位

0 正数 1 负数

第1位不代表数，代表符号

```
例子1
x = +90   二进制 1011010

八位二进制源码：    01011010
```

```
例子2
x = 190   二进制 -1011010

八位二进制源码：  11011010
```

## 2.4.2 数值数据的定点显示

问题2 **小数点如何表示**

区分其他数，且记录小数点

解决办法：小数点固定在固定位置

定点数

- 小数点左边的二进制是整数，右边是小数
- 计算机通常将数分为定点整数和定点小数
- 小数点在数据类型里默认（程序员心里）

定点数在机器中表示

整数 符号 数值

定点整数：小数点固定在最低位的右边

​		   表示范围 （0，2^n-1）1

定点小数：小数点固定在数值部分最高位左边

​		表示范围（0，2^-n）

问题三：**如何表示零**？

一个数不是整数就是负数，0不是正数也不是负数，符号位咋办？

区分正零和负零

```
x=+0
八位二进制
原码 00000000
反码 00000000
补码 00000000
```

```
x=-0
八位二进制
原码 10000000
反码 11111111
补码 00000000
```

反码：正数不变

​	   负数 符号位不变，数值位取反

补码：整数不变

​	   负数反码+1

补码解决了同一个数不同表示的问题，广泛应用于现代计算机

## 2.4.3 数值数据的浮点表示

问题4 如何表示实数？

实数：尾数和指数（阶码）——浮点数表示

25.75 = 2.575*10^1 十进制

​	  = 11001.11 二进制真值

​	  = 1.100111 *  10^100 二进制

科学计数法

尾数

十进制小数点

阶码：改变小数点位置

基

二进制

- 尾数 定点小数
- 阶码 定点整数

小数点导致一个数有多种表示方式 1/1000000000

1.0*10^-9  0.1 * 10^-8  10.0 * 10^-10

规格化格式：小数点只有一位非0数 1.0 * 10^-9

二进制规格

浮点数总位数不变的情况下，提高数据表示精度，尾数有效数字尽可能占满已有位数

会当属规格化 1/2<=abs(f)<1

右规:f>1

右移1位，阶码加1

11.01100111 * 10^101

0.11011001 * 10^111

左归 f<1/2

左移1位，阶码减一

0.00110011 * 10^101

0.11001100 * 10^011

浮点数 ieee 754 图灵讲

符号s

阶码e 整数

尾数f 小数

尾数f

- 尾数为原码
- 规格化尾数最高位1，隐含表示，省一位

尾数=1+signed   signed(0,1)

阶码为0专门表示数值0

​	1+23bit(单精度)，1+52bi(双精度)

​	float double

尾数精度=尾数位数+1

**阶码**e

移码表示   

移码：数值加一个偏置常数

-8+（+8）=0000

0（+8）= 1000

移码表示阶码

便于浮点数对接

浮点数对接操作转换阶码小的数

比较两个数：从左到右依次比较

-2 1110     0110

3   0011    1011 比较了阶码大小

按位比较是错误的

偏置常数

单精度 偏置常数 127

双			  1023

单精度阶码 -126——127

全0 1表示特殊值

双精度

浮点数——真值

单精度 = (-1)^s * (1+signficand) * w(exp-127)

双精度 = (-1)^s * (1+signficand) * w(exp-1023)

 浮点数精度尾数f决定

浮点数表示范围基数R和阶码e决定

阶码 基数表示尾数越大，表示范围越大

练习1 二进制浮点数转ieee754

十六进制表示

bee00000H

1011 1110 1110 0000 0000 0000 0000 0000

符号位1 负数

阶码

01111101 = 125

125-127=-2

尾数1+0.5+0.25=1.75

表示 -1.75 * 2^-2

-0.4375

练习2 十进制到浮点数

-1.275 * 10^1

1. 计算真值 -12.75

2. 整数部分转换 12 = 8+4  1100

3. 小数变换 0.75 = 0.5+0.25=0.11

4. 规格化

   ​	1100.11=1.10011 * 2^011

5. 移码表示阶码

127+3 = 130 = 10000010

1100 0001 0100 1100 0000 0000 0000 0000 16进制C14C0000H

全0 全1

阶码   尾数  数据

1-254  任意  规格化数

0	 0		？0

0  	非0	？非规格化

255 	0	？+∞	

255	非0	？非数NaN 0/0  -4开平方 无穷的运算

如何表示0

阶码 0

尾数 0

符号位随便

正零负零都是零

正负无穷

阶码 255

尾数 0

符号为正负

单精度 32位

双精度 64位

## 2.4.4数据数值的十进制表示

- 能否直接表示10进制数

十进制数的二进制编码

ascii

bcd码

十进制看成字符串

十进制0-9代表30H-39H

一位十进制对应8位二进制

符号位？

前分隔数字串

- 符号位用一个字节表示，位于数字串之前
- 正号 + 2BH表示
- 符号 -   2DH表示

十进制数 + 236 

2B 32 33 36H

十进制 -2369 表示

2D 32 33 36 39H

后嵌数字穿

符号位嵌入最低位数字的ascii的最高4位，省一个字节

- 正数：最低位数字的高四位不变
- 负数：最低位数字高4位，变为0111

十进制 236 3233 36 H

十进制-2369 32 33 36 79H

**BCD码**

0-9 每个十进制需要4位二进制

4位二进制组合16个状态，有冗余

8421码：十进制有权码 

2 的 3 2 1次方 十进制无权码

其他 5中取2 读热码

编码思想

+ 1100 +
+ 1101   -
+ +236 = 1100 0010 0011 0110 两个字节
+ - 2369 1101 0010 0011 0110 1001 1001 8432码
    - ​             110100000010001101101001补零

## 2.4.5 字符数据的机器表示

西文特点

- 语言文字，几个可以组合为单词
- 对少量字母和一些数字符号，标点符号进行复制编码
- 所有西门字符不超256，用8个二进制位存放

汉字特点

- 汉字表意
- 含子传输大，超6w，给汉字表示，传输，io交换，一系列问题

编码形式

- 输入吗：每个含子使用按键进行编码，用于输入
- 内码：系统存储查找传送
- 学校代码和轮廓环境：描述含子点阵，解释加湿机



## 2.4.6 数据的度量与存储

描述信息不同单位换算不同有1024也有1000

数据存储方式

现代计算机都是字节编址

int 4个字节

isa设计考虑问题

- 如何基于一个字节地址取到多个字节的字   **字的存放**
- 一个字能否存放在任何字节边界                   **自动边界对齐**

例子 int i = 0x01234567，存放在内存100号，使用取数指令从100号去除i，程序员必须清楚i的4个字节如何存放

01 23 45 67

msb        lsb

msb字最高有效位

lsb字最低有效位

多字节 两种方式

大端 小端方式

大端 msb是数的地址 低地址    lsb高地址

mips ibm360

小端  lsb是数的地址   低地址    msb高地址

80386

有的机器都支持，需要特定控制位

```
struct{
    char c;
    short si;
    int i;
    float sf;
}rec_var={0xab,2098,-1028,0.625}
```

2098 =0x0832,

-1028=0xfffffbfc

0.624=0x3f20

大端机

```
00 01 02 03 04 05 06 07
ab 08 32 ff ff fb fc 3f
08 09 0a 0b 0c 0d 0e 0f
20 00 00 00 00 00 00 00
```

小端机

```
07 06 05 04 03 02 01 00
20 ff ff fb fc 08 32 ab
0f 0e 0d 0c 0b 0a 09 08
20 00 00 00 00 00 00 00
```

**字节交换**

- 存放方式不同的机器之间程序移植或数据通信发生问题
- 存放方式不同，数据访问需要进行顺序转换
- 音频，视频，图像也会遇到这种问题

**数据对齐**

目前数据字长32 64字长，存储器按字节编址

指令系统支持字节 半字 字 双字运算 也有按位处理的指令

不同长度的数据存放，有两种处理办法

- 按边界对齐（假定字宽32位，存储器按字节编址）
  - 字地址 4的倍数 低两位 0
  - 半字地址 2的倍数 低位0
  - 字节地址 任意
- 不按边界对齐

例子：假设数据顺序 字 半字 双字 字节 半字

int i,short i,double x, char c,short j

边界对齐

&i=0

&k=4

&x=8

&c=16

&j=18

x 2个周期

j 一个周期

不对其

地址分别是 0 4 6 14 15

x 3个周期

j 2个周期

效率变低了

## 2.4.7 数据出错

数据差错咋办？

具体措施

- 计算机硬件提高可靠性，

电路，电源布线增加抗干扰能力

- 数据检查错误，与校正错误，自动的发现并纠正

如和错误检测和矫正？

冗余校验，增加校验位

计算的校验位与读出的比较，不一致则错误

1. 未检测错误，直接输出
2. 检查到错误可以纠错，数据为和比较结果一起送入纠错器，将整错的数据输出
3. 检查到错误，无法纠错，输出错误信号

奇偶校验码

- 增加一个奇偶校验位一块传输存储，目的不见计算校验位并比较，根据比较得出是否发生错误

步骤

- 源不见算奇偶校验位 P

- 目的部件算P'

- 计算最终校验位p*=p异或p'，判断是都出错

1 奇数位错误

0 正确或偶数错误

特点

- 奇数位不同，校验位不同
- 偶数位不同，校验相同，至少两个数据出错
- 只能发现奇数错，不能发现偶数错，不能纠错
- 开销小，校验一字节长的代码，用于存储器写检查或字节传输的数据校验

## 2.4.8 基本指令和指令系统

1044年哈佛 markI

存储器带线啊哦 32字

机器字长 32

6条指令：

- jump 跳转
- load accumulator 操作数加载
- subtract
- store accumulator 存入累加器
- test for zer0 分支跳转
- stop 停机

**完善的指令系统**

- 数据传送指令move store load exchange
- 算术运算指令 定点数、浮点数、十进制数
- 逻辑运算指令 and or not compare
- 数据转换 字节与正数转换
- 输出输入 in out
- 系统控制 启动io设备，存取特殊寄存器
- 程序控制   转移 循环控制 子程序调用call ret 程序中断与返回int iret

**数据传送指令**

功能

- 寄存器与寄存器，寄存器与存储单元以及存储单元之间的数据传送

表征参数

- 源操作数地址，可由指令给出  发件人地址
- 目的操作数地址 指令给出        收件人地址
- 传送数据长度 ，指令隐含     物品数量

L 取数 4个寄存器

**算术逻辑运算指令**

功能

- 二进制加减乘除基本运算

算术运算指令的操作过程

- 源操作数传输到alu     数据的传送
- 进行运算
- alu计算结果传送到目的操作数地址单元

逻辑运算指令

- 按位进行运算，针对任何一种可寻址单元位进行操作
- 运算基础是布尔代数，与或非异或，位运算，移位

**程序控制指令**

功能

- cpu执行程序时候，执行一条指令后，程序计数器pc+4,打破顺序，需要程序控制指令
- 循环 分支 子程序调用用得到

**转移指令**

功能：改变cpu执行顺序，cpu到新地址执行后续操作

分类

**无条件转移**：直接控制转移到指令所指的目标，从那里开始执行，cpu在无条件转移指令时候只需要转移目的地址进入程序计数器pc就可以

**条件转移**：条件满足时候转移到指令所制定目标，否则顺序执行下一条指令

方法：条件吗。条件寄存器，比较返回指令



**子程序调用返回指令**

子程序

经常使用、独立完成特定功能的程序段，独立出来为其他语句调用的整体

使用子程序的优势

- 降低程序设计复杂度
- 提高程序复用性
- 节省存储空间
- 模块坏程序设计的基础，子程序库

子程序

主程序

- 专门的调用指令 call  返回ret指令
- 子程序调用和返回，实质是程序控制的转移
- 主程序是主动的，预知的，子程序是被动的，不能预知什么时候被调用，什么时什么位置调用

子程序设计解决的问题

1. 调用程序与子程序的调用返回
2. 参数传递
3. 公用寄存器问题

堆栈法

主程序M和两个子程序A B，M调用A,A调用B

M

MA

MAB

MA

M

**子程序调用和跳转指令的区别**

- 子程序要求返回，递归嵌套调用也行，转移指令不要求返回，也只出现再同一程序段
- 子程序用于程序之间转移，转移指令实现程序内的转移

call x;

x是子程序地址，Δ是指令长度

寄存器存返回ra = pc+Δ

​			pc=x

**如何递归嵌套调用**、

- 寄存器存放返回地址
  - 单寄存器不支持递归嵌套
  - 多寄存器支持嵌套，不支持递归

- 子程序起始位置
  - 支持嵌套，不支持递归



**参数传递**

调用程序提供i程序一便加工处理的称为入口参数

子程序加工处理后送回调用程序的信息是出口参数

参数传递方法

- 约定寄存器法
- 阅读存储单元法
- 参数赋值法
- 堆栈法

**寄存器共用**

- 子程序开始保护现场，返回前恢复现场

- 保护和恢复现场原则：破坏什么现场就保护什么现场，保护什么现场就恢复什么现场
- push指令构成保护程序段，pop构成恢复程序段，栈先进后出

**子程序结果**

- 保存现场
- 依据入口参数从指定位置索取加工信息
- 加工处理
- 依据出口函数向指定位置输出加工后的结果信息
- 恢复现场   当时的寄存器内容恢复回来
- 返回调用程序

**输入输出指令**

- 专用的io指令：两个操作数（数据地址，外部设备地址）

x86的 in out 指令

- 通用数据传输：存储器映像的io操作。外部设备寄存器与主存统一编址

- io处理机完成：通道和iop

**系统控制指令**

- os执行，不给用户的特权指令，处理机特权状态才能执行

- 实现：控制寄存器操作，检测或修改访问权限，改变系统工作方式，访问进程进程控制块，多用户，多任务环境使用
- 一半用户需要计算机系统特权服务，通过系统控制指令发出请求，操作系统处理，结果返回用户



基本指令和指令类型

- 数据传送指令
- 算术逻辑指令
- 程序控制指令
- 输出输出指令
- 系统控制指令



## 2.5 程序的计算机表示

程序的机器级表示

mips指令32位宽，字地址对齐



mips三种指令

R-型（用于寄存器）

- 两个操作数
- 操作数都是寄存器
- sub rd rs rt

op 6   操作吗

rs 5  第一个源操作数寄存器

rt5 第二个源操作数寄存器

rd 5 结果寄存器

shamt 5 位移指令的位移量 一般不用

funct 6 功能码 扩展操作码的功能

例如：R型指令op字段特定的000000 具体操作由funct字段给出

funct 100000表示加法 100001 减法

I型

- 运算指令：一个寄存器，一个立即数。入：ori rt rs imm16
- load store指令 lw rt rs imm16
-  条件分支 beq rs rt imm16

op 6

rs源操作数寄存器 5

rt源操作数寄存器 5

immediate 16 立即数，分支转移的地址

J型

- 无条件跳转

op 6

target address 26	无条件转移的低26位



mips寻址

R 型 寄存器直接寻址

I 型 

- 立即数寻址
- 基址寻址
- pc寻址

J型

26位怎么寻址

mips指令32位宽，字地址对齐

低两位一定是00

pc高四位+26位地址+00来组成一个地址



距离汇编与机器指令的对应

mips 的对应

add $        $ t0 ,      $s1,     $s2

funcr	rd(结果)rs	rt(过程)

op 6

re 5

rt 5

rd 5

smt 5

funct 6

0   17   18   8    0    32 十进制

R   s1    s2   t0   no  add

6    5    5    5     5    6、

000000 10001 10010 01000 00000 100000

这个过程是汇编，汇编成二进制机器代码

例子 取一条指令 00AF8020H 汇编是个啥？

32位代码 0000 0000 1010 1111 1000 0000 0010 0000

op rs rt rd shamt funct

6 5 5 5 5 6

前6位000000 R型

000000   00101  01111 10000 00000 100000

add 

rs rt rd  5 15 16

​	   a1 t7 s0

add s0 as t7     

a1+t7---> s0

反汇编   机器指令到汇编

可破解二进制代码（exe）

 漏洞 逆向 汉化

mips操作数

**寄存器的指定**

- 32 * 32 grps r0=0
- 寄存器编号 5 位
- f0 f31 双精度浮点
- HI LO PC：特殊寄存器HI LO乘除法运算结果

寄存器

- zero  0   恒为0
- at      1   汇编器保留
- v0-v1 2-3   过程调用返回值value for return
- a0-a3 4-7 过程调用参数argument
- t0-t7 8-15 临时变量
- s0-s7 16-23 保存 save
- t8-t9  24-25  其他临时变量 temp
- k0-k1 26-27 os保留
- gp       28     全局指针 globol pointer
- sp       29      栈指针 srack pointer
- fp       30      祯指针 frame pointer
- ra        31     过程调用返回地址return address

过程调用

v0 v1返回 a0-a3参数 ra返回地址

register数字 名称

0号恒为0 r1+r0 ->r2 将r1送到r2

因此没有寄存器传值的指令



存储器数据指令

- load store访问存储器数据
- 字节编址，边界对齐
- 大端方式
- 访问空间 4gb 2的32次方
- 访存地址通过32位寄存器内容加16位偏移量得到，16位偏移是有符号整数
- 字地址相差4字节
- 可以前后偏移

mips指令类型

算术逻辑

add sub multiply  add or xor

add    

sub

addi 加一个立即数

mul  乘法结果 高32 Hi低32 Lo

div 除法  只需要除数  缺省被除数  Lo商  Hi余数

and

or imm

xor

nor



数据传输

sw 存1个字

sh 存半个字

sb 存字节

lw

lh

lb

同上

操作数长度有操作码来决定

不同长度的操作数？

高级语言的多种数据类型

char short int long 

条件分支

beq 相等跳转

if(s1=s2) goto Pc+4+100

bne branch on not eq if(s1!=s2) goto pc+4+100

**pc+4?**

pc自动更新下一条地址

下一条指令的地址

slt set on less than slt 1  2   3  if(S1<S3) S1 =1,else S1 =0

slti  set less than imm    slti 1 2 100  if(S2<100)S1=1,else S1 =0

条件码 状态吗 标志位

通过执行算术指令或比较测试指令来设置条件码

例子

sub r1 r2 r3  r2 r3 结果存放r1 生成标志物ZF/CF

bz label  标志位ZF=1,转移到label除

标志位

sf  符号

of 溢出

cf 进位

zf 判0

- 可以存放在标志寄存器/程序状态字 psw
- 也可以放通用寄存器

例子

cmp r1 r2 r3  比较 r2 r3 标志位r1

bgt r1 label   判断r1大于0，转移到abel处

两条指令合成一条：计算并转移

bgt r1 r2 label   r1 r2 比较  决定时候转移

不同处理器，对标志位处理不同

状态标志位举例

将字节59H和6CH相加，Flags四个状态标志设置为上面值

01011001

01101100

11000101

进位 没有CF进位标志 0

符号  1      SF 符号标志1

溢出   正+正=负 溢出 OF溢出标志1

是否为0 不是0              ZF  零标志 0



条件分支

无条件处理器根据算法结果设置CF OF标志

CF 进位 运算结果**无符号数**

OF 溢出 运算结果视为**有符号数**

溢出与进位/借位区别

- 进位/借位CF 无符号数  是否超出范围，如果超了，保存了进位和借位，结果依然正确
- 溢出标志OF表示有符号数运算结果是否超出范围，超了则结果不不正确



**无条件跳转指令**

**jump** 转移目标地址 j

伪直接寻址方式

**jump** **and** **link**  jal

- 首先保存返回主程序的地址，pc+4  goto 100000 

- 然后将jump的地址赋值pc，跳转过去

- 返回时候用100000地址返回

**jump** **register**

jr  31号寄存器寻址

指令设计

简单源自规整

越少越快

- 寄存器太多，硬件复杂，时钟周期边长
- 寄存器32个

c编译汇编

```
c =  (g+h)-(i-j)
```



```
add t0 g h    #t0=g+h

add t1 i j     # t1 = i+j

sub f t0 t1     #f = t0-t1
```

有问题吗？

操作数必须来自寄存器

编译时候寄存器与程序变量必须对应，fghij分别分配寄存器s0 s1 s2 s3 s4



```
add t0 s1 s2
add t1 s3 s4
sub s0 t0 t1
```

常数，存储器读出，避免访问常数，提高常数的快速运算指令——立即数操作指令

原则——加速常数操作

addi

指令长度相同

不同的指令格式

均衡地址

## 实验1



- 高级语言与机器表示
- 数据类型转换及运算
- 处理器设计与实现
- 运算器设计与实现
- 趣味实验

### 1实验环境介绍

gcc使用方法

源程序到目标代码

机器语言到汇编语言

机器语言与指令集结构

虚拟机vmware

虚拟机操作系统 xp

编译 gcc

编辑 ultraedit

## 2 gcc使用方法

编译代码

vs

eclipse



推荐gcc

gnu c cpmplier

c c++ java 

gun gun's not unix

理查德马修斯托曼

哈佛 mit

自由软件运动人

gcc

vs compile选项

四阶段

hello.c

- 预处理   hello.i
- 编译 hello.s
- 汇编 hello.o
- 连接 hello.exe

gcc分阶段处理

gcc 常用命令

gcc options filenames

​	参数   名称

**gcc --help**

帮助文档：可调用的选项查看

**gcc -E hello.c -o hello.i**  预处理

-E仅仅预处理

-o输出文件的名称

预处理

**编译处理**

gcc -S hello.i

编译为 hello.s  

-S 只文件进行编译

**汇编处理**

gcc -c hello.s 

**链接处理**

gcc hello.o -o hello.exe

链接明确指出生成exe

gcc hello.c -o gcc hello.exe

一条龙

## 3 源程序到目标代码

预处理 -E .c   .i

预处理

```C
#include<stdio.h>

int main(){
    printf("hello world!\n");
    return 0;
}
```

printf使用了stdio.h的代码

.i文件

mian前面出现了stdio的代码

对#代码进行处理

```
#inlude进行包括到代码中
```

.i还是高级语言



-S .i  .s文件

汇编语言，与指令集有关

汇编不能直接移植

高级语言可以移植

原因：高级语言编译为本平台的汇编代码

助忆符

地址符号

汇编

可重定位的目标文件 二进制

链接

可执行目标文件 二进制

差别：

- .o不能直接使用
- 引用来其他文件的代码
- 把库函数目标函数模块合并printf合并

exe 打印一个字符

# 第三章 计算机的运算

## 3.1基本计算

25*4+40/4-13







