# 计算机原理

## 第一章 计算机的抽象与艺术

## 1.1 概述

计算 实验 理论科学研究三大方法

成功的程序员关心程序的性能

决定程序性能的因素

- 算法——数据结构、算法设计
- 创建程序并翻译为机器指令的软件——编译原理
- 计算机各部件执行效率——计算机原理、操作系统

本课：计算机组成结构

算法：决定源程序语句数量及执行io操作数量

程序语言、编译器和体系结构：决定每条程序语句对应的机器指令

处理器、存储器系统：决定指令的执行速度

io系统（硬件和操作系统）：决定io操作的执行速度

## 1.2 程序的表象之下

如何与计算机沟通

高级程序语言计算机无法理解

简单的软硬件层次化结构

- 隐藏低层次的是实现细节，简化各层次的用户的使用
- 每一层为上一层隐藏了自己的技术细节——抽象

硬件 系统软件 应用软件

系统软件：提供公共服务程序

**操作系统**

- 用户程序和硬件的接口，提供计算机的资源管理
- 功能：处理基本的输入输出功能、分配存储空间、为多个程序同时使用计算机提供支持

**编译器**

将高级语句翻译成汇编语句的程序

**汇编器**

汇编语言是一台计算机指令系统的符号化表示

汇编器将汇编语言中的符号指令翻译成计算机能够识别的二进制指令

**计算机的层次结构**

电路设计

数字系统设计

cpu 主存 io

编译器 操作系统

应用程序

计算机层次结构中，指令系统是软/硬件的交互面

isa:屏蔽硬件实现细节，简化程序员的使用

 不同用户工作在不同的层次，看到的计算机不一样

终端用户：应用程序层，如何使用应用程序

应用程序开发人员：程序设计语言层，使用编程语言编程

系统管理员：操作系统层，使用系统工具与命令

系统程序员：操作系统编译器开发人员：了解软硬件工作原理

分析

**如何使用计算机求解一个问题**

- 将问题求解通过输入设备告诉计算机
- 计算机调用相应的运算部件求解
- 将结果输出到输出设备

一个c语言的生命周期

**问题的高级语言描述**

高级语言 c java python go

sum.c

```c
#include<stdio.h>
int main(){
    nt c;
    18+40;
    printf("result is : %d\n",c);
}
```

预处理阶段

将# include内容插入到文本中

编译阶段

翻译为汇编

gcc -S sum sum.c

```
dw C equ//双字长变量C

mov A,12H;
ADD A,28H;
MOV C,A

```

16进制的12 28是十进制的18 40

高级语言源程序

编译器

汇编语言程序

汇编器

机器语言模块

**汇编到机器语言**

主存地址 指令或数据 说明

​		 D8       12H      取数 A   12H    向寄存器存数

​		05         28H       加法 A   A+28H

​		A3        30H       存数：30H  A  向主存存数

​		F4                       停机

​	

​		初始数据

​		3AH                   结果数据

编译汇编链接加载

二进制机器语言程序

硬盘中的可执行文件

**高级语言源程序**

编译

**汇编语言程序**

汇编

目标文件：**机器语言模块**  **库程序模块**

链接

**可执行文件**：**机器语言程序**

加载   操作系统调度或者boot指引

**存储器二进制机器指令流**

cpu 取指，译码，控制单元

**电路上电信号**

cpu运作   外设运作



**计算机内部工作流程**

逐条执行加载到内存的二进制机器指令流的过程

- 一条指令执行 两个操作阶段
  - 取指姐u但，cpu内存读取指令，程序计数器保存到被去除下一指令的地址，除非遇到挑战指令，否则pc一半在每次取指后增加一个增量（当前指令的字节数）

计算机系统基本执行结构

cpu与内存

PC 指令计数器

AR 地址寄存器

pc 00H

送AR 

pc+2

pc 02H

00H地址译码

D8H 12H

读数据

D8H送到指令译码单元

操作数到累加器

操作数到DR 

到累加器

1.3.1打开计算机机箱——冯诺伊曼架构

ENAIC

电子数字计算机

缺点：

开关和连接线设置指令程序，程序设计麻烦，低效

思考

程序存储在机器中，由它控制机器操作

**存储程序原理**

将事先设计好，用以描述计算机解题过程的程序如同数据一样，二进制形式存储在机器中，计算机工作时候自动高速从机器去除指令并加以执行

存储程序

不使用存数程序

计算器

- 数据指令都是人按键输入

操作在人脑而不是机器中

enaic修改电路类似于计算器按键

如果操作指令和数据被存放在存储器中

控制器自动取指令和数据，控制计算执行

**机器完全自动化**

计算机按照顺序自动执行

不同出入不同结果判断改变解题步骤

一个程序产生另外一个程序

播下了程序设计语言和人工智能种子



冯诺伊曼结构结构

输入

输出

存储

运算

控制

总线连接



非冯诺依曼模型

神经网络

生物计算机

量子计算机

## 1.3.2 打开计算机的机箱

电源

风扇

主板

内存条

光驱

硬盘

cpu

功能

- 执行程序
- 控制单元与数据通路
- 控制单元对指令译码，产生控制信号
- 数据通路：完成指令的执行
- 核心是alu+寄存器
- ALU执行算术，逻辑运算
- 寄存器：临时存放数据或控制信息：pc IR

存储器：仓库

功能：存储程序和数据

组成：层次化结构

- 内存：cache+mm
- cache：最近使用的数据和指令
- 主存：存放被启动的程序的部分数据和指令
- 外存：磁盘，固态，光盘，磁带

io

功能：信息输入输出

组成：io控制器,io设备

io控制器：控制外设工作，完成通信

io设备：输入输出信息

键盘，打印机，鼠标，显示器

总线：连接一块

电路板 集成电路 模块 逻辑单元 门电路

越深入，细节越多

隐藏起来，简洁模型

抽象 分层

## 1.4_1 评价计算机的性能

性能指标

- 响应时间
  - 执行时间，等待时间
- 吞吐率
  - 带宽
- 指令执行速度

功耗

如何定义计算机性能比另一个好？

民航客机：载客量、续航能力、巡航速度、运载能力

巡航速度

吞吐率

性价比

不同的标准不同的结果

x比y块？

不同的性能标准

- 完成单个计算任务的时间
  - 响应时间
  - 执行时间
  - 等待时延
- 单位时间完成的任务量
  - 吞吐率
  - 带宽

不同场景性能不同

- 吞吐率高的场合——多媒体应用
- 响应时间——事务处理系统
- 双高——ATM,文件服务器，web服务器

如何提高相应时间和增加吞吐率？

1. 处理机换更好的
2. 多个处理器分别处理，如万维网

加响应肯定加吞吐

加吞吐不一定加响应

如果有排队情况，加吞吐也可加响应

响应时间越来越小

性能：执行时间的倒数

 一个程序A10秒 B15秒

A是B1.5倍

比较计算机性能，响应时间来衡量

- 同样的工作量，完成时间短的性能好
- 处理器时间往往被多个程序共享使用，用户感觉到的程序执行时间不仅仅是程序真正执行的时间

系统响应时间（用户感觉的）

- cpu执行时间：cpu花费在程序执行的时间
  - 用户cpu时间：运行用户代码的时间
  - 系统cpu时间：执行用户程序而运行操作系统代码的时间
- 其他：io操作或其他cpu花在别的程序的时间

计算机系统性能！=cpu性能

- 系统性能：系统响应时间
- cpu性能：用户cpu时间

cpu真正执行用户程序的时间

## 1.4.2 cpu执行时间

度量cpu执行时间

一个程序cpu执行时间

执行一个程序需要的计算机基本时间单元的数量*基本时间单元

时钟周期

- 所有计算机都有一个固定频率的硬件时钟，决定各个因该你事件发生和执行的事件和顺序
- 硬件时钟产生的离散时间间隔称为时钟周期

时钟频率

- 时钟周期的倒数

时钟周期250ps,时钟频率为

1/（250*10-12）=0.25 * 10-9 =4*10^9=4GHz

cpu的主频就是时钟频率

cpu执行时间=程序的cpu时钟周期数*时钟周期时间

改进性能

- 时钟周期数
- 时钟频率

一个程序cpu时钟周期数=程序的指令数*每条指令平均周期数

每条指令平均周期数：CPI 

不同指令时钟周期不同

cpu时间= 指令数/程序 * CPI * 时钟周期时间



​                             指令数        CPI           时钟周期

算法与编程语言    Y    	    Y

编译程序                Y		Y

指令集体系结构    Y		Y		Y

计算机组成			       Y		Y

实现技术						  Y

乘法：指令集：提供乘法指令操作吗

​	    计算机组成：如何实现？乘法器？加法器+移位器？

​	    实现计数：材料，工艺，布线

单位

程序cpu执行时间 		程序执行的秒数

指令数 				  程序执行的指令数

CPI					每条指令平均时钟周期

时钟周期时间		      每个时钟周期秒数



相关性？

- 改isa减少了指令可能增加了时钟周期
- cpi减少可能增加时钟周期
- 缩短时钟周期可能增加了指令的条数
- 同一台机器同一问题，指令数少不一定块，其他可能慢

## 1.4.3三个例子

例子1 改变1个因素，影响另一个因素

一程序在4Ghz计算机A 10秒

设计一个时钟频率更高的B,执行时间6秒

提高时钟频率大致时钟周期数增加了1.2倍，计算机B的时钟频率

机器A  cpu时间频率4G    程序时钟周期数I   执行时间10秒

机器B			？？			    1.2I		6

cpu时间=时钟周期数/时钟频率=10s/4G

时钟频率=1.2* 10 * 4/6=8Ghz

机器B时钟频率是A两倍，速度却没有提升两倍

例子2

相同指令集，不同硬件

A   周期250ps。cpi 2.0

B           500	     1.2

cpu执行时间 = 指令数/程序* cpi *时钟周期

同样指令集，指令数一样

A = 指令数* CPI *时钟周期

   = 250*2I=500Ips

B=I*500 *1.2 = 600Ips

算法影响指令数 CPI 

算法决定源程序指令数

算法对快速指令的倾向性影响cpi，乘法比加法慢，浮点数比整数慢

编程语言

指令数 cpi

编程语言翻译为cpu指令，决定指令数

强支持数据抽象的语言要求简洁调用使用高cpi指令

编译器指令数 cpi

编译器决定指令翻译

指令集

指令数 时钟 cpi

完成功能需要的指令数，每条指令周期数和cou时钟频率

例三 不同代码段

编译器设计者在两个代序列上选择

A cpi 1 B cpi 2 C cpi 3

1   A 2 B1 C 2

2   A 4 B 1 C 1

A 5条指令 时钟 10 cpi2

B 6条指令 时钟 9   cpi1.5

同一基准程序在不同机器测运行时间，如何评价机器性能？

p1: A 1s B 10s

p2:A 1000s,B 100s

A B谁快

总执行时运行时间*出现频率



基准测试程序来预测机器实际负载的性能

# 第二章 指令系统

## 2.1指令系统概述

计算机的语言

普通人

应用程序员

汇编程序员

机器语言

二进制序列

指令

- 实现某个基本操作的命令

指令系统

计算机所有指令集合

软件层

编译 os 应用

硬件抽象 数字电路 数据通路 控制器 输入输出 指令

接口：指令系统

指令系统不是凭空而来

存储程序原理

指令/数据预先存放在计算机中

指令系统的设计？

设计原则

- 完备 该有的都有
- 有效  简洁，无歧义
- 规整 对称，均匀，一致
- 兼容性  前后都能用

兼容性：

- 上下兼任
- 前后兼容

指令系统包括

- 数据传输
- 输入输出
- 算术运算
- 逻辑运算
- 程序控制

指令系统设计派别

复杂cisc

大而全

vax-11

303指令

16寻址

9数据格式

操作符可变

每个指令执行时间长

- 系统复杂
- 指令周期长
- 各种指令访问寄存器
- 专用寄存器
- 微程序控制
- 难以编译优化产生高校代码

问题

- 研制周期长
- 难以保证正确，难以调试维护
- 机器时钟周期长，降低系统性能
- 效率低下
  - 20简单指令占比80
  - 占比20的复杂指令，占用80的控制寄存器容量

精简rics

john cock

小而精

1. 简化指令系统
2. 寄存器-寄存器方式工作
3. 指令周期段
4. 大量通用寄存器，减少访问内存次数
5. 组合逻辑电路控制，不用或少用微程序控制
6. 优化的编译系统，更好支持高级语言程序

伯克利 risc I

斯坦福 mips

ibm ibm  801

现代处理器大部分risc

x86为了兼容，保留cisc风格，借鉴了risc思想



## 2.2指令格式

指令是指挥计算机实现某个基本操作的命令

什么操作？ 操作吗

操作导对象？操作数

如何找到操作对象？寻址方式

操作吗 地址码

指令长度

1. 每条指令长度可以一样吗

指令长度

- 一条指令包括二进制代码位数
- 取决于操作码长度，操作地址长度和地址个数
  - 定长指令字：所有指令长度相同，向最长的指令对齐 risc 规整
  - 变长指令字：不同指令长度不同 cisc

每条指令操作码有几个？

一个 有效性：无歧义

具体的操作是怎样表示的？

一定的长度不同编码表示不同的操作

指令地址码几个？

0到多个 看操作码

零地址 op 堆栈

一地址 op a1 累加

二地址 op a1 a2 最常用

三地址 op a1 a2 a3 通用寄存器

多地址指令

地址码个数与性能和实现难度密切相关

## 2.3 如何找到操作数 寻址问题

地址如何编码？寻址方式决定

操作码 地址码

长度限制 给出逻辑地址 通过寻址找到物理地址

**为啥不直接把操作数放操作吗后面**，**就不寻址了**？

地址码位数有限，更大的操作数无法支持

**为什么不把操作数物理地址放进，就不需要寻址了**

地址吗位数有限，放不下多少操作数地址。

而且寄存器非常少。

以一个32位指令为例，操作码12位，地址码只有20位·，直接寻址空间只有2^20次，1MB的寻址空间

寄存器少，能放操作数非常少

无法满足我们的要求

寻址方式

- 扩大访存范围
- 提高访问数据的灵活与有效
- 支持软件计数发展，多道程序设计

寻址方式

- 寻找操作数
  - 操作对象寻找
- 寻指令
  - 下一条指令的地址
- 通常指代操作数寻址

指令寻址——简单

正常 pc增1

跳转：同操作数的地址



操作数寻址——复杂

- 操作数的来源：寄存器/外设/主存/虚存/栈顶
- 操作数据结构：位/字节/半字/字/双子/一维表

## 2.4 数据在计算机的表述

为什么二进制编码？

- 开关表示，物理器件简单
- 二进制，编码，计数，运算简单
- 逻辑命题对应，便于逻辑运算，方便使用逻辑电路实现

真值和机器数

- 机器数：0 1编码 计算机内部的 0 1 序列
- 真值：机器数真正的值，即：现实中带正负的数

数据在计算机内部如何表示？

整数/负数/整数/小数/逻辑数



数据表示

——能倍计算机硬件识别的数据类型

1. 可用计算硬件直接表示
2. 可以由计算机指令直接调用

数据表示和数据结构的关系

- 数据表示是研究硬件如何识别数据类型
- 数据结构是在数据表示基础上，如何计算机处理硬件不能直接识别的数据类型

数据的不同抽象

文字，图，表，声音等 用户级别

输入输出设备

程序员

二进制表示的各种数据

树图链表等结构化数据

系统设计者

指令能识别的基本类型

- 数值型数据
  - 二进制数
    - 整数
      - 无符号
      - 有符号
    - 实数 ：浮点数
  - 二进制编码的其他进制的数
- 非数值型数据
  - 逻辑数据
  - 西文字符和汉字

数据宽度

位 ：计算机存储处理传输最小单位

字节：二进制计量单位

​	 主存按字节编址，字节是最小可寻址单位

字 word 被处理信息的单位，度量数类型宽度

子长是cpu数据通路的宽度，等于cpu内部总线的宽度或运算器的位数或通用寄存器的宽度

字和字长的宽度可以一样，也可以不同，通常是字节的整数倍

intel386 字长32 字 16

常用数值数据

定点数、浮点数、十进制数

解决的问题：

- 整数与负数的表示
- 小数点的表示
- 零的表示
- 实数的表示

问题1 如何表示正负数

解决办法：设置符号位

0 正数 1 负数

第1位不代表数，代表符号

```
例子1
x = +90   二进制 1011010

八位二进制源码：    01011010
```

```
例子2
x = 190   二进制 -1011010

八位二进制源码：  11011010
```

## 2.4.2 数值数据的定点显示

问题2 **小数点如何表示**

区分其他数，且记录小数点

解决办法：小数点固定在固定位置

定点数

- 小数点左边的二进制是整数，右边是小数
- 计算机通常将数分为定点整数和定点小数
- 小数点在数据类型里默认（程序员心里）

定点数在机器中表示

整数 符号 数值

定点整数：小数点固定在最低位的右边

​		   表示范围 （0，2^n-1）1

定点小数：小数点固定在数值部分最高位左边

​		表示范围（0，2^-n）

问题三：**如何表示零**？

一个数不是整数就是负数，0不是正数也不是负数，符号位咋办？

区分正零和负零

```
x=+0
八位二进制
原码 00000000
反码 00000000
补码 00000000
```

```
x=-0
八位二进制
原码 10000000
反码 11111111
补码 00000000
```

反码：正数不变

​	   负数 符号位不变，数值位取反

补码：整数不变

​	   负数反码+1

补码解决了同一个数不同表示的问题，广泛应用于现代计算机

## 2.4.3 数值数据的浮点表示

问题4 如何表示实数？

实数：尾数和指数（阶码）——浮点数表示

25.75 = 2.575*10^1 十进制

​	  = 11001.11 二进制真值

​	  = 1.100111 *  10^100 二进制

科学计数法

尾数

十进制小数点

阶码：改变小数点位置

基

二进制

- 尾数 定点小数
- 阶码 定点整数

小数点导致一个数有多种表示方式 1/1000000000

1.0*10^-9  0.1 * 10^-8  10.0 * 10^-10

规格化格式：小数点只有一位非0数 1.0 * 10^-9

二进制规格

浮点数总位数不变的情况下，提高数据表示精度，尾数有效数字尽可能占满已有位数

会当属规格化 1/2<=abs(f)<1

右规:f>1

右移1位，阶码加1

11.01100111 * 10^101

0.11011001 * 10^111

左归 f<1/2

左移1位，阶码减一

0.00110011 * 10^101

0.11001100 * 10^011

浮点数 ieee 754 图灵讲

符号s

阶码e 整数

尾数f 小数

尾数f

- 尾数为原码
- 规格化尾数最高位1，隐含表示，省一位

尾数=1+signed   signed(0,1)

阶码为0专门表示数值0

​	1+23bit(单精度)，1+52bi(双精度)

​	float double

尾数精度=尾数位数+1

**阶码**e

移码表示   

移码：数值加一个偏置常数

-8+（+8）=0000

0（+8）= 1000

移码表示阶码

便于浮点数对接

浮点数对接操作转换阶码小的数

比较两个数：从左到右依次比较

-2 1110     0110

3   0011    1011 比较了阶码大小

按位比较是错误的

偏置常数

单精度 偏置常数 127

双			  1023

单精度阶码 -126——127

全0 1表示特殊值

双精度

浮点数——真值

单精度 = (-1)^s * (1+signficand) * w(exp-127)

双精度 = (-1)^s * (1+signficand) * w(exp-1023)

 浮点数精度尾数f决定

浮点数表示范围基数R和阶码e决定

阶码 基数表示尾数越大，表示范围越大

练习1 二进制浮点数转ieee754

十六进制表示

bee00000H

1011 1110 1110 0000 0000 0000 0000 0000

符号位1 负数

阶码

01111101 = 125

125-127=-2

尾数1+0.5+0.25=1.75

表示 -1.75 * 2^-2

-0.4375

练习2 十进制到浮点数

-1.275 * 10^1

1. 计算真值 -12.75

2. 整数部分转换 12 = 8+4  1100

3. 小数变换 0.75 = 0.5+0.25=0.11

4. 规格化

   ​	1100.11=1.10011 * 2^011

5. 移码表示阶码

127+3 = 130 = 10000010

1100 0001 0100 1100 0000 0000 0000 0000 16进制C14C0000H

全0 全1

阶码   尾数  数据

1-254  任意  规格化数

0	 0		？0

0  	非0	？非规格化

255 	0	？+∞	

255	非0	？非数NaN 0/0  -4开平方 无穷的运算

如何表示0

阶码 0

尾数 0

符号位随便

正零负零都是零

正负无穷

阶码 255

尾数 0

符号为正负

单精度 32位

双精度 64位

## 2.4.4数据数值的十进制表示

- 能否直接表示10进制数

十进制数的二进制编码

ascii

bcd码

十进制看成字符串

十进制0-9代表30H-39H

一位十进制对应8位二进制

符号位？

前分隔数字串

- 符号位用一个字节表示，位于数字串之前
- 正号 + 2BH表示
- 符号 -   2DH表示

十进制数 + 236 

2B 32 33 36H

十进制 -2369 表示

2D 32 33 36 39H

后嵌数字穿

符号位嵌入最低位数字的ascii的最高4位，省一个字节

- 正数：最低位数字的高四位不变
- 负数：最低位数字高4位，变为0111

十进制 236 3233 36 H

十进制-2369 32 33 36 79H

**BCD码**

0-9 每个十进制需要4位二进制

4位二进制组合16个状态，有冗余

8421码：十进制有权码 

2 的 3 2 1次方 十进制无权码

其他 5中取2 读热码

编码思想

+ 1100 +
+ 1101   -
+ +236 = 1100 0010 0011 0110 两个字节
+ - 2369 1101 0010 0011 0110 1001 1001 8432码
    - ​             110100000010001101101001补零

## 2.4.5 字符数据的机器表示

西文特点

- 语言文字，几个可以组合为单词
- 对少量字母和一些数字符号，标点符号进行复制编码
- 所有西门字符不超256，用8个二进制位存放

汉字特点

- 汉字表意
- 含子传输大，超6w，给汉字表示，传输，io交换，一系列问题

编码形式

- 输入吗：每个含子使用按键进行编码，用于输入
- 内码：系统存储查找传送
- 学校代码和轮廓环境：描述含子点阵，解释加湿机



## 2.4.6 数据的度量与存储

描述信息不同单位换算不同有1024也有1000

数据存储方式

现代计算机都是字节编址

int 4个字节

isa设计考虑问题

- 如何基于一个字节地址取到多个字节的字   **字的存放**
- 一个字能否存放在任何字节边界                   **自动边界对齐**

例子 int i = 0x01234567，存放在内存100号，使用取数指令从100号去除i，程序员必须清楚i的4个字节如何存放

01 23 45 67

msb        lsb

msb字最高有效位

lsb字最低有效位

多字节 两种方式

大端 小端方式

大端 msb是数的地址 低地址    lsb高地址

mips ibm360

小端  lsb是数的地址   低地址    msb高地址

80386

有的机器都支持，需要特定控制位

```
struct{
    char c;
    short si;
    int i;
    float sf;
}rec_var={0xab,2098,-1028,0.625}
```

2098 =0x0832,

-1028=0xfffffbfc

0.624=0x3f20

大端机

```
00 01 02 03 04 05 06 07
ab 08 32 ff ff fb fc 3f
08 09 0a 0b 0c 0d 0e 0f
20 00 00 00 00 00 00 00
```

小端机

```
07 06 05 04 03 02 01 00
20 ff ff fb fc 08 32 ab
0f 0e 0d 0c 0b 0a 09 08
20 00 00 00 00 00 00 00
```

**字节交换**

- 存放方式不同的机器之间程序移植或数据通信发生问题
- 存放方式不同，数据访问需要进行顺序转换
- 音频，视频，图像也会遇到这种问题

**数据对齐**

目前数据字长32 64字长，存储器按字节编址

指令系统支持字节 半字 字 双字运算 也有按位处理的指令

不同长度的数据存放，有两种处理办法

- 按边界对齐（假定字宽32位，存储器按字节编址）
  - 字地址 4的倍数 低两位 0
  - 半字地址 2的倍数 低位0
  - 字节地址 任意
- 不按边界对齐

例子：假设数据顺序 字 半字 双字 字节 半字

int i,short i,double x, char c,short j

边界对齐

&i=0

&k=4

&x=8

&c=16

&j=18

x 2个周期

j 一个周期

不对其

地址分别是 0 4 6 14 15

x 3个周期

j 2个周期

效率变低了

## 2.4.7 数据出错

数据差错咋办？

具体措施

- 计算机硬件提高可靠性，

电路，电源布线增加抗干扰能力

- 数据检查错误，与校正错误，自动的发现并纠正

如和错误检测和矫正？

冗余校验，增加校验位

计算的校验位与读出的比较，不一致则错误

1. 未检测错误，直接输出
2. 检查到错误可以纠错，数据为和比较结果一起送入纠错器，将整错的数据输出
3. 检查到错误，无法纠错，输出错误信号

奇偶校验码

- 增加一个奇偶校验位一块传输存储，目的不见计算校验位并比较，根据比较得出是否发生错误

步骤

- 源不见算奇偶校验位 P

- 目的部件算P'

- 计算最终校验位p*=p异或p'，判断是都出错

1 奇数位错误

0 正确或偶数错误

特点

- 奇数位不同，校验位不同
- 偶数位不同，校验相同，至少两个数据出错
- 只能发现奇数错，不能发现偶数错，不能纠错
- 开销小，校验一字节长的代码，用于存储器写检查或字节传输的数据校验

## 2.4.8 基本指令和指令系统

1044年哈佛 markI

存储器带线啊哦 32字

机器字长 32

6条指令：

- jump 跳转
- load accumulator 操作数加载
- subtract
- store accumulator 存入累加器
- test for zer0 分支跳转
- stop 停机

**完善的指令系统**

- 数据传送指令move store load exchange
- 算术运算指令 定点数、浮点数、十进制数
- 逻辑运算指令 and or not compare
- 数据转换 字节与正数转换
- 输出输入 in out
- 系统控制 启动io设备，存取特殊寄存器
- 程序控制   转移 循环控制 子程序调用call ret 程序中断与返回int iret

**数据传送指令**

功能

- 寄存器与寄存器，寄存器与存储单元以及存储单元之间的数据传送

表征参数

- 源操作数地址，可由指令给出  发件人地址
- 目的操作数地址 指令给出        收件人地址
- 传送数据长度 ，指令隐含     物品数量

L 取数 4个寄存器

**算术逻辑运算指令**

功能

- 二进制加减乘除基本运算

算术运算指令的操作过程

- 源操作数传输到alu     数据的传送
- 进行运算
- alu计算结果传送到目的操作数地址单元

逻辑运算指令

- 按位进行运算，针对任何一种可寻址单元位进行操作
- 运算基础是布尔代数，与或非异或，位运算，移位

**程序控制指令**

功能

- cpu执行程序时候，执行一条指令后，程序计数器pc+4,打破顺序，需要程序控制指令
- 循环 分支 子程序调用用得到

**转移指令**

功能：改变cpu执行顺序，cpu到新地址执行后续操作

分类

**无条件转移**：直接控制转移到指令所指的目标，从那里开始执行，cpu在无条件转移指令时候只需要转移目的地址进入程序计数器pc就可以

**条件转移**：条件满足时候转移到指令所制定目标，否则顺序执行下一条指令

方法：条件吗。条件寄存器，比较返回指令



**子程序调用返回指令**

子程序

经常使用、独立完成特定功能的程序段，独立出来为其他语句调用的整体

使用子程序的优势

- 降低程序设计复杂度
- 提高程序复用性
- 节省存储空间
- 模块坏程序设计的基础，子程序库

子程序

主程序

- 专门的调用指令 call  返回ret指令
- 子程序调用和返回，实质是程序控制的转移
- 主程序是主动的，预知的，子程序是被动的，不能预知什么时候被调用，什么时什么位置调用

子程序设计解决的问题

1. 调用程序与子程序的调用返回
2. 参数传递
3. 公用寄存器问题

堆栈法

主程序M和两个子程序A B，M调用A,A调用B

M

MA

MAB

MA

M

**子程序调用和跳转指令的区别**

- 子程序要求返回，递归嵌套调用也行，转移指令不要求返回，也只出现再同一程序段
- 子程序用于程序之间转移，转移指令实现程序内的转移

call x;

x是子程序地址，Δ是指令长度

寄存器存返回ra = pc+Δ

​			pc=x

**如何递归嵌套调用**、

- 寄存器存放返回地址
  - 单寄存器不支持递归嵌套
  - 多寄存器支持嵌套，不支持递归

- 子程序起始位置
  - 支持嵌套，不支持递归



**参数传递**

调用程序提供i程序一便加工处理的称为入口参数

子程序加工处理后送回调用程序的信息是出口参数

参数传递方法

- 约定寄存器法
- 阅读存储单元法
- 参数赋值法
- 堆栈法

**寄存器共用**

- 子程序开始保护现场，返回前恢复现场

- 保护和恢复现场原则：破坏什么现场就保护什么现场，保护什么现场就恢复什么现场
- push指令构成保护程序段，pop构成恢复程序段，栈先进后出

**子程序结果**

- 保存现场
- 依据入口参数从指定位置索取加工信息
- 加工处理
- 依据出口函数向指定位置输出加工后的结果信息
- 恢复现场   当时的寄存器内容恢复回来
- 返回调用程序

**输入输出指令**

- 专用的io指令：两个操作数（数据地址，外部设备地址）

x86的 in out 指令

- 通用数据传输：存储器映像的io操作。外部设备寄存器与主存统一编址

- io处理机完成：通道和iop

**系统控制指令**

- os执行，不给用户的特权指令，处理机特权状态才能执行

- 实现：控制寄存器操作，检测或修改访问权限，改变系统工作方式，访问进程进程控制块，多用户，多任务环境使用
- 一半用户需要计算机系统特权服务，通过系统控制指令发出请求，操作系统处理，结果返回用户



基本指令和指令类型

- 数据传送指令
- 算术逻辑指令
- 程序控制指令
- 输出输出指令
- 系统控制指令



## 2.5 程序的计算机表示

程序的机器级表示

mips指令32位宽，字地址对齐



mips三种指令

R-型（用于寄存器）

- 两个操作数
- 操作数都是寄存器
- sub rd rs rt

op 6   操作吗

rs 5  第一个源操作数寄存器

rt5 第二个源操作数寄存器

rd 5 结果寄存器

shamt 5 位移指令的位移量 一般不用

funct 6 功能码 扩展操作码的功能

例如：R型指令op字段特定的000000 具体操作由funct字段给出

funct 100000表示加法 100001 减法

I型

- 运算指令：一个寄存器，一个立即数。入：ori rt rs imm16
- load store指令 lw rt rs imm16
-  条件分支 beq rs rt imm16

op 6

rs源操作数寄存器 5

rt源操作数寄存器 5

immediate 16 立即数，分支转移的地址

J型

- 无条件跳转

op 6

target address 26	无条件转移的低26位



mips寻址

R 型 寄存器直接寻址

I 型 

- 立即数寻址
- 基址寻址
- pc寻址

J型

26位怎么寻址

mips指令32位宽，字地址对齐

低两位一定是00

pc高四位+26位地址+00来组成一个地址



距离汇编与机器指令的对应

mips 的对应

add $        $ t0 ,      $s1,     $s2

funcr	rd(结果)rs	rt(过程)

op 6

re 5

rt 5

rd 5

smt 5

funct 6

0   17   18   8    0    32 十进制

R   s1    s2   t0   no  add

6    5    5    5     5    6、

000000 10001 10010 01000 00000 100000

这个过程是汇编，汇编成二进制机器代码

例子 取一条指令 00AF8020H 汇编是个啥？

32位代码 0000 0000 1010 1111 1000 0000 0010 0000

op rs rt rd shamt funct

6 5 5 5 5 6

前6位000000 R型

000000   00101  01111 10000 00000 100000

add 

rs rt rd  5 15 16

​	   a1 t7 s0

add s0 as t7     

a1+t7---> s0

反汇编   机器指令到汇编

可破解二进制代码（exe）

 漏洞 逆向 汉化

mips操作数

**寄存器的指定**

- 32 * 32 grps r0=0
- 寄存器编号 5 位
- f0 f31 双精度浮点
- HI LO PC：特殊寄存器HI LO乘除法运算结果

寄存器

- zero  0   恒为0
- at      1   汇编器保留
- v0-v1 2-3   过程调用返回值value for return
- a0-a3 4-7 过程调用参数argument
- t0-t7 8-15 临时变量
- s0-s7 16-23 保存 save
- t8-t9  24-25  其他临时变量 temp
- k0-k1 26-27 os保留
- gp       28     全局指针 globol pointer
- sp       29      栈指针 srack pointer
- fp       30      祯指针 frame pointer
- ra        31     过程调用返回地址return address

过程调用

v0 v1返回 a0-a3参数 ra返回地址

register数字 名称

0号恒为0 r1+r0 ->r2 将r1送到r2

因此没有寄存器传值的指令



存储器数据指令

- load store访问存储器数据
- 字节编址，边界对齐
- 大端方式
- 访问空间 4gb 2的32次方
- 访存地址通过32位寄存器内容加16位偏移量得到，16位偏移是有符号整数
- 字地址相差4字节
- 可以前后偏移

mips指令类型

算术逻辑

add sub multiply  add or xor

add    

sub

addi 加一个立即数

mul  乘法结果 高32 Hi低32 Lo

div 除法  只需要除数  缺省被除数  Lo商  Hi余数

and

or imm

xor

nor



数据传输

sw 存1个字

sh 存半个字

sb 存字节

lw

lh

lb

同上

操作数长度有操作码来决定

不同长度的操作数？

高级语言的多种数据类型

char short int long 

条件分支

beq 相等跳转

if(s1=s2) goto Pc+4+100

bne branch on not eq if(s1!=s2) goto pc+4+100

**pc+4?**

pc自动更新下一条地址

下一条指令的地址

slt set on less than slt 1  2   3  if(S1<S3) S1 =1,else S1 =0

slti  set less than imm    slti 1 2 100  if(S2<100)S1=1,else S1 =0

条件码 状态吗 标志位

通过执行算术指令或比较测试指令来设置条件码

例子

sub r1 r2 r3  r2 r3 结果存放r1 生成标志物ZF/CF

bz label  标志位ZF=1,转移到label除

标志位

sf  符号

of 溢出

cf 进位

zf 判0

- 可以存放在标志寄存器/程序状态字 psw
- 也可以放通用寄存器

例子

cmp r1 r2 r3  比较 r2 r3 标志位r1

bgt r1 label   判断r1大于0，转移到abel处

两条指令合成一条：计算并转移

bgt r1 r2 label   r1 r2 比较  决定时候转移

不同处理器，对标志位处理不同

状态标志位举例

将字节59H和6CH相加，Flags四个状态标志设置为上面值

01011001

01101100

11000101

进位 没有CF进位标志 0

符号  1      SF 符号标志1

溢出   正+正=负 溢出 OF溢出标志1

是否为0 不是0              ZF  零标志 0



条件分支

无条件处理器根据算法结果设置CF OF标志

CF 进位 运算结果**无符号数**

OF 溢出 运算结果视为**有符号数**

溢出与进位/借位区别

- 进位/借位CF 无符号数  是否超出范围，如果超了，保存了进位和借位，结果依然正确
- 溢出标志OF表示有符号数运算结果是否超出范围，超了则结果不不正确



**无条件跳转指令**

**jump** 转移目标地址 j

伪直接寻址方式

**jump** **and** **link**  jal

- 首先保存返回主程序的地址，pc+4  goto 100000 

- 然后将jump的地址赋值pc，跳转过去

- 返回时候用100000地址返回

**jump** **register**

jr  31号寄存器寻址

指令设计

简单源自规整

越少越快

- 寄存器太多，硬件复杂，时钟周期边长
- 寄存器32个

c编译汇编

```
c =  (g+h)-(i-j)
```



```
add t0 g h    #t0=g+h

add t1 i j     # t1 = i+j

sub f t0 t1     #f = t0-t1
```

有问题吗？

操作数必须来自寄存器

编译时候寄存器与程序变量必须对应，fghij分别分配寄存器s0 s1 s2 s3 s4



```
add t0 s1 s2
add t1 s3 s4
sub s0 t0 t1
```

常数，存储器读出，避免访问常数，提高常数的快速运算指令——立即数操作指令

原则——加速常数操作

addi

指令长度相同

不同的指令格式

均衡地址

## 实验1



- 高级语言与机器表示
- 数据类型转换及运算
- 处理器设计与实现
- 运算器设计与实现
- 趣味实验

### 1实验环境介绍

gcc使用方法

源程序到目标代码

机器语言到汇编语言

机器语言与指令集结构

虚拟机vmware

虚拟机操作系统 xp

编译 gcc

编辑 ultraedit

## 2 gcc使用方法

编译代码

vs

eclipse



推荐gcc

gnu c cpmplier

c c++ java 

gun gun's not unix

理查德马修斯托曼

哈佛 mit

自由软件运动人

gcc

vs compile选项

四阶段

hello.c

- 预处理   hello.i
- 编译 hello.s
- 汇编 hello.o
- 连接 hello.exe

gcc分阶段处理

gcc 常用命令

gcc options filenames

​	参数   名称

**gcc --help**

帮助文档：可调用的选项查看

**gcc -E hello.c -o hello.i**  预处理

-E仅仅预处理

-o输出文件的名称

预处理

**编译处理**

gcc -S hello.i

编译为 hello.s  

-S 只文件进行编译

**汇编处理**

gcc -c hello.s 

**链接处理**

gcc hello.o -o hello.exe

链接明确指出生成exe

gcc hello.c -o gcc hello.exe

一条龙

## 3 源程序到目标代码

预处理 -E .c   .i

预处理

```C
#include<stdio.h>

int main(){
    printf("hello world!\n");
    return 0;
}
```

printf使用了stdio.h的代码

.i文件

mian前面出现了stdio的代码

对#代码进行处理

```
#inlude进行包括到代码中
```

.i还是高级语言



-S .i  .s文件

汇编语言，与指令集有关

汇编不能直接移植

高级语言可以移植

原因：高级语言编译为本平台的汇编代码

助忆符

地址符号

汇编

可重定位的目标文件 二进制

链接

可执行目标文件 二进制

差别：

- .o不能直接使用
- 引用来其他文件的代码
- 把库函数目标函数模块合并printf合并

exe 打印一个字符

# 第三章 计算机的运算

## 3.1基本计算

25*4+40/4-13

计算的层次

- 加法减法减法乘法除法：不是最底层的运算，依靠底层实现进一步实现的

底层基本运算

- 按位运算
- 逻辑运算
- 移位运算

按位运算：对二进制数的每一位进行操作

- 按位与
- 按位或
- 按位取反
- 按位异或

按位与

- 将两个二进制数对应位上的数做与运算
  - c语言用符号 & 表示
  - 一个串联开关的灯泡就是按位与，只有两个开关都是1时候，灯泡才是1

A   B    A&B

0    0        0

0     1       0

1     0       0

1     1       1

功能

- 提取二进制数的指定位
  - 取低数四位（和00001111按位与）



按位或

- 将两个二进制数对应位上的数做或运算
  - c语言用符号 | 表示
  - 一个并联开关的灯泡就是按位与，只要1个开关是1时候，灯就会亮起来，结果为1

A   B    A|B

0    0        0

0     1       1

1     0       1

1     1       1

按位或

- 二进制特定位为条件复制
  - 最低为置为1（和00000001按位或）



按位取反

- 将两个二进制数0变1，1变0
  - c语言用符号 ~表示
  - 一个与灯泡并联的开关，开关开灯泡被短路，结果是1

A   ~A   

0	1

1	0

按位异或

- 二进制的数对应位进行异或操作
- c中^表示

电路：

两个串联开关和灯泡并联，两个都通时候串联所在的桶，短路了灯泡

A   B    A^B

0    0        0

0     1       1

1     0       1

1     1       0

异或功能

- 判断两个二进制数是否相等
  - 两个数按位异或 相等的结果为0
- 对一个二进制数按位取反

## 3.1.2 逻辑运算

真假

- 逻辑与
- 逻辑或
- 逻辑非

逻辑与

- 两个表达式真值与操作
  - c   &&表示
  - （x<=6)&&(x>=4)
  - [4,6]
  - 取交集

真值表

x>=4 	x<=6	(x>=4)&&(x<=6)

0		0			0

0		1			0

1		0			0

1		1			1





逻辑或

- 两个表达式真值或操作
  - c   ||表示
  - （x<4)||(x>6)
  - 取并集
  - 至少一个真就是真

真值表

x>6 	x<4	(x>6)||(x<4)

0		0			0

0		1			1

1		0			1

1		1			1

或门

逻辑或

- 两个表达式真值取反操作
  - c   ！表示
  - ！(x>6)
  - 取反
  - 1变0，0变1

x>6    !(x>6)

0	    1

1	    0

## 3.1.3 移位操作

- 算术左移
- 逻辑左移
- 算术右移
- 逻辑左移

算术 有符号

逻辑 无符号 如地址

**算术左移**

- 指定移动位数进行向左移位
- c   <<表示
- 01011000  左移1
- 10110000
- 算术左移，移除的位在特定寄存器保存，最后一位补0

**功能**

- 乘以2的n次方



**算术右移**

- 指定移动位数进行向右移位
- c   >>表示  尖头方向就是移位方向
- 11011000  右移1
-  11101100
- 补码表示有符号数
- 补码最高位为符号位，右移要补符号位而不是补0

**功能**

- 除以2的n次方

**逻辑右移**

直接右移，高位补零

位操作

移位

左移x<<k

右移x>>k

逻辑函数算术根据数来决定

无符号数 逻辑移位  补0

判断溢出

- 左移，最高位是1
- 右移，最低位1

有符号数 算术移位  补符号

- 算术左移。高位移除，地位补0
- 低位移除，高位符号位

溢出：溢出的位不等于新的符号位，则溢出

右移：数据丢失

加减乘除由按位，逻辑，移位计算

基本运算

- 对寄存器数运算
- 基本操作单元，一个时钟周期完成
- 控制信号

## 3.2 加法与减法

二进制加法

十进制加法

  245

+673

  918

每位加法结果

- 结果位
- 进位
- 4+7  结果1 进位1
- 拆分为加法位表，进位表

**二进制也类似**

加发表 

''+'    0     1

0     0 0    0 1

1     0 1     1 0

差分

**加法位表**

''+'    0     1

0       0     1 

1       1     0

**进位位表**

''+'    0     1

0       0     0 

1       0     1



二进制加法实例

 00100101

 10110110

 11011011

无符号数的二进制加法



有符号怎么半？

有符号数的表示

原码表示

同号

 100100101

 110110110

 111011011

数值位相加

符号位同号保留下来

同号简单

**异号怎么办**

100100101负数取补码变为

111011011 

010110110

010010001

数值位相加

产生进位

结果位正

不产生进位咋办？

110110110

负数取补码

101001010

000100101

数值位相加

1 01101111

没有进位，符号位是1，结果是补码

取补得到原码

原码二进制加法

- 符号位和数值分别处理

- 比较符号位异同

- 同号：数值位相加，最高位进位，结果溢出，符号取被加数的符号

- 异号：负数取补码，与正数i相加

  - 最高位产生进位，符号位0，表示结果是正，所得数字是原码
  - 最高位没有进位，符号位1，结果为负，是补码，再取补得到原码

  数值部分操作，符号位判断控制作用，这是复杂的

**如何简化操作**

补码的二进制加法

补码

- 符号相同
- 最高位符号位，0正 1负
- 数字部分与符号有关
  - 正数，数值部分同原码
  - 负数，数值部分是原码按位取反加1，反码+1

简化操作

补码加法不区分符号数值

x = + 1101

x原 = 00001101

x补= 00001101

y = - 1110

y原= 10001110

y补= 11110010

补码加法，符号位运算

a+b 补 = a补 + b补 mod 2

A 1011 B -1110

A+B补 为

00001011

11110010

11111101

**补码减法？**

补码减法简化为加法

a-b 补 = a补 +（-b)补 mod2

A  = 1011

B = -0010

A-B 补

A 补  01011

-B 补 00010

​          01101

补码加减法，只需要一套加法电路，简化了硬件电路结构

**补码实例**

A = +1111

B = 01101

A+B

A 补码 01111

B 补码 10011

  01111

  10011

100010

溢出了应该取上面？

符号为0，正负相加不会溢出

00010

进位标志位CF=1

溢出标志位OF=0



A = -1111

B = -1101

A+B

A补 10001

B补 10011

  10001

  10011

100100

进位

符号位0正数

负数+负数还是负数

溢出

进位CF 1

溢出OF 1

结果溢出



**溢出问题**

运算结果超出机器表示数的范围

A1 B2

1101 100

补码相加 01101+01001 = 10110 正溢出

A1 B2

-1011 -1100

补码相加 10101+10100 = 01001 负溢出

**如何判断**

变形补码

检测方法

- 补码采用两位符号位（变形补码）：x补 = 4+x(mod4)
- 模4补码
- 符号位参与运算，结果两位符号位判断溢出



符号位 相同    01 	  10

状态      正粗 正溢出 负溢出

A = -1101

B = -1010

A补 = 110011

B补 = 110110

A+B补

110011

110110

101001

负溢出



A 1101

B -1010

求A-B补

A补 001101

-B补 001010

001101

001010

010111

正溢出

二进制加法的原理



加法器的硬件功能

一位加法

进位考虑

一位全加器

三个输入

两个输出

两个加法位，上一级进位 Ai Bi Ci-1 Si Ci

结果 加法位结果  进位结果

真值表

Ai Bi Ci-1 Si Ci

0 0 0 0 0

0 0 0 1 0

1 0 0 1 0

1 1 0 0 1

0 0 1 1 0

0 1 1 0 1

1 0 1 0 1

1 1 1 1 1

Si = Ai异或Bi异或Ci-1

Ci = (Ai+Bi)Ci-1+AiBi

   =(Ai异或Bi)Ci-1+AiBi

两个异或

两个与

一个或

n位加法器

多个1位串联起来

串行进位加法器:n步是西安，每步求1位和

Ci+1 = AiBi+Ci(Ai异或Bi)

串行加法器延迟？2n级别延迟

串行每次运算依赖上一级的结果

延迟等待？

串行到并行

逻辑合并得到新真值表

Cin Ai Bi Cout

X    0    0    0

Cin 0    1    Cin

Cin  1     0    Cin

X     1     1      1

cout不依赖cin

A B 都是1或者0 则于cin无关

A B有一个是1，in out相同

进位生成函数Gi=AiBi

进位产地函数Pi = Ai+Bi=Ai异或Bi

传递进位PiCi-1

Ci = Gi+PiCi-1

Ci=AiBi+(Ai+Bi)Ci-1

并行进位加法器

各个进位信号独立生成

**大规模完全进位器吗**？

- 高位进位形成逻辑输入变量过多，器件扇入系数限制

位数较多的加法器，分级，分组的进位链结构

- 分组 组内并行，组间串行
  - 组内并行，组间并行

# 实验1下 高级语言与机器表示

## 



4 机器语言与汇编语言

汇编代码 汇编->  二进制代码

​                <-反汇编

 gcc 反汇编命令 objdmp -d 可执行文件 > 输出目标文件

objdump -d hello.exe > txt

-d disassenble

objdum -help

x86 可执行文件

反汇编 x86指令结果

二进制 83 c0 0f 指令 add  0xf  %eax

## 机器语言与指令集结构

高级语言不同指令集编译结果不同

机器语言 指令 基本操作 01编码

指令集合

不同机器不同

risc

1. 指令集精简
2. 寄存器方式工作
3. 指令周期短
4. 大量通用寄存器

cisc

1. 指令复杂
2. 各种指令访问存储器
3. 指令周期长
4. 专用寄存器

ia32平台

反汇编

指令不定长，复杂

x86

不同编译不同的可执行代码

intel 编译 直接运行在intel处理器

交叉编译生成mips可执行代码

一种环境下的编译器可以得到另一个平台的可执行代码 交叉编译器

得到的汇编完全不同

## 3.3 乘法运算

十进制乘法

​                          245

​                        *673

M0=A*B3         735

M1=A*B2   1715

M2=A*B1 1470

A*B           164885

位积 A * Bi

A*B=164885

​           1 1 0 1

​           1 0 1 1

​           1 1 0 1

​        1 1 0 1

​     0 0 0 0

  1 1 0 1

1 0 0 0 1 1 1 1

问题1 加法器只有两个输入，无法支持多路输入，本题需要4路加法器

需要2n+1位加法器，不能有效利用全部加法器

**改进：引入部分积P,改一次求和位累加求和**



​           1 1 0 1

​           1 0 1 1	P0=0

​           1 1 0 1	P1=P0+2^0M0		

​        1 1 0 1   	P2=P1+2^1M1

​     0 0 0 0	      P3=P2+2^2M2

  1 1 0 1		 P4=P3+2^2M3

1 0 0 0 1 1 1 1

只需要两个输入了

P2=P1+2^1M1

P1最低位不需要参与运算，

部分积右移，最后一位保存，

用5位加法器求得剩余部分的和，左移加上部分积最后一位得到最终结果

改进2：部分积右移一位再求和，再移出部分保存

二进制乘法

- 被乘数寄存器X:存放被乘数
- 部分积寄存器P：初始值P0=0;结束时候存74位成绩高32位
- 乘数寄存器：初始乘数；结束存放64乘积的低32位
- 写使能
- 控制逻辑计数器Cn:循环次数，初值31，cn-1直到Cn=0
- 进位出发前C;保存进位信号
- ALU:乘法核心部件，加逻辑对PA内容运算，写使能逻辑控制运算结果送回P,进位存放C

每次循环，对进位C,部分积寄存器和乘数寄存器B实现同步右移

1.存储部分及寄存器移出来的位

2.乘数移除最右边，已经用过了，没用了

3.控制是否更新部分积的值

A 1101

B 1011

**原码乘法**

原码一位乘法 ：符号位异或，数值部分绝对值相乘

两个32位原码相乘，迭代31次，加一次符号

两个定点小数

A 0.1101

B=0.1011

处置部分相同

无符号移除位丢掉

四次移位操作

原码一位乘法

部分积 高四位，低四位

最终结果0.10001111

定点整数也一样

分析：机器运算算法特定

- 乘法数值部分靠多次累加移位完成
- n次n+1位加法
- n次右移操作

原码一位乘法器

- 被乘数寄存器
- 乘数寄存器
- 乘积寄存器
- 加法器
- 输入选择开关
- 控制电路

**3.3.3补码乘法**

原码一位乘法基础发展

比较法，booth乘法

C = A *Ｂ

乘数和被乘数的符号位参与运算

被乘数Ａ采用了模４变形补码，判断是否溢出

正　００

负　１１

正常情况两位相同

乘数非负＞＝０

当被乘数A>=0 乘法过程与原码相同，符号位参加运算

被乘数<0,模4补码

B>=0,B0=0,

A补B补 = A补B

AB补=A补B补

- 符号位按照补码规则
- 移位按照补码规则操作

乘数位负

B补

B=B补-2

AB补=A补（B补尾）+-A补

AB补 = C补（0B1B2B..)+(-A)补B0

Bn+1==0

部分积



判断位

00 右移1位

01 加A补右移

10 加-A补右移

11 右移

booth乘法

- 被乘数A和部分积P取变形码，乘数取一位符号位，符号位参与运算
- 乘数末尾增加附加位Bn+1，初始值0
- Bn和Bn+1构成各部运算乘法判断位
- 按照补码移位原则



被乘数A=-0.011

乘数B = 0.101



补码一位乘法器

- 被乘数寄存器
- 乘数寄存器
- 乘积寄存器
- 加法器
- 输入选择开关
- 控制电路

n+1步完成乘法

第n+2周期输出结果

## 3.3.3快速乘法

加速乘法

加速加法

加速乘法

- 每步处理两位乘数，实现加速乘法
- 提高1倍



加速加法

- 一步完成多个位积相加，实现快速乘法
- 多位乘法专用芯片

柱形乘法器

- 一位全加器和存储进位加法器（伪加器）
- FA
- CSA

CSA得到伪加和，伪积和

一次伪加一次普通加

- 阵列乘法器

## 3.4 除法计算

笔算十进制除法

- 除法是乘法的逆运算，本质是一个试探法
- 从被除数中试探除数，通过余数是否能够减，决定商的值
- 余数分真余数，不能取假余数



二进制除法



- 二进制除法可魔法十进制除法运算，只需要试探商1还是0，更加简单

1011除数

被除数1101010

心算上商

计算机如何做到？试探法

每次直接余数减除数，够商1，不够商0，商0需要恢复余数

除数不断做右移操作

- 除数右移与余数比较，等效于除数不懂，余数左移一位，

- 除数寄存器
- 余数寄存器
- 余数/商寄存器
- 控制逻辑计数器n+1,每次-1

step

- 初始状态
- 余数-除数
- CF判断借位，位1说明减多了，需要恢复回来
- 余数+除数
- 余数和商左移1位
- 商0
- cn-1

除法逻辑

RQ同步左移，Q做高移入R最低位

Q空出最低位商，商各位一次逐渐左移到Q

ALU决定上商

**原码一位除法**

恢复余数法

- 有符号的被除数和除数转换为整数相除
- 符号位单独处理，商==除数和被除数异或
- 余数的符号与被除数的符号一致

定点小数的除法

- 被除数绝对值小于除数绝对值
- 比较上商
- 余数逐渐减小

运算规则

- 两数相除
- 第一步除法 A-B，R0
- R0>0;余数正，上商1
- R0<0;余数负，上商0，此时加上B,恢复原来的余数
- 之后每一步都通过Ri-2^-1B实现
- Ri-2^-1B>=0,余数正，上商
- 若-2^-1B<0.上商0，此时加上B,恢复原来的余数

除数右移与余数比较，等效于除数不动，余数左移一位

余数是放大的余数，需要缩小2的n次方倍

A = - 0.1001 B =0.1011

A/B原

恢复余数法的问题：

相同位数的除法，对于不同的值，由于恢复余数操作，运算步数不统一，控制器设计困难

去掉恢复余数的步骤？

**加减交替法**

Ri>0,商1，下部除法新余数Ri+1

Ri+1=2Ri-|B|

Ri<0,商0.得到下步除法新余数Ri+1,不必恢复余数

只需要Ri视为真余数，左移1位，加上|B|得到新余数Ri+1

Ri+1=2(Ri+|B|)-|B|=2Ri+|B|

ri为真余数，左移一位加B得到新余数Ri+1

- 余数正，下步减法
- 余数正，下步加法

加减交替法运算规则（）

- 原码除法符号单独处理，商符号位异或
- 被除数 余数 设置双符号位，判断溢出
- 余数为正，商1，余数和寄存器同步左移一位，左移以后余数奸商除数的绝对值得到新的余数
- 重复n+1步，
- 最后一步余数不左移
- 最后一步负的，加b的绝对值

加减交替发求例子1

加减交替除法

- 规整运算步骤
- 省区了恢复余数的过程，加快了除法的速度

**小结** **原码除法**

- 符号位数值位分开处理
- 数值部分无符号数实现
- 浮点数尾数计算

恢复余数

加减交替法

- 先加减，后上商
- - 本次余数正，下一次减法
  - 本次余数负，下一次加法

**有符号除法**

补码：定点整除除法运算

补码一位除法

符号位和数值位一起运算

ooth除法，加减交替次序

先上商，后加减

- 余数符号vs除数符号上商，商左移一位
- 同号，商1，余数座椅，减去除数
- 异号，商0，余数左移，加上除数
- 最后一部上商，余数不败你
- 商符号取反
- 恢复余数和修正商

n步除法

n+2时钟周期

3.4.4 **快速除法**

阵列乘法器加速乘法运行

有没有阵列除法器

CAS 核心部件



阵列触发器

- 两个整数加减交替进行相除
- 除法各步的加减移位操作在一个节拍完成，提高运算速度

以一个多个alu位核心，加上移位器和中间寄存器组，实现各种运算

运算部件ALu,移位器，寄存器组，多路选择器，总线构成运算数据通路

- 运算器芯片实现

除法

- 无符号 加减 左移
- 原码除法 符号位与数值位分开。浮点数尾数预算
- 补码除法：一块算，用于定点整数运算

## 3.5.1 浮点数运算基本问题

浮点数的算术运算是浮点运算

二进制浮点数

- 符号
- 尾数
- 基数
- 阶码

五个异常

- 无效操作
  - 1有一个是非有限数，加减无穷，0乘无穷
  - 结果无效，源操作数是NaN

- 除以9

- 数太大，上溢出

- 数太小 下溢出

- 结果不准确（舍入）

实现一套浮点数运算指令，解决问题

- 表实
- 范围和精度
- 支持的运算 加减乘除
- 舍入
- 异常处理
- 误差与精度控制

## 3.5.3 浮点数加法

A = 1.23 * 10^5 B = 4.56 * 10^2

A+B

计算过程

1.23*10^5+4.56 * 10^2

1.23*10^5+0.00456 * 10^5

1.23456 * 10^ 5

进行尾数加法运算，必须先对阶

对阶：两个操作数阶码相等

规则：小的向大的看齐，使得两个阶数一致

为森么小看大？

如果大看小？

大的左移，尾数不再是定点小数，不规整

右移注意：空出来补什么，移出去的咋处理

1. 隐含1移动到小数部分，空出补0
2. 移除的低位保留特定的附加位上

浮点数A B

A = Ma * 2^Ea

B = Mb * 2^Eb

浮点数加法

- 求阶差 Ea-Eb
- 对阶 Mb.2^-Ea-Eb
- 尾数相加
- 结果规格化
- 舍入
- 置零 尾数为0，阶码也应该置为0

相减类似

乘积==阶码相加，尾数相加

除法==尾数相除，阶码相减

溢出

- 阶码上溢出
  - 超过了阶码可以表示的最大值 正负无穷
- 阶码下溢出
  - 超过可以表示的最小值，认为是0
- 尾数上溢出
  - 同符号相加，最高有效位进位，进位尾数右移，重新对齐
- 尾数下溢出
  - 位数右以时候，最低有效位从尾数右端移除，丢失有效信息

进行舍入处理

运算添加保护位

**舍入**

- 就近舍入
  - 最近可以表示的数
- 正无穷舍入

负无穷舍入

0舍入

**浮点数乘除法**

A = Ma * 2^Ea.

B=Mb* 2^Eb

A*B = （Ma *Mb） * 2^(Ea+Eb)

A/B = （Ma /Mb） * 2^(Ea-Eb)



阶码加减

尾数乘除

规格化

舍入

缺点符号

判溢出

## 3.6精确问题

- 字长表示范围是有限的
- 浮点数位数超过机器字长，近似来代替

机器数与现实的差距，无法避免的误差错误

1. 浮点加法满足结合律，错误的
   1. x=-1.5*10^38,y 1.5 * 10^28 z =1.0
   2. x+y+z =1.0
   3. x(+y+z)=0
2. 整数，左移相当于成2次方方，右移处以2的此方，一个近似
   1. 有符号操作
   2. 爱国者飞错了地方

# 实验二 扫雷游戏破解

## 1. 扫雷游戏的破解

- 地雷计数器
- 地雷
- 数字提示
- 计时器

扫雷的破解工具

找到地雷

反汇编

破解

## 2.什么工具扫雷



静态反汇编常用工具

- w32Dasm
- PEiD
- Objdump

动态反汇编

- ollydbg
- windbg
- hdasm64

## 3 如何找到雷

分析雷在哪？

反汇编零秒扫雷

# 第四章 中央处理器

## 4.1 基本mips数据通路

五大组件

- 运算器
- 控制器
- 存储器
- 输出
- 输入

**数据通路**

- 指令执行过程中，数据所经过的路径，是指令的执行部件

**控制器**

- 对指令译码，生成控制信号，控制数据通路的动作，对指令的执行部件发出控制信号，指令的控制部件

数据通路，指令执行过程数据怎样在cpu各个部件传递

- 传递那些数据
- 数据传递方向
- 数据传递顺序

控制器

- 控制指令流出：取指令
- 控制指令的分析：指令译码
- 控制指令执行：执行指令，发出操作命令
- 控制指令流向：确定下一条指令的地址
- 控制执行环境的维护：执行环境的建立和保护，修改寄存器flas/psw的值

基本的mips数据通路

单周期控制器

多周期控制器

流水线数据通路

微程序控制器

## 4.1.2加法指令数据通路

加法指令的执行过程

add R1 R2 R3

功能 R2+R3 ——>R1

过程：

- 取指令，Mem[PC]-->inst,将指令取出来，PC+4---->PC PC指向下一个地址
- 指令译码，[R2]----->A,[R3]------>B,准备好操作数
- 完成加法，A+B -> ALUOutput  计算结果，放在ALU中
- 结果写回，ALUOutput->[R1]



指向过程

- 取指令
  - PC指向地址将指令从内存取出来，放入inst内部寄存器
  - PC+4
- 译码
  - 译码获得操作数A B
  - 查到他们保存在RS1 RS2中
  - 读出两个寄存器的内容AB
- 执行
  - 加法
  - A 输入BALU
  - 结果放在ALUOutput
- 结果写回
  - 结果写回到RD 也就是R1中

加法需要传递大量信息

- 指令地址
- pc地址读出的指令
- rs1
- rs2
- rd
- a
- b
- a+b

## 4.1.3 load store 分支跳转的数据通路

Load 指令 LW R1,R2,#4为例子

功能 Mem[R2+4]--->R1

过程 

- 取指令 Mem[PC]-->inst,将指令取出来，PC+4---->PC PC指向下一个地址
- 指令译码  [R2]--->A,立即数符号扩展到32位
- 计算访存地址 A+4  ALU执行  保存ALUOutput
- 读地址A+4的存储单元 [A+4]---> LMD，LMD保存访存的结果
- 结果写回   LMD-->[R1]



立即数符号扩展到32位 16位数字扩展32位需要扩展单元sign extend

合并，增加mux，选择合适的加数

mux选择写回的结果

译码如何准备操作数

固定字段译码技术

- 译码准备所有操作数
- 不用丢弃
- 实现简单



store R1 R2 #4

含义：R1->Mem[R2+4]

过程

- 取指令 Mem[PC]-->inst,将指令取出来，PC+4---->PC PC指向下一个地址指令
- 译码  [R2]--->A,[R1]->B,立即数符号扩展到32位
- 计算访存地址 A+4
- B写入地址A+4的存储单元，B-->Mem[A+4]

不同

- 译码扩展
- 和imm相加
- store没写回
- 访存A+imm

load与store

- store写
- load读



条件分支指令数据通路

 增加两个mux

- 选择加法运算被加数，nextsecondPC
- mux 确定新的pc值

区别

- 判断分支条件转移条件
-  nextPC与imm加就是转移的地址
- 根据分支成功选择下一条地址，成功alu,否则next

## 4.1.4 基本mips数据通路

store add 4步骤

load 5步骤

指令周期，取指令到结束的时间

对它扩展就可以完成这个数据通路

alu哪种运算，alu的输入是什么，这是变化的，根据指令的类型控制寄存器和alu的操作

控制器的设计方法

## 4.2.1 微操作

基本操作

- 读主存内存，装入寄存器，load,指令取址
- 把一个数据从某个寄存器存入给定的主存单元中 store访存
- 把一个数据从某个寄存器送到另一个寄存器或者alu 读寄存器，加法，load写回
- 算术逻辑运算，结果送入寄存器，alu上 内容不同，算术运算的结果，地址加立即数的地址，分支转移成功的地址

基本操作时间就是一个时钟周期

每个基本操作的执行时间是一个极其周期

指令周期由多个机器周期组成

取指令周期 同

执行周期 不同

load 4

add store 3个周期

基本操作就算是微操作

可用寄存器传输语音描述

R[r]表示寄存器r的内容

M[addr]表示地址为addr的存储单元内容

<- 表示数据传送，源寄存器在右，目的寄存器在左

pc程序计算器的值

OP[data]表示对data进行OP操作





同以功能单元回完成多种微操作

- 寄存器：读写

寄存器控制信号  RegWr

- 存储器：读写 

存储器控制信号 Mem Wr

- ALU 算术 逻辑运算

控制信号ALUctr

- 多路选择器：选择不同输入作为输出

四个问题

1. 一条指令哪些微操作
2. 什么顺序执行
3. 一个功能单元执行哪些微操作
4. 某个机器周期里，功能单元执行哪个微操作



数据通路设计与控制器设计

怎么样为不同类型的指令生成每个机器周期需要的控制信号

## 4.2.2 单周期处理器控制器设计

1. 确定数据通路上每个元件所需要的控制信号以及控制信号的取值
2. 汇总所有指令设计的控制信号，生成一张反映指令与控制信号之间的关系表
3. 根据关系表得到每个控制信号的逻辑表达式子、，据此设计控制器电路



分支指令：

- if(cond)PC <- PC+4+imm
- else PC<-PC+4

跳转指令：PC<-PC+4+Target

其他：Pc<-PC+4

**mips指令的执行周期**

寄存器文件：译码，写回

reg Wr=1写

​              0 读

RegDst 决定使用哪个寄存器



ALUsrts 指令类型选择不同的路径 address 还是 imm

ALUctr 选择执行什么操作

Mem Wr  1写

​		 0读

不访问存储器Mem Wr咋办，简单0读，保证内存不改变，但是不使用内容，设置专门的位电路复杂，不推荐

Mem to Reg 1 MMD写回寄存器，Load结果返回

​			0 将ALUOutput结果写回

立即数扩展单元

0扩展

符号扩展

逻辑与

ORI R1 R1 #3

extOp 1符号扩展

​	   0 0扩展

Branch 是否分支

Jump 是否跳转

Zero 分支条件是否位真

7个控制信号

MIPS指令执行过程

ADD/SUB

R[rs]<-R[rs]+/-R[rt]

ORI

R[rt]<-R[rs]   orZoreExt[imm6]

Load

R[rt]<-M[rs]+signExt[imm16]

Store

M[R[rs]+SignExt[imm16]]<-R[rt]

Branch

if(R[rs]-R[rt]==0) then Zero<-1,else Zero<-0

10哥信号的作用

R[rt]<-R[rs]   orZoreExt[imm6]

branch 0

jump 0

不是条件分支跳转

pc=pc+4

Zero=0

转移不成功或其他类型

extop=x 任意的，不影响

ALRSRC 0 加减法

ALUctr add 加法

​	    sub   减法

memtoreg 0 ALU单元

regdst 1  rd寄存器

ret W  1 寄存器写



逻辑与

R[rt]<-R[rs]   orZoreExt[imm6]

extop 0 立即数0扩展

alusrc  1   源操作来自于imm

aluctr   or    逻辑与操作

mem wr 0 不访存

memtoreg 0 ALU单元

regdst 1  rd寄存器

ret W  1 寄存器写



Load

R[rt]<-M[rs]+signExt[imm16]

extop 1 符号扩展

alusrc 1 imm

alucrt add 加法

memwr 0 读

memtoreg 1 有写回

regdst 0  rd寄存器



store

M[R[rs]+SignExt[imm16]]<-R[rt]

extop 1 符号扩展

alusrc 1 imm

aluctr add 

memwr 1 写

regwr 0



Branch

if(R[rs]-R[rt]==0) then Zero<-1,else Zero<-0

rs rt 

alu 减法 

alusrc 0 

aluctr sub

memwr 0

剩下的任意

branch 1 条件分支

jump 0 不是跳转

zero alu 得到

## 4.2.3单周期处理器性能

cpu time = IC * CPI * 时钟周期

IC 指令数

CPI 每指令周期数

cycle time 时钟周期

f 处理器主频

cpu与cpi 周期时间 有关

单周期处理器

- 时钟周期是最复杂指令执行时间
- 很多指令比最慢的块很多
- 如果仅仅改变非最长周期的指令，其他指令的优化是无用的

例如单周期主要功能单元

存储单元 200ps

alu加法器 100ps

寄存器文件读写 50ps

不考虑mux 控制单元pc富豪扩展 传输线路延迟，哪个块，块多少

1.每条指令一个固定时钟周期完成

2.每条指令一个时钟周期，时钟周期仅指令所需，是可变的

方案1 600ps

方案2 447.5ps

R,立即数不需要读内存

store指令不需要写寄存器

条件分支指令不需要访问内存和写寄存器

jump 不需要alu 不需要读内存，不需要读写寄存器



## 4.3.1多周期处理器思想



单周期处理器，时钟周期按最长的为准，太长了

解决思路

1. 每条指令执行分为多个阶段，每个阶段都在一个时钟周期内完成
2. 取指令、指令译码、执行、访存、结果返回
3. 把每个阶段结果保存在专用寄存器中

要求：

- 时钟周期长短取决于花费时间最多的阶段
- 各个阶段时间尽可能相同
- 每个阶段只能完成基本操作1个：1次访存或读写寄存器或ALu运算

好处：

- 缩短了时钟周期
- 不同指令所用周期可以不同
- 功能部件可以复用



加法器+ALU (多周期只需要一个ALU,不同时期可以复用)

指令/数据存储器（多周期时候合用一个寄存器，不同周期重复使用）

load指令 lw rt ts imm16

多周期处理器

取指

译码

执行

访存

写回

1. 指令分为五个阶段，顺序执行
2. 统一阶段是可以同时发生的
3. 每个阶段结果保存在内部寄存器中

共同点：指令独占整个数据通路

## 4.3.2**多周期处理器设计**

多周期数据通路

R

Ori

load

store

分支

跳转

多周期控制信号取值在指令执行过程中发生变化

控制信号iord控制多路选择器，位存储器读操作选择地址。读指令时候来自PC寄存器，读数据地址来自ALU

irwr决定是否对指令寄存器ir进行写操作，一条指令执行过程中，只有一个周期将指令写入ir

regwr 对寄存器文件进行写操作，译码周期读寄存器，写回周期会写寄存器

实现多周期的控制器

单周期控制器

控制信号整个指令执行过程保持不变

真值表反应指令和控制信号的关系

真值表实现控制器

多周期控制器能不能这样实现

不能，每个指令多个周期，每个周期控制信号取值不同



多周期控制器需要另外一种方式来描述与控制信号的关系

- 有限状态机：组合逻辑硬连线
- 微程序，设计微程序，rom存放程序实现

组合逻辑的方法

opcode 状态寄存器 输入得到输出

当前指令控制周期，下一状态

- 不同状态不同的控制信号
- 下一状态看成和其他控制信号一样
- 下一状态是当前状态和操作吗的函数

状态表

- 每条指令从0 Ifetch开始

- R ori sw 4
- beq jmp 3
- load 5

## 4.3.3 多周期处理器的性能

22%LOAD 11 store 49 r  16 branch 2 jmp

cpi多少

每种指令周期数

load 5

store 4

r 4

brach 3

jump 3

cpi = 时钟周期总数/指令数=每类指令加权评价

22%*5+11%*4+49%4+16%3+2%3=4.04

例子2

load 5

alu 4

store 4

beq jmp 2

个欸指令执行占比load 20 store 10 alu 50 beq 15 jmp 5

两种处理器时钟周期时间分别40ns 10ns

speedup = 1  * 40/3.8*10  =1.05

结论：

多周期cpi变大，时间周期时间变短，称为多周期处理器提升关键

## 4.4.1什么是流水线

20世纪美国工程师泰勒发明，是管理学界最大的发明

1913年10月7日，福特公司创立了汽车装配流水线，使得速度提高了8倍，第一次实现了10秒一部汽车的神话

流水线是一种多条指令的执行过程相互重叠的实现技巧，使cpu可以通过并行执行多条指令来提高吞吐率

洗衣店

- 每个步骤30分钟
- 顾客按排队顺序进入
- 洗衣店每次只允许一个顾客进入

每个洗衣任务完成时间 2小数

吞吐量 4个洗衣服任务 8小时  0.5任务/小时

流水线处理

每个洗衣完成时间2小时

四个洗衣服3.5完成

加速比8/3.5 = 2.3

吞吐率 4/3.5 =1.14任务/小时

每个设备使用率 57%

流水线的奇妙

- 单个任务执行时间不变
- 多个任务，并行处理，单位时间完成的工作量大大增加了
- 不改变单个任务执行时间的前提下，流水线提高了吞吐率

流水线适合大量重复的时序过程

流水线技术难以理解，每个时钟周期内同时会有多条指令在一个数据通路上执行

为了帮助我们理解流水线原来，两种图形表示方法

lw

sub

add

lw

add

多周期流水线时空图

洗衣房

流水线整体情况

流水线时间

通过时间=m

与流水线级数有关

总时间=m+N-1

m流水线级数

N 指令数

单周期流水线图

描述了一个时钟周期内整个数据通路的内容

**流水线的性能**

假设以下操作

取指令 200

寄存器读 100

alu 200

存储器读 200

存储器写 100

比较单周期与流水线性能

**单周期性能**

- 每条指令1个时钟周期
- 时钟周期800Nps
- N条800Nps



流水线

- 时钟200
- 每条指令执行时间1ns
- 执行N条指令（4+N)200ps

N无穷大 加速比   4



什么特征适合流水线

- 指令长度一致，简化取指令和译码操作
- 指令格式少，源寄存器位置相同，有利于指令未知就可取操作数
- 只有load.store访存，减少操作步骤，规整流水线
- 数据指令内存对齐，有利于访存次数和流水线的规整

规整简单

mips流水方式执行

## 4.4.2流水线冒险

load 5个周期，5个部件同时工作

- 每个时钟周期5给功能部件同时工作
- 后面指令在前面完成取指后马上开始
- 每个load指令仍然需要5个时钟周期完成，
- 吞吐量提高很多，理想情况下
  - 每个周期一条指令进入流水线
  - 每个时钟周期一条指令完成
  - 每条指令时钟周期是1

R 型

取值

译码

计算

写回



问题

- load R流水线
- 两条指令同时写寄存器

一个功能部件同时倍多条指令使用的现象，称为结构冒险

为了保证流水线

- 每个功能部件每条指令只能用一次（如不能两次或两次以上使用寄存器文件写端口）
- 每个功能部件必须在相同阶段倍使用，（如总是第5阶段使用寄存器文件端口）

法1：流水线中插入气泡

插入气泡

​	抵达某个流水段的指令正常执行，其余指令在鸽子当前的流水段等待一个周期

插入气泡到流水线，进制统一周期两次写寄存器，缺点

- 控制逻辑复杂
- 第5周期没指令执行

法2 R 型指令wr延后一个周期执行

插入一个空操作

变得规整了

加一个nop阶段延迟指令写操作

把写操作安排在第五阶段，R-type Mem阶段空NOP

store 5周期

beq加一个变5周期



消去办法：

- 都划分为5个阶段
- 不需要的加nop操作

五段流水线数据通路

结构冒险

控制冒险

条件分支导致的延迟现象，

beq指令第四周期取出来

- 目的地址第7周期送到PC
- 第八周期才能取出目的地址的指令执行

结果：取目标指令之前，有三条指令被去处理，取错了三条指令

分支冒险，转移冒险

数据冒险

load r指令

load第一周期取出来

- 数据在第五周期才写入寄存器
- 第六个周期，写入数据才能使用

结果：load指令有效钱，已经有三条指令取出来，若他们用到load数据，需要延迟

数据相关



流水线三种冒险

冒险:无法正确执行后续指令，或者执行了不应该的指令

结构冒险

同一个部件被不同指令所使用

数据冒险

后面的指令用到前面指令的结果，结果还没产生

控制冒险

转移或异常出现改变了执行流程，顺序执行指令在目标地址前已经被取出来了

## 4.4.3 数据冒险的解决方法

1. 硬件阻塞
2. 软件差nop
3. 转发，旁路技术
4. 编译优化，调整指令顺序

**硬件阻塞**

三条指令数据冒险，数据冒险，无法按预期进行

虽然sub的取指阶段正常允许，但是由于冒险，译码操作最早第6个周期进行

指令执行的推迟，

硬件阻塞方法，直到需要的数据写入计算器，

流水线气泡

缺点：控制非常复杂，改造数据通路

- 检测数据相关
- 插入气泡

思想可以利用，操作十分麻烦

**法2：软件插入nop指令**

add sub 插入若干指令，延迟sub指令执行

指令不能影响程序正确性，一般用nop

缺点：浪费了三条数据指令的时间和空间

**法 3 转发技术**

指令sub不能及时执行的原因

- 寄存器数据不是最新
- 指令只能从寄存器获得源操作数
- 其实数据已经在alu里面
- 如果允许指令从流水线寄存器中获得源操作数呢？

sub最早可以在第四个周期取出来源操作数

时间早于alu单元进行sub操作时间

**把数据从流水线寄存器直接送到alu的输入**

增加一条专门的数据传输线

增加一个监测点，译码段，检测当前id段的指令源操作数是否是前面阶段的结果，是否数据相关

五条指令

转发 旁路后

- 数据从流水线寄存器直接送到alu输入端
- 寄存器写读分别安排在前后部分，写入数据在同一周期读出

load use指令序列，转发不是万能

硬件检测

- 译码端，判断适合load 指令
- 判断数据相关
- sub译码段执行
- and取值执行
- 周期结果写入流水线
- 增加阻塞点、检测到load use 阻塞后续进行

sub指令结果清零，爆出sub指令不败

保持pc值不变

转发：

增加转发单元

**法4 编译优化**、调整指令执行顺序

把无关的语句调整顺序，增加新执行，效率提高了

编译优化，优化了30-50



## 4.4.4**控制冒险处理**

解决流水线控制冒险

1. 硬件阻塞    延迟分支后的指令执行，直到分支指令完成，产生新的pc值
2. 软件插入nop
3. 分支预测
4. 延迟分支



分支预测

静态预测

- 总是预测条件不满足，即：继续执行分支命令的后续命令
- 启发式预测：特定情况总是成功，其他情况与不成功。比如循环顶部分预测为转移不成功，达到65-85的准确预测率

动态检测

- 根据程序执行历史情况，动态预测与调整，90的准确率

简单静态分支预测

- 总是预测条件不满足，继续执行后续指令
- 预测错误，吧三条不该执行的指令丢弃
- 延迟损失时间片：预测错误会给流水线带来延迟损失C=3

性能

- 转移概率50，预测正确率也是50，正确率不高

预测错误代价

- 与何时能确定发生转移有关，早点好
- 把是否转移确定工作提前，不要等到mem阶段才确定

提前到那？



动态预测方法

- 最近转移的情况，预测下一次发生的转移

思想：分支指令之前的情况，多少次转移，多少次不转移

- 预测后，实际发生时候验证并调整预测
- 转移发生的历史情况记录在特定的缓存
  - 分支历史记录表BHT

预测位

转移目的地址

分支指令地址

pc查找表

都不相等，未命中

- 不是分支命令
- 没出现过
- 认为顺序执行
- 加入新项，填入指令地址和转移目的地址，初始化预测位

命中，取出来预测位，根据预测位置，选择转移取还是顺序取



**延迟分支技术**

静态调度技术，编译器重新排列顺序

基本思想

- 分支指令前面与分支指令无关的指令调度到分支指令后面执行，填充延迟时间片，找不到可调度的指令时候用nop填充

调整后load-use数据冒险

调度后分支延迟损失，与时间片大小有关



# 实验三 运算器的设计

## 1 实验内容介绍

工具

加法

减法

乘法

## 2 实验工具

基本逻辑单元 与门 或门 非门

logisim

## 3.加法器实现

## 4减法器实现

## 5.乘法器实现

## 4.5.1 微程序控制器的基本思想

多周期控制器

**组合逻辑**

**微程序**

开电视onTv

1. 插电源
2. 按开关

组合逻辑：判断ontv,判断执行到那个周期，第一周期操作1，第二周期操作2，与门组合一块

微程序：没有组合逻辑电路，把执行的动作保存在特殊的存储器CM上，

操作1 0，操作2 0 1。

**定义**：微操作用位指令表示，固话在特定的存储器上，为每条机器指令编制一个微程序，执行该微程序，完成该机器指令的执行。

思想：

1. 仿照程序设计，编址每条指令对应的微程序
2. 每个微程序由若干微指令构成，一条微指令包含若干微命令

一条微指令相当于一个状态，微命令就是状态中的控制信号

3. 所有微程序只放一个只读存储器中，执行某条指令时，取出对应微程序中各条微指令，译码产生对应微命令，这些微命令就是控制信号
4. 只读存储器称为控制存储器，简称控存

**特点**

- 规整，可维护，灵活，速度慢

微指令

- 机器指令执行的微操作序列中能够在一个节拍内完成的微操作作用控制位构成的二进制代码串表示
- 指令的执行，微指令的序列

微程序

- 实现一条指令功能的许多条指令组成的序列
- 微指令序列=微指令
- 一条指令对应一段微程序

控制存储器

- 存放微程序的存储器
- 所有指令的微程序保存在控制器中

微命令

- 控制部件通过控制线向执行部件发出的各种控制命令
- 控制部件和执行部件通过控制线和反馈线进行联系

微操作

- 执行部件接收微命令后执行的基本操作

微指令周期

- 微指令：机器一个cpu周期内，一组实现一定操作功能的微命令的组合
- 从控制存储器读取一条微指令并执行玩相应操作所需要时间
- 时间固定
- 和指令周期区别：指令周期时间可以变化

## 4.5.2wikes模型

wilkes提出微程序概念

- 一种控制器设计的系统化方法
- 给计算机控制器的设计和实现带来巨大影响

wilkes模型

ibm360运用技术，系列机概念

不同型号的系列机程序指令兼容

第三代计算机的里程碑 ibm360 

- 最早使用半导体元件的通用计算机

CM控制存储器

微指令寄存器：控制信号字段，微地址吗字段

微地址寄存器

微地址译码器

微程序控制器：上述方法设计的控制器

- 软件方法设计硬件
- 慢

- 微指令寄存器：存放微指令信息

- 微程序控制逻辑

- 访问地址控制部件

- 控制信号字段

- 微地址码字段

微指令地址形成逻辑

- 地址吗控制信息和机器状态
- 操作吗变换

工作过程

- 执行微指令
- 取IR操作码
- 形成CM地址
- 取微指令
- 微地址字段发送至FCMAR
- 2 3 4重复，取下一条指令

## 4.5.3 微程序设计关键问题

微指令编码

确定下一条微指令地址

- 将机器指令转换位为微程序执行
- 微程序是一个微指令序列
- 每条微指令是一串01序列，包含若干微命令
- 每个微命令控制数据通路的执行

控制程序

- 指令的编码
- 下条指令怎么取

1. 微指令对微命令编码
2. 下一条微指令在哪

微指令 包括 微命令，下条微指令地址，常数

微操作吗

- 直接控制型
- 字段直接编码法
- 字段间接编码法
- 最短垂直编码法

微程序执行顺庆控制

- 顺序转移法
- 断定法，下址字段法

- 取微程序地址
- 首条微指令
  - 顺序执行
  - 无条件转移执行
  - 分支执行

# 第五章 存储层次结构

## 5.1 存储器概述

存储器是计算机系统中的记忆设备，用来存放程序和数据



主存 memory 内存 记忆装置。存储器整体

包括：记录介意，有关电路和其他部件

辅存：外存，本意仓库。多指记录介质本身：包括磁盘、固态盘、磁带、存储阵列

cpu 主存储器 辅助存储器

主存用于存放当前处于活动状态的程序和数据，是cpu可直接访问的存储器



存储器在现代计算机中的作用

1. cpu提供数据和指令
2. 控制输入输出设备读写

在整个计算机传输处于中心地位

存储设备贯穿真个计算机领域

不同的层次

cpu

- 寄存器
- L1高速缓存SRAM
- L2高速缓存SRAM

主机

- 主存储器 DRAM
- 二级存储 本地磁盘
- 远程二级存储 分布式文件 web服务器

小而快

大而慢

存储器对应用程序的性能影响很大

程序数据在

寄存器中 一个时钟周期

cache 1-30个周期

主存 50-200周期

磁盘 几千万周期

**基本术语**

记忆单元/存储位元

- 具有两种稳态的保存二进制数01的物理器件

主存 一个位元存1比特

存储单元/编址单位

- 存储器中具有相同地址的那些位构成一个存储单元，又称为一个编址单位
- 主存一个存储单元 一个字节 8bit

存储体/存储矩阵/存储阵列

- 所有存储单元构成一个存储阵列

存储器地址寄存器 mar

- 存放主存单元地址的寄存器

存储器数据寄存器 mdr

- 用于存放主存单元中数据的寄存器

机器字长

- 运算器中参加运算的寄存器的位数：数据通路的宽度

存储字

- 存储芯片一个读写单位，一般等于存储器的数据线宽度

编址方式：对存储体中各个存储单元进行编号的方法

- 按字节编址   基本都是
- 按字编址 早期

传输单位：一次读写存储器的数据单位

- 主存：一次从注册呢读入写出的数据位数
- 辅存：数据通常按快传输，传输单位是块

386 字节编址 机器字长32位，单字位16，传输单位 8 16 32 64

## 5.1.2 存储器分类

分类标准

计算机中作用

- 寄存器存储器
  - 便签存储器，寄存器构成，cpu内
  - 存放执行的指令和数据
  - 触发器实现，速度快，容量小 kb级别
- 高速缓冲存储器
  - cpu内部，主存和cpu之间
  - 用来 正在执行的局部程序段和数据
  - sram 速度ns 容量mb
- 主存储器
  - cpu外
  - 已经被启动的程序和用的数据
  - dram 速度ns 容量 gb 比cpu慢一个数量级
- 辅存
  - 不同cpu之间访问
  - 不运行的程序和数据
  - 容量大 tb ms级别
- 其他功能存储器
  - 控制cm:微程序
  - 表格存储器：加快cpu处理设置 倒数表，函数表
  - 字库和数据缓冲存储器，显示和印刷输出设备

存储介质

- 半导体存储scm

  - 速度块，内存

    记忆原来：双稳态触发器，电容（静态，动态）

- 磁表面存储器msm

  - 陶瓷，非磁性金属或塑料
  - 此话后不同剩磁状态记录
  - 易丢失，容量大，价格低
  - 外存

- 光盘存储器odm

  - 有机玻璃载体，磁化，晶化/非晶态表示信息
  - 非易失，可靠性高，保存时间长，容量大，容易更换
  - 存储器速度比硬盘还低

- 铁电ream

- 相位rcm

- 阻变reram

- 掉电数据不丢失，速度块

存储方式

- 随机访问存储器

  - 存储任意单元可随时访问且
  - 访问时间与存储单元所处的物理位置无关
  - 速度块ns
  - 主存和cache

- 只读存储器rom

  - 正常工作只读，随机读出，不能随机写入
  - mrom 只读
  - prom 一次写
  - eprom e2prom 多次改写

- 相连存储器cam
  - 按内存检索到存储位置读写
  - 速度块，价格高
  - 块表tle
- 直接存取寄存器das
  - 信息组织同sas，介于随机和顺序存取之间
  - 可以之间定位到要读写的数据块，存取时间长短与数据所在位置有关
  - 速度慢
  - 磁盘
- 顺序存储器sas
  - 存储以块位单位，顺序记录在存储介质
  - 数据按顺序从存储在他始端读出写入，存取时间的长短与数据位置有关
  - 速度慢，容量大，成本低，后院外存
  - 磁带，vcd,ccd

存储器信息的可保存

断电后是否丢失数据

挥发性存储器 易失性存储器

- 断电信息丢

- sram dram

永久性 非易失性 存储器

- 断电信息不丢失
- 磁盘，闪存，rom

读出后数据还在？

破坏性存储器

- 信息破坏，需要重写
- dram

非破坏性存储器

- 读出信息不破坏
- sram

## 5.1.3 内存主要技术指标

内存 cpu直接访问存储器

内容容量

存储容量

- 内存所能容纳二进制位数总和，即构成内存的存储单元的综合
- 存储容量=存储单元个数*内阁存储单元的存储位元个数
- 一般，内存的存储容量越大越好
- 常用单位 B KB 10 MB 20 GB 30TB40

存储器速度

存取时间

存储周期

Ta 启动一次存储器操作到完成该操作所用时间

Ts 连续两次启动同一存储器进行存取操作所需的最小时间间隔，亦或是存取周期或访问周期 两次操作最小间隔

读   启动读命令到读出的数据送MDR的时间

写   从启动到MDR内容写入指定存储单元的时间

访问时间，反映存储器速度指标，决定了cpu发出读写后必须等待的时间

Ta<Ts 

破坏性读出必须重写，非破坏不用则

**存储宽度**

一次访存操作可存钱的数据位数或字节数，由编址方式决定

**存储带宽**

每秒传输的最大数据 bit/s

存储周期500ns 每个存储和周期可访问16位

32M

可靠性

MTBF 衡量主存的可靠性

MTBF 两次故障平均时间间隔

编码纠错技术进行容错处理

银河2 cpu 64位 存储器字长 72位，海明码纠1检2 提高主存可靠性

功耗与集成度

存储带宽功耗反应存储器件耗电多少

维持功耗

工作功耗

集成度：单个存储芯片的容量

存储器综合性能

性价比

容量高速度块价格低

**内存外存关系**

1. 任务启动，执行任务的程序和数据将从外存成批传送到内存
2. cpu从内存中逐条读取该程序的指令及数据
3. cpu逐条执行指令，按指令要求完成对数据的处理和运算
4. 指令运算处理结构送回内存保存
5. 任务完成，处理得到的全部结构成批传送到外存长久保存

外存慢 便宜 大 cpu不能直接访问 非易失性

利用他们的特点设计理想的存储器

## 5.1.4随机存取存储器

半导体存储

- 随机存储RAM
  - 静态随机存储SRAM cache
    - 加电，信息一直保存
    - 干扰不敏感
    - 比DRAM块，贵
  - 动态随机存储DRAM  主存
    - 每隔一段时间刷新
    - 电器干扰敏感
    - SRAM慢，便宜
- 只读存储器ROM
  - 不可在线修改内容ROM  BIOS
  - 闪存flash memory  主存扩展 u盘

工艺 

双极

mos ram

原理

- 触发器：互补的两个状态 六管静态mos电路
- 电容 冲放电 单管动态mos电路

基本存储位和存储器

存储位元 存储单元 存储矩阵 存储芯片（译码，驱动，读写电路） 存储模块 存储器

六管静态mos电路

sram 不需要刷新

动态单管mos

构造和表示

读出需要重写

优点：电路少，能耗低，集成度高 主存

缺点 速度慢，需要重写，定期刷新

存储器芯片

- 存储体
- 外围电路
- 地址译码与读写控制

线选法 一维地址译码

m字*n字存储阵列

子线：地址驱动线



k位地址，地址译码驱动选择线条数 2的k次方

sram 线选线，单方向译码，同时读出一条子线所有位

**位片式**二维双译码

k位地址，地址译码驱动选择条数？

2^k/2 + 2^k/2

位片式可在字方向和位方位扩冲，需要有片选信号

行列选中

we 写使能，高时读操作



​          Dram   SRAM

原理    电容   触发器

集成度  高        低

速度      慢      块

引脚      少       多

钱         低       高

刷新      有    无

应用    主存     高速缓存

存储器模块 多个存储器加存储控制器 主存



DIMM 

CIM

每次访存总是在某一个内存条

内存条

- 若干dram芯片焊制在电路板上
- 内存条插主板内存插槽
- ddr3
- 双倍数据同步dram
- 两个时钟延控制信号，翻倍

## 5.15 只读存储器**rom**

地址寻址，只能随机读，不能随机写的半导体存储器

特点

- 信息只能读不能写
- 非破坏性读出，无需再生
- 随机存取工作
- 已经写入，长久保存，不受断电影响

不能随机写，但是随机读

不希望改写的信息存放其中

用途

- 存放固定程序，监控程序，启动程序，一加接通就能自动运行
- 控制存储器，存放微程序
- 函数发生器和代码转换器
- 输入输出设备，字符发生器，汉字库

rom分类

- 固定掩膜MROM
  - 只读不修改
- 一次可改写PROM
  - 只能修改一次，修改后只读
- 多次改写的ROM
  - 多次擦除，多次改写，改前擦除
  - 光擦除可编程只读存储器 UV EPROM
  - 电擦除可编程只读存储器E2PROM
  - 块擦除电可编程块擦除存储器FM

掩模MROm

- 厂家写的
- 结构简单 便宜
- 不灵活
- 标准件场

可编程ROM PROM

- 编程一次，不可改变
- 熔丝 反向二极管
- 编程按位编程

EPROM可擦除可编程

- 不能在线擦除和编程
- 不能对单个单元擦除
- 紫外线灯照射
- 不灵活

电擦除ROM EEPROM

- 电擦除
- 可在线编程和擦除
- 比RAM慢

闪存 EPROM RAM ROM优点都有



小结

机器字

存储器分类

性能指标

sram

dram



ram

地址译码

读写控制

内存 磁盘 cpu速度差越来越重要

访存速度提高

- 提高芯片速度
- cache
- 多模块存储器技术

# 实验四 数据类型转化 

整数类型转换

整数基本运算

浮点数类型转换

浮点数基本运算

类型间相互转换

## 1 整数基本运算

32位机器gcc

字符 8位

整形

- short 16
- int 32
- long 32

浮点型

- float 42
- double 64



short    int  

short   unsigned int

unsigned short int

unsigned short unsigned int 

short int unsignedi int 

长度增加，符号扩展

short int 符号扩展，真值保持不变



unsignedint 数据拓展 补0

符号拓展，0拓展

int    short

截断 直接



整数计算会溢出





## 5.2.1主存储器设计

原则

结合实际

存储器性质：主存，cache,cm,dram.sram.rom

存储器的性能指标：速度容量字长

存储器环境条件：温度，湿度，船载，机载

系统 逻辑 工艺

**系统设计 总体方案**

- 字长 宽度 存取时间 存储周期  使用场景
- 总线宽度 控制方式 纠错能力 环境条件

确定存储结构组成 外围电路 芯片类型

- 存储芯片的类型 sram dram biram rom
- 外围芯片 ecl ttl cmos
- 选址方法 重合法 线选法
- 系统结构 多体 单体 编址方式

**逻辑设计**

- 容量扩展
- 负载计算与分析
- 速度估算
- 纠错检错设计：提高可靠性确定芯片存储结构组成，外围电路，芯片类型

工艺设计

- 印刷电路板
- 机加工

器件测试



重点：逻辑设计

- 容量扩展
- 负载计算
- 速度估算

1.存储容量扩展

位扩展

存储芯片mk*n 构成存储器 mk * N

特点：字数不变，存储单元个数不变，位数扩展，字长加长

- 芯片地址码位数与存储器地址吗位数相同
- 每隔存储单元中所含存储位元数增加，给出地址后，该存储的那元中所含芯片均工作
- 需要片数 N/n 上取整

例子：16K * 6 组成16K *32 存储器需要

32/6上取整 =6

位扩展

1024* 4 构成1K * 8 几个芯片 地址范围

地址范围没变 还是10位  2芯片

000H -3ffH

片内地址

信号线链接

芯片地址线及读写控制线对应链接，数据线单独引出，没有外部译码器



**字扩展**

存储芯片 mk * n 到存储器 Mk * n

特点 ：位数不变 字长不变 扩充容量 存储单元个数增加

- 芯片地址码位数小于存储器地址吗位数
- 芯片和存储器二者的存储单元所包含位元数相同
- 给出地址后，选中芯片工作

32k 8位    到 128K  8位

需要128 / 32  = 4片

芯片连接

- A WE OE数据输入输出端 分别连接
- CS 单独引出，与高位地址吗译码结构连接



2k 8位   4k 8位 几个芯片   地址范围多少

字扩展 2倍 2芯片

地址读写控制线对应连接，片选信号分别与外部译码器各端输出

**字位扩展**

mk n    到  Mk  N

特点：字长和地址都增加

位元数改变

16k 4  到 128k 32

需要128/16  * 32/4 = 64片

芯片连接 

A WEO分别连接

CS 位并行连接，字向独立引出

DQ 位向 独立引出 字向并接

1k 4   4k 8

需要8片

存储芯片1K 地址吗10位 存储器4K 地址吗12位

**负载计算**

- 存储器逻辑设计，外围电路芯片是驱动，存储芯片各端点是负载
- 逻辑电路负载能力是有限的
- 双极型芯片各端点是电流负载
- Mos型芯片各端点是电容负载
- 负载因数 f端点：存储芯片从耨中端点一个端点的负载量称为该端点的负载因数

**速度估算**

一级门2.5ns 走线1米6ns

系统取数时间Tsa

系统存储周期**Tsm**=Tm+Td+Tr

**逻辑设计过程**

容量扩展

负载计算

速度估算



1m 1   构成 4m 32位

芯片 4*32 =128片

字数 4倍，位长32倍

## 5.2.2存储器和cpu连接

mrd mar 

数据总线

- 地址线
- 数据线
- 控制线

cpu地址线决定整个主存空间寻址范围

cpu地址线》存储芯片地址引脚线

cpu低位和存储芯片地址线相连，高位用作字扩展时候的片选信号译码

cpu数据条数决定了一次读写的最大数据宽度

cpu数据线连接到多个位扩展的芯片，扩展后位数与cpu数据线数相等



若cpu读写命令线和存储器读写控制是一根，电平一致，可直接相连

c'pu读写命令线分开，需要分别进行连接



cpu主存通信方式

异步方式 握手信号

读操作

- cpu送地址到地址线，主存进行地址译码
- cpu发读命令，等待存储器发回完成信号
- 主存受到读命令后开始读数，完成后发完成信号给cpu
- cpu接收到完成信号，数据线取数



同步方式

- cpu主存同一时钟信号，无需应答
- 主存总是在确定时间准备好数据
- cpu送出地址和读命令后，总是在确定的时间取数据

主存分rom ram 区

- rom存放系统程序，标准子程序rom芯片构造
- ram区 用户程序，ram芯片构造



存储器与cpu连接



dram的刷新

定时刷新

集中刷新

分散刷新

透明刷新

## 5.3.1  **程序访问的局部性**

计算机存储层次

cpu运作 操作寄存器

向存储器访问时候先看看cache

不在cache，访问ram,在访问ram

不在ram.访问磁盘，磁盘到ram到cacheju

局部性 

时间局部性

空间局部性



## 5.3.2cache高速缓存

cpu和主存之间的存储器

更快

加速访存

cache

存储器是i+1层

cache问题？

主存和cache映射

cache和主存映射

分块

一致性问题

主存cache地址转换

cache对程序员透明

cache sram



cache 主存划分大小相同的块

cache程序没运行时候是空的，运行时候调入chache

地址映射到cache

命中访问cache

未命中 访问主存

查找cache

命中 

cache传送cpu

不在

失效

主存法访问块，cache写入，传cpu

系统加电 无效

运行 有效

区分有效无效

如何标识？

- 每个cache tag域名、加1位-----有效位
- 开机或复位 0
- 命中 1
- flush cache 0

命中率  cahche概率

命中时间 cache时间

失效 访问信息不在cache

失效率

失效损失 主存到cache

不命中 失效损失+命中时间

平均等于数学期望

## 5.3.3 cache 主存映射

主存划分主存块

cahche分位行，一行就是一个主存块

**直接映射**

主存每一块映射一个固定cache 主存地址对应高速缓存唯一地址，模映射

映射：cache = 主存块号 mod cache行数

cache抖动

换进换出

特点

容易实现

命中时间短

淘汰替换策略简单

不灵活，cache存储空间得不到充分利用，命中率低

快设置为1如何？

快太小，没有利用空间局部性，效率低

全相联映射

主存可以装任何一行

叉车标记指出储字哪个主存块

主存tag指出对应地址位于哪个主存块

两个标记相等说明在草里面，否则失效

快冲突概率低：有空闲快，就不会冲突

实现复杂，速度慢

**组相联**

组间模映射，组内全映射

特点：

折中

**关联度**

主存快映射到cache可能存放的位置

直接映射 1

两路组相连 2

全相连 N

- 关联度高失效率低
- 关联度会提高命中时间

cache**失效率影响因素**

cache大小：cache越大，失效率低，成本高

block大小

block越大，失效率越低

快大小在大小占比低到一定程度时候失效率增高

增加快大小，缺失损失也会增大

cache容量小映射方式影响大

失效类型

- 强制失效
  - 首次访问数据块，必然失效
  - 增加块大小，减少命中
- 容量失效
  - cache不能存放程序运行所需所有块，替换后再次使用所引起cache失效
  - 增加cache大小，有利于减少命中
- 冲突失效
  - 映射到同一组块，冲突引起
  - 全相连没有这个，成本呢高，访问慢

cache抖动来源

- 容量
- 冲突

缓解抖动

- 容量
- 相连度



## 5.3 cache一致性内存

cache是副本

情况1：cache内容更新，没有改变主存，二者不一致

情况2：多个设备访存

io设备dma方式直接读写主存，不经过cache，修改了主存，cache无效，

cache改了，主存没改，io得到数据错误

情况3：多个cpucache，一个改了，其他cpuchache没改

cache写机制 写直达

写操作同时操作cache和主存

cache主存使用缓冲，写完后再缓存到cache

**写回**

新值直接去cache，不去主存



cache 修改位



替换时候如果修改了，再写回



写命中

- 写直达
- 写回

写不命中

- 写分配
- 写不分配

写直达 分配不分配都行

写回 写分配

cache映射

直接映射

- 映射唯一，无条件新信息替换

N路组相连

- 主存数据N个cache可选择，需要考虑换哪行

全相连

- 每个主存放任意行，考虑



多级**cache**

掩盖访存延迟，提高处理器执行效率

几级比较好

单极

3级

2. 联合/分立cache

指令

数据cache

有利于流水线

l1 分立

l2  l3联合

缓存技术很多

web 磁盘 局部性

## 5.4存储器层次结构

cpu存储器差距越来越大

主存速度越来越拖后退

解决

- 解决芯片速度
- 主存和cpucache
- 并行结构技术

1. 层次存储
2. 并行主存



多体存储器

多模块存储器

uma模型

unma模型

迁移

复制

侦探协议

一致性协议

# 第六章 io

## 6.1概述

输入输出 外设与内存 cpu交换的软硬件系统

- 硬件 外设 接口
- 软件 驱动

io分类

- 人机交互 鼠标键盘
- 机器读 磁盘 网络 声音设备

功能

- 输入输出
- 存储设备



io

- 慢
- 复杂
- 异步
- 实时
- 数据交互复杂
- 设备无关

指标

- 响应时间
- 吞吐率
- 带宽



## 6.2 io接口



内部接口

外部接口

屏蔽细节

提高一致接口

缓存

解决设备速度不匹配

主权区分io 为设备分配地址

io状态寄存器 忙闲

io

- 缓存寄存器
- 状态寄存器
- 控制寄存器
- io控制逻辑模块
- 外设界面控制逻辑

io接口 io端口

io接口 硬件电路 软件控制

io端口 io的寄存器

- 数据端口
- 控制端口
- 状态端口



编址方式

- 统一编址 主存编址
- 独立编址

统一

- 访存指令复用
- 读写逻辑简单
- 慢
- 占用主存

## 6.3**磁盘存储器**

磁道

扇区

柱面

记录密度 道密度 位密度

磁盘容量

读取时间

误码率

磁盘格式化

空袭

- 同步
- 区分盘区
- 可靠读出
- 格式化容量
- 非格式化容量

存取时间

- 寻道时间
- 数据传输
- 旋转时间

数据错误

- 软错误
- 硬错误

总体性能提高不匹配

- 处理器主存性能改进块
- 辅存改进慢

## 6.5.1 闪存

光盘

# 第七章 总线

总线就是信息通路

成本低

可扩展

串行

并行

总线长度

总线连接设备数

系统总线

多总线

通信总线











