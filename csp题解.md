# 第一题

## 2013-12-1

## 题目

试题编号：	201312-1
试题名称：	出现次数最多的数
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　给定n个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。
输入格式
　　输入的第一行只有一个正整数n(1 ≤ n ≤ 1000)，表示数字的个数。
　　输入的第二行有n个整数s1, s2, …, sn (1 ≤ si ≤ 10000, 1 ≤ i ≤ n)。相邻的数用空格分隔。
输出格式
　　输出这n个次数中出现次数最多的数。如果这样的数有多个，输出其中最小的一个。
样例输入
6
10 1 10 20 30 20
样例输出
10

### 题解

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 10100;

int a[N],b[N];

int main(){
    int n,res=0,m;
    cin>>n;
    for(int i=0;i<n;i++){
       cin>>a[i];
    }
    for(int i=0;i<n;i++){
       b[a[i]]++;//计算每个元素出现次数
    }
    for(int i=0;i<N;i++){
       if(res<b[i]) {
           res=b[i];//如果有出现更高的，更新
           m=i;
       }
    }
    cout<<m;
    return 0;
    
}
```



## 2014-03-1

### 题目

试题编号：	201403-1
试题名称：	相反数
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　有 N 个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数(a 和 -a 为一对相反数)。
输入格式
　　第一行包含一个正整数 N。(1 ≤ N ≤ 500)。
　　第二行为 N 个用单个空格隔开的非零整数,每个数的绝对值不超过1000,保证这些整数各不相同。
输出格式
　　只输出一个整数,即这 N 个数中包含多少对相反数。
样例输入
5
1 2 3 -1 -2
样例输出
2



### 题解 

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1010;
int a[N];
int main(){
    int n,res=0;
    cin>>n;
    for(int i=0;i<n;i++){
       cin>>a[i];
    }
    for(int i=0;i<n;i++){
       for(int j=i+1;j<n;j++){
           if(a[i]==-a[j]) res++;
       }
    }
    cout<<res;
    return 0;
    
}
```



## 2014-09-1

### 题目

试题编号：	201409-1
试题名称：	相邻数对
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　给定n个不同的整数，问这些数中有多少对整数，它们的值正好相差1。
输入格式
　　输入的第一行包含一个整数n，表示给定整数的个数。
　　第二行包含所给定的n个整数。
输出格式
　　输出一个整数，表示值正好相差1的数对的个数。
样例输入
6
10 2 6 3 7 8
样例输出
3
样例说明
　　值正好相差1的数对包括(2, 3), (6, 7), (7, 8)。
评测用例规模与约定
　　1<=n<=1000，给定的整数为不超过10000的非负整数。

### 题解

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1010;
int a[N];
int main(){
    int n,res=0;
    cin>>n;
    for(int i=0;i<n;i++){
       cin>>a[i];
    }
    sort(a,a+n);
    for(int i=1;i<n;i++){
       if(abs(a[i]-a[i-1])==1) res++;
    }
    cout<<res;
    return 0;
    
}
```



## 2014-12-1

### 题目

试题编号：	201412-1
试题名称：	门禁系统
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　涛涛最近要负责图书馆的管理工作，需要记录下每天读者的到访情况。每位读者有一个编号，每条记录用读者的编号来表示。给出读者的来访记录，请问每一条记录中的读者是第几次出现。
输入格式
　　输入的第一行包含一个整数n，表示涛涛的记录条数。
　　第二行包含n个整数，依次表示涛涛的记录中每位读者的编号。
输出格式
　　输出一行，包含n个整数，由空格分隔，依次表示每条记录中的读者编号是第几次出现。
样例输入
5
1 2 1 1 3
样例输出
1 1 2 3 1
评测用例规模与约定
　　1≤n≤1,000，读者的编号为不超过n的正整数。

### 题解

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1010;
int a[N],b[N],c[N];
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
       cin>>a[i];
    }
    for(int i=0;i<n;i++){
       b[a[i]]++;
       c[i]=b[a[i]];
    }
    for(int i=0;i<n;i++){
       cout<<c[i]<<' ';
    }
    return 0;
    
}
```

## 201503-1

### 题目

试题编号：	201503-1
试题名称：	图像旋转
时间限制：	5.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　旋转是图像处理的基本操作，在这个问题中，你需要将一个图像逆时针旋转90度。
　　计算机中的图像表示可以用一个矩阵来表示，为了旋转一个图像，只需要将对应的矩阵旋转即可。
输入格式
　　输入的第一行包含两个整数n, m，分别表示图像矩阵的行数和列数。
　　接下来n行每行包含m个整数，表示输入的图像。
输出格式
　　输出m行，每行包含n个整数，表示原始矩阵逆时针旋转90度后的矩阵。
样例输入
2 3
1 5 3
3 2 4
样例输出
3 4
5 2
1 3
评测用例规模与约定
　　1 ≤ n, m ≤ 1,000，矩阵中的数都是不超过1000的非负整数。

### 题解

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1010;
int a[N][N];
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            cin>>a[i][j];
        }
    }
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            cout<<a[j][m-i-1]<<' ';//这就是转的了矩阵
        }
        cout<<endl;
    }
    return 0;
    
}
```



## 2015-09-1

### 题目

试题编号：	201509-1
试题名称：	数列分段
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　给定一个整数数列，数列中连续相同的最长整数序列算成一段，问数列中共有多少段？
输入格式
　　输入的第一行包含一个整数n，表示数列中整数的个数。
　　第二行包含n个整数a1, a2, …, an，表示给定的数列，相邻的整数之间用一个空格分隔。
输出格式
　　输出一个整数，表示给定的数列有多个段。
样例输入
8
8 8 8 0 12 12 8 0
样例输出
5
样例说明
　　8 8 8是第一段，0是第二段，12 12是第三段，倒数第二个整数8是第四段，最后一个0是第五段。
评测用例规模与约定
　　1 ≤ n ≤ 1000，0 ≤ ai ≤ 1000。

### 题解

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1010;
int a[N];
int main(){
    int n,res=0;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    for(int i=1;i<n;i++){
        if(a[i]!=a[i-1]) res++;
    }
    cout<<res+1;
    return 0;
    
}
```



## 2015-12-1

### 题目

试题编号：	201512-1
试题名称：	数位之和
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　给定一个十进制整数n，输出n的各位数字之和。
输入格式
　　输入一个整数n。
输出格式
　　输出一个整数，表示答案。
样例输入
20151220
样例输出
13
样例说明
　　20151220的各位数字之和为2+0+1+5+1+2+2+0=13。
评测用例规模与约定
　　所有评测用例满足：0 ≤ n ≤ 1000000000。

### 题解

```c++
#include<iostream>
#include<algorithm>

using namespace std;

int main(){
    int n,res=0;
    cin>>n;
    while(n){
        res+=n%10;
        n/=10;
    }
    cout<<res;
    return 0;
    
}
```









## 2016-04-1

### 题目

试题编号：	201604-1
试题名称：	折点计数
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　给定n个整数表示一个商店连续n天的销售量。如果某天之前销售量在增长，而后一天销售量减少，则称这一天为折点，反过来如果之前销售量减少而后一天销售量增长，也称这一天为折点。其他的天都不是折点。如下图中，第3天和第6天是折点。

　　给定n个整数a1, a2, …, an表示销售量，请计算出这些天总共有多少个折点。
　　为了减少歧义，我们给定的数据保证：在这n天中相邻两天的销售量总是不同的，即ai-1≠ai。注意，如果两天不相邻，销售量可能相同。
输入格式
　　输入的第一行包含一个整数n。
　　第二行包含n个整数，用空格分隔，分别表示a1, a2, …, an。
输出格式
　　输出一个整数，表示折点出现的数量。
样例输入
7
5 4 1 2 3 6 4
样例输出
2
评测用例规模与约定
　　所有评测用例满足：1 ≤ n ≤ 1000，每天的销售量是不超过10000的非负整数。

### 题解

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1010;
int a[N];
int main(){
    int n,res=0;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    for(int i=1;i<n-1;i++){
        if((a[i]>a[i-1]&&a[i]>a[i+1])||(a[i]<a[i-1]&&a[i]<a[i+1])) res++;
    }//如果a[i]笔两边都大或者都小，则是拐点
    cout<<res;
    return 0;
    
}
```



## 2016-09-1

### 题目

试题编号：	201609-1
试题名称：	最大波动
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　小明正在利用股票的波动程度来研究股票。小明拿到了一只股票每天收盘时的价格，他想知道，这只股票连续几天的最大波动值是多少，即在这几天中某天收盘价格与前一天收盘价格之差的绝对值最大是多少。
输入格式
　　输入的第一行包含了一个整数n，表示小明拿到的收盘价格的连续天数。
　　第二行包含n个正整数，依次表示每天的收盘价格。
输出格式
　　输出一个整数，表示这只股票这n天中的最大波动值。
样例输入
6
2 5 5 7 3 5
样例输出
4
样例说明
　　第四天和第五天之间的波动最大，波动值为|3-7|=4。
评测用例规模与约定
　　对于所有评测用例，2 ≤ n ≤ 1000。股票每一天的价格为1到10000之间的整数。

### 题解

不停扫描，更新最大值

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1010;
int a[N];
int main(){
    int n,res=0;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    for(int i=1;i<n;i++){
            res=max(res,abs(a[i]-a[i-1]));
    }
    cout<<res;
    return 0;
    
}
```



## 2016-12-1

### 题目

试题编号：	201612-1
试题名称：	中间数
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　在一个整数序列a1, a2, …, an中，如果存在某个数，大于它的整数数量等于小于它的整数数量，则称其为中间数。在一个序列中，可能存在多个下标不相同的中间数，这些中间数的值是相同的。
　　给定一个整数序列，请找出这个整数序列的中间数的值。
输入格式
　　输入的第一行包含了一个整数n，表示整数序列中数的个数。
　　第二行包含n个正整数，依次表示a1, a2, …, an。
输出格式
　　如果约定序列的中间数存在，则输出中间数的值，否则输出-1表示不存在中间数。
样例输入
6
2 6 5 6 3 5
样例输出
5
样例说明
　　比5小的数有2个，比5大的数也有2个。
样例输入
4
3 4 6 7
样例输出
-1
样例说明
　　在序列中的4个数都不满足中间数的定义。
样例输入
5
3 4 6 6 7
样例输出
-1
样例说明
　　在序列中的5个数都不满足中间数的定义。
评测用例规模与约定
　　对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ ai ≤ 1000。

### 题解

两重循环，分别判断每个数在所有数组中比它大的和比他小的，如果二者相等就是中间数，输出结果，否则不存在中间数，输出-1

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1010;
int a[N];
int main(){
    int n,tag=0;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];//读数据
    }
    int big=0,small=0;//比当前大，小的个数
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            if(a[i]>a[j]) small++;
            if(a[i]<a[j]) big++;
        }
        if(small==big){//相等
            cout<<a[i];
            tag = 1;//标记找到了中位数
            break;
        }
        small=big=0;//清空大小数个数
    }
    if(tag==0) cout<<-1;//没找到中位数
    return 0;
    
}
```



## 2017-03-1

### 题目

试题编号：	201703-1
试题名称：	分蛋糕
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　小明今天生日，他有n块蛋糕要分给朋友们吃，这n块蛋糕（编号为1到n）的重量分别为a1, a2, …, an。小明想分给每个朋友至少重量为k的蛋糕。小明的朋友们已经排好队准备领蛋糕，对于每个朋友，小明总是先将自己手中编号最小的蛋糕分给他，当这个朋友所分得蛋糕的重量不到k时，再继续将剩下的蛋糕中编号最小的给他，直到小明的蛋糕分完或者这个朋友分到的蛋糕的总重量大于等于k。
　　请问当小明的蛋糕分完时，总共有多少个朋友分到了蛋糕。
输入格式
　　输入的第一行包含了两个整数n, k，意义如上所述。
　　第二行包含n个正整数，依次表示a1, a2, …, an。
输出格式
　　输出一个整数，表示有多少个朋友分到了蛋糕。
样例输入
6 9
2 6 5 6 3 5
样例输出
3
样例说明
　　第一个朋友分到了前3块蛋糕，第二个朋友分到了第4、5块蛋糕，第三个朋友分到了最后一块蛋糕。
评测用例规模与约定
　　对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 10000，1 ≤ ai ≤ 1000。



### 题解

使用两个变量，size存放当前人得到的蛋糕数，res存分给的人数，最后一个人虽然不够k，仍然算一个人，++

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1010;
int a[N];
int main(){
    int n,k;
    cin>>n>>k;//人数，至少分配蛋糕质量
    for(int i=0;i<n;i++){
        cin>>a[i];//读入蛋糕数据
    }
    int res=0,size=0;//res 分的人数，size当前人分到的蛋糕
    for(int i=0;i<n;i++){
        if(size<k){
            size+=a[i];//没分够，继续分
        }
        if(size>=k){
            size=0;//分够了，size清空，到下一个人
            res++;//分配人数加一
        }
    }
    if(size!=0) res++;//如果还有人有蛋糕，但是不到k，加一
    cout<<res;
}
```



## 2017-09-1

### 题目

试题编号：	201709-1
试题名称：	打酱油
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　小明带着N元钱去买酱油。酱油10块钱一瓶，商家进行促销，每买3瓶送1瓶，或者每买5瓶送2瓶。请问小明最多可以得到多少瓶酱油。
输入格式
　　输入的第一行包含一个整数N，表示小明可用于买酱油的钱数。N是10的整数倍，N不超过300。
输出格式
　　输出一个整数，表示小明最多可以得到多少瓶酱油。
样例输入
40
样例输出
5
样例说明
　　把40元分成30元和10元，分别买3瓶和1瓶，其中3瓶送1瓶，共得到5瓶。
样例输入
80
样例输出
11
样例说明
　　把80元分成30元和50元，分别买3瓶和5瓶，其中3瓶送1瓶，5瓶送2瓶，共得到11瓶。

### 题解

```c++
#include<iostream>
#include<algorithm>

using namespace std;


int main(){
    int n,res=0;
    cin>>n;
    while(n>=50){
        n-=50;
        res+=7;
    }
    if(n>=30){
        n-=30;
        res+=4;
    }
    res+=(n/10);
    cout<<res;
    return 0;
}
```



## 2017-12-1

### 题目

试题编号：	201712-1
试题名称：	最小差值
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　给定n个数，请找出其中相差（差的绝对值）最小的两个数，输出它们的差值的绝对值。
输入格式
　　输入第一行包含一个整数n。
　　第二行包含n个正整数，相邻整数之间使用一个空格分隔。
输出格式
　　输出一个整数，表示答案。
样例输入
5
1 5 4 8 20
样例输出
1
样例说明
　　相差最小的两个数是5和4，它们之间的差值是1。
样例输入
5
9 3 6 1 3
样例输出
0
样例说明
　　有两个相同的数3，它们之间的差值是0.
数据规模和约定
　　对于所有评测用例，2 ≤ n ≤ 1000，每个给定的整数都是不超过10000的正整数。

### 题解

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1010,MAX=10010;

int a[N];
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    sort(a,a+n);
    int m = MAX;
    for(int i=1;i<n;i++){
         m = min(m,abs(a[i]-a[i-1]));
    }
    cout<<m;
    return 0;
}
```



## 2018-03-1

### 题目

试题编号：	201803-1
试题名称：	跳一跳
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　近来，跳一跳这款小游戏风靡全国，受到不少玩家的喜爱。
　　简化后的跳一跳规则如下：玩家每次从当前方块跳到下一个方块，如果没有跳到下一个方块上则游戏结束。
　　如果跳到了方块上，但没有跳到方块的中心则获得1分；跳到方块中心时，若上一次的得分为1分或这是本局游戏的第一次跳跃则此次得分为2分，否则此次得分比上一次得分多两分（即连续跳到方块中心时，总得分将+2，+4，+6，+8...）。
　　现在给出一个人跳一跳的全过程，请你求出他本局游戏的得分（按照题目描述的规则）。
输入格式
　　输入包含多个数字，用空格分隔，每个数字都是1，2，0之一，1表示此次跳跃跳到了方块上但是没有跳到中心，2表示此次跳跃跳到了方块上并且跳到了方块中心，0表示此次跳跃没有跳到方块上（此时游戏结束）。
输出格式
　　输出一个整数，为本局游戏的得分（在本题的规则下）。
样例输入
1 1 2 2 2 1 1 2 2 0
样例输出
22
数据规模和约定
　　对于所有评测用例，输入的数字不超过30个，保证0正好出现一次且为最后一个数字。

### 题解

根据输入数据不同，判断不同的加分，因为数据规模不超过30，用一个30的for循环读入数据，当a==0退出循环,a=1时候，没跳中间，分数加1，讲连跳奖励score清0，当跳到中心，增加对应的连跳奖励，并更新连跳奖励score

```c++
#include<iostream>
#include<algorithm>

using namespace std;

int main(){
    int res=0,score=0;//res最终结果,score连跳加成
    for(int i=1;i<=30;i++){
        int a;
        cin>>a;
        if(a==0) break;
        if(a==1) 
        {
            res+=1;
            score=0;//清空连跳加成
        }
        if(a==2) 
        {
            score+=2;//更新连跳加成
            res+=score;
        }
    }
    cout<<res;
    return 0;
}
```



## 2018-09-1

### 题目

试题编号：	201809-1
试题名称：	卖菜
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　在一条街上有n个卖菜的商店，按1至n的顺序排成一排，这些商店都卖一种蔬菜。
　　第一天，每个商店都自己定了一个价格。店主们希望自己的菜价和其他商店的一致，第二天，每一家商店都会根据他自己和相邻商店的价格调整自己的价格。具体的，每家商店都会将第二天的菜价设置为自己和相邻商店第一天菜价的平均值（用去尾法取整）。
　　注意，编号为1的商店只有一个相邻的商店2，编号为n的商店只有一个相邻的商店n-1，其他编号为i的商店有两个相邻的商店i-1和i+1。
　　给定第一天各个商店的菜价，请计算第二天每个商店的菜价。
输入格式
　　输入的第一行包含一个整数n，表示商店的数量。
　　第二行包含n个整数，依次表示每个商店第一天的菜价。
输出格式
　　输出一行，包含n个正整数，依次表示每个商店第二天的菜价。
样例输入
8
4 1 3 1 6 5 17 9
样例输出
2 2 1 3 4 9 10 13
数据规模和约定
　　对于所有评测用例，2 ≤ n ≤ 1000，第一天每个商店的菜价为不超过10000的正整数。

### 题解

读入数据，处理数据，输出数据，读入数组放a[N]，输出放b[N],首尾2个数取平均，中间三个数取平均

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1010;
int a[N],b[N];
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    b[0]=(a[0]+a[1])/2;
    b[n-1]=(a[n-1]+a[n-2])/2;//首尾2个数取平均
    for(int i=1;i<n-1;i++) b[i]=(a[i]+a[i-1]+a[i+1])/3;//中间三个数取平均
    for(int i=0;i<n;i++) cout<<b[i]<<' ';
    return 0;
}
```



## 2018-12-1

### 题目

试题编号：	201812-1
试题名称：	小明上学
时间限制：	1.0s
内存限制：	512.0MB
问题描述：	
题目背景
　　小明是汉东省政法大学附属中学的一名学生，他每天都要骑自行车往返于家和学校。为了能尽可能充足地睡眠，他希望能够预计自己上学所需要的时间。他上学需要经过数段道路，相邻两段道路之间设有至多一盏红绿灯。
　　京州市的红绿灯是这样工作的：每盏红绿灯有红、黄、绿三盏灯和一个能够显示倒计时的显示牌。假设红绿灯被设定为红灯 r 秒，黄灯 y 秒，绿灯 g 秒，那么从 0 时刻起，[0,r) 秒内亮红灯，车辆不许通过；[r, r+g) 秒内亮绿灯，车辆允许通过；[r+g, r+g+y) 秒内亮黄灯，车辆不许通过，然后依次循环。倒计时的显示牌上显示的数字 l（l > 0）是指距离下一次信号灯变化的秒数。
问题描述
　　一次上学的路上，小明记录下了经过每段路的时间，和各个红绿灯在小明到达路口时的颜色和倒计时秒数。希望你帮忙计算此次小明上学所用的时间。
输入格式
　　输入的第一行包含空格分隔的三个正整数 r、y、g，表示红绿灯的设置。这三个数均不超过 106。
　　输入的第二行包含一个正整数 n（n ≤ 100），表示小明总共经过的道路段数和看到的红绿灯数目。
　　接下来的 n 行，每行包含空格分隔的两个整数 k、t。k=0 表示经过了一段道路，耗时 t 秒，此处 t 不超过 106；k=1、2、3 时，分别表示看到了一个红灯、黄灯、绿灯，且倒计时显示牌上显示的数字是 t，此处 t 分别不会超过 r、y、g。
输出格式
　　输出一个数字，表示此次小明上学所用的时间。
样例输入
30 3 30
8
0 10
1 5
0 11
2 2
0 6
0 3
3 10
0 3
样例输出
70
样例说明
　　小明先经过第一段道路，用时 10 秒，然后等待 5 秒的红灯，再经过第二段道路，用时 11 秒，然后等待 2 秒的黄灯和 30 秒的红灯，再经过第三段、第四段道路，分别用时6、3秒，然后通过绿灯，再经过最后一段道路，用时 3 秒。共计 10 + 5 + 11 + 2 + 30 + 6 + 3 + 3=70 秒。
评测用例规模与约定
　　测试点 1, 2 中不存在任何信号灯。
　　测试点 3, 4 中所有的信号灯在被观察时均为绿灯。
　　测试点 5, 6 中所有的信号灯在被观察时均为红灯。
　　测试点 7, 8 中所有的信号灯在被观察时均为黄灯。
　　测试点 9, 10 中将出现各种可能的情况。

### 题解

模拟题，按照题意读取数据，使用res存储需要时间，对于不同的红绿灯分别判断即可

```c++
#include<iostream>
#include<algorithm>

using namespace std;
int main(){
    int r,y,g;
    cin>>r>>y>>g;
    int n;
    cin>>n;
    int res=0;
    while(n--){
        int k,t;
        cin>>k>>t;
        if(k==0) res+=t;//直路，直接加行走时间
        if(k==1) res+=t;//红灯，加上红灯时间       
        if(k==2) res+=(t+r);//黄灯，加上黄灯剩余时间和一个红灯的时间        
        if(k==3) res+=0;//绿灯，不加，可以删去这句
    }
    cout<<res;
    return 0;
}
```



## 2019-03-1

### 题目

![img](http://118.190.20.162/RequireFile.do?fid=b7Gg64e9)

![img](http://118.190.20.162/RequireFile.do?fid=JrBL7JYe)

### 题解

思路

对于一个输入序列求解这个序列的最大值，中位数，最小值

首先思考如何存储数据，对于这一序列我们可以使用vector或者数组来存储，对于vetor可以动态扩容，不需要考虑开辟空间大小，对于数组在定义时候需要考虑开辟空间大小，观察输入数据范围为10^5级别，开辟一个100010大小的数组，对于函数题内部的变量会声明为局部变量，受到系统栈大小的限制函数内开辟大数组会爆栈，因此选择函数内开数组，定义为全局变量，放在堆空间上，受计算机内存大小的限制，对于数据输入规模防止看错，我们将其声明为一个常量N，修改起来更加方便。在读入数组时候，我们选择从a[1]-a[n]的存放，处理起来更加直观。

对于一个算法题代码主题框架基本上都是，读入数据，处理数据，输出结果，读入输出数据较为容易，我们主要解决处理数据的问题。

对于题目的要求，是有序的，要么升序，要么降序，他的最值只可能出现在数组的开头与结尾，二者中更大的便是最大值，反之则是最小值。

本题目的难点部分就在于中位数的处理，由于中位数当为奇数个个数时候就是最中间的元素，偶数时候就是最中间两个元素的平均数，当取平均时候需要输出四舍五入后的浮点数。需要通过判断语句来判断中位数应该如何计算。

```c++
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 100010;//数据规模
int a[N];
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    int m,M, mid;//最小，最大，中位数
    bool tag = true;//是整数与否
    m = min(a[1],a[n]);
    M = max(a[1],a[n]);//二者较大是最大，较小是最小
    if(n%2==1) mid = a[(n+1)/2];//个数奇数，直接取中间
    else
    {//个数偶数，取中间两个的平均数
        if((a[n/2]+a[n/2+1])%2!=0) tag = false;//平均数不能整除
        mid = (a[n/2]+a[n/2+1])/2;
        
    }
    if(tag)//可以整除
    printf("%d %d %d",M,mid,m);
    else//不能整除
    printf("%d %d.5 %d",M,mid,m);
    return 0;
}
```

# 第二题

## 2019-03-2

![img](http://118.190.20.162/RequireFile.do?fid=rBtBTn4A)

![img](http://118.190.20.162/RequireFile.do?fid=h83D3dGa)



![img](http://118.190.20.162/RequireFile.do?fid=h83D3dGa)

## 题目

```
试题编号：	201903-2
试题名称：	二十四点
时间限制：	1.0s
内存限制：	512.0MB
```



## 题解

```c++
#include<iostream>
#include<algorithm>

using namespace std;

int judge(char s[]){
    int a[4],i,j;
    char op[3];
    for(int i=0;i<4;i++) a[i] = s[i*2]-'0';
    for(int i=0;i<3;i++) op[i] = s[i*2+1];
    
    int k=3;
    for(i=0;i<k;i++){
        if(op[i]=='x'||op[i]=='/'){
            if(op[i]=='x') a[i]=a[i]*a[i+1];
            else a[i]=a[i]/a[i+1];
            for(j=i+1;j<k;j++){
                op[j-1]=op[j];
                a[j]=a[j+1];
            }
            i--,k--;
        }
    }
    int ans = a[0];
    for(i = 0; i < k; i++)
        if(op[i] == '+') {
            ans = a[i] + a[i + 1];
            a[i + 1] = ans;
        } else {
            ans = a[i] - a[i + 1];
            a[i + 1] = ans;
        }
    return ans==24;

}

int main(){
    int n;
    char s[8];
    cin>>n;
    while(n--){
        scanf("%s",s);
        printf("%s",judge(s)?"Yes\n":"No\n");
    }
    return 0;
    
}
```



## 2018-12-2

## 题目

```
试题编号：	201812-2
试题名称：	小明放学
时间限制：	1.0s
内存限制：	512.0MB
问题描述：	
题目背景
　　汉东省政法大学附属中学所在的光明区最近实施了名为“智慧光明”的智慧城市项目。具体到交通领域，通过“智慧光明”终端，可以看到光明区所有红绿灯此时此刻的状态。小明的学校也安装了“智慧光明”终端，小明想利用这个终端给出的信息，估算自己放学回到家的时间。
问题描述
　　一次放学的时候，小明已经规划好了自己回家的路线，并且能够预测经过各个路段的时间。同时，小明通过学校里安装的“智慧光明”终端，看到了出发时刻路上经过的所有红绿灯的指示状态。请帮忙计算小明此次回家所需要的时间。
输入格式
　　输入的第一行包含空格分隔的三个正整数 r、y、g，表示红绿灯的设置。这三个数均不超过 106。
　　输入的第二行包含一个正整数 n，表示小明总共经过的道路段数和路过的红绿灯数目。
　　接下来的 n 行，每行包含空格分隔的两个整数 k、t。k=0 表示经过了一段道路，将会耗时 t 秒，此处 t 不超过 106；k=1、2、3 时，分别表示出发时刻，此处的红绿灯状态是红灯、黄灯、绿灯，且倒计时显示牌上显示的数字是 t，此处 t 分别不会超过 r、y、g。
输出格式
　　输出一个数字，表示此次小明放学回家所用的时间。
样例输入
30 3 30
8
0 10
1 5
0 11
2 2
0 6
0 3
3 10
0 3
样例输出
46
样例说明
　　小明先经过第一段路，用时 10 秒。第一盏红绿灯出发时是红灯，还剩 5 秒；小明到达路口时，这个红绿灯已经变为绿灯，不用等待直接通过。接下来经过第二段路，用时 11 秒。第二盏红绿灯出发时是黄灯，还剩两秒；小明到达路口时，这个红绿灯已经变为红灯，还剩 11 秒。接下来经过第三、第四段路，用时 9 秒。第三盏红绿灯出发时是绿灯，还剩 10 秒；小明到达路口时，这个红绿灯已经变为红灯，还剩两秒。接下来经过最后一段路，用时 3 秒。共计 10+11+11+9+2+3 = 46 秒。
评测用例规模与约定
　　有些测试点具有特殊的性质：
　　* 前 2 个测试点中不存在任何信号灯。
　　测试点的输入数据规模：
　　* 前 6 个测试点保证 n ≤ 103。
　　* 所有测试点保证 n ≤ 105。
```



## 题解

```c++
#include<iostream>
using namespace std;
int main(){
    std::ios::sync_with_stdio(false);
    int r,y,g;
    cin>>r>>y>>g;
    int n;
    cin>>n;
    //cout<<n<<endl;
    long long ans=0,cur=0;
    while(n--){
        int k,t;
        cin>>k>>t;
        if(k==0) ans+=t;
        if(k==1) cur = r-t+y+g;
        if(k==2) cur = y-t+g;
        if(k==3) cur = g-t;
        if(k!=0){
            // int tag = (cur+ans)%(r+g+y)<g;
            // int temp = (cur+ans)%(r+g+y);
            // ans = tag?ans:(ans-temp+r+y+g);
            ans = (cur+ans)%(r+g+y)<g?ans:(ans-(cur+ans)%(r+g+y)+r+y+g);
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

## 2018-09-2

## 题目

```
试题编号：	201809-2
试题名称：	买菜
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　小H和小W来到了一条街上，两人分开买菜，他们买菜的过程可以描述为，去店里买一些菜然后去旁边的一个广场把菜装上车，两人都要买n种菜，所以也都要装n次车。具体的，对于小H来说有n个不相交的时间段[a1,b1],[a2,b2]...[an,bn]在装车，对于小W来说有n个不相交的时间段[c1,d1],[c2,d2]...[cn,dn]在装车。其中，一个时间段[s, t]表示的是从时刻s到时刻t这段时间，时长为t-s。
　　由于他们是好朋友，他们都在广场上装车的时候会聊天，他们想知道他们可以聊多长时间。
输入格式
　　输入的第一行包含一个正整数n，表示时间段的数量。
　　接下来n行每行两个数ai，bi，描述小H的各个装车的时间段。
　　接下来n行每行两个数ci，di，描述小W的各个装车的时间段。
输出格式
　　输出一行，一个正整数，表示两人可以聊多长时间。
样例输入
4
1 3
5 6
9 13
14 15
2 4
5 7
10 11
13 14
样例输出
3
数据规模和约定
　　对于所有的评测用例，1 ≤ n ≤ 2000, ai < bi < ai+1，ci < di < ci+1,对于所有的i(1 ≤ i ≤ n)有，1 ≤ ai, bi, ci, di ≤ 1000000。
```



## 题解

```c++
#include<iostream>
using namespace std;

const int N = 1e6+10;
int cnt[N];
int main(){
    int n,ai,bi;
    cin>>n;
    n=2*n;
    while(n--){
        cin>>ai>>bi;
        for(int i=ai;i<bi;i++){
            cnt[i]++;
        }
    }
    int ans=0;
    for(int i=1;i<N;i++){
        if(cnt[i]==2) ans++;
    }
    cout<<ans;
    return 0;
}
```

## 2018-03-2

## 题目

```
试题编号：	201803-2
试题名称：	碰撞的小球
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。
　　当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。
　　当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。
　　现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。
提示
　　因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。
　　同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。
输入格式
　　输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。
　　第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。
输出格式
　　输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。
样例输入
3 10 5
4 6 8
样例输出
7 9 9
样例说明
　　初始时，三个小球的位置分别为4, 6, 8。

　　一秒后，三个小球的位置分别为5, 7, 9。

　　两秒后，第三个小球碰到墙壁，速度反向，三个小球位置分别为6, 8, 10。

　　三秒后，第二个小球与第三个小球在位置9发生碰撞，速度反向（注意碰撞位置不一定为偶数），三个小球位置分别为7, 9, 9。

　　四秒后，第一个小球与第二个小球在位置8发生碰撞，速度反向，第三个小球碰到墙壁，速度反向，三个小球位置分别为8, 8, 10。

　　五秒后，三个小球的位置分别为7, 9, 9。

样例输入
10 22 30
14 12 16 6 10 2 8 20 18 4
样例输出
6 6 8 2 4 0 4 12 10 2
数据规模和约定
　　对于所有评测用例，1 ≤ n ≤ 100，1 ≤ t ≤ 100，2 ≤ L ≤ 1000，0 < ai < L。L为偶数。
　　保证所有小球的初始位置互不相同且均为偶数。
```



## 题解

```c++
#include<iostream>
using namespace std;

const int N = 1e3+10;
int pos[N],step[N];
int main(){
    int n,l,t;
    cin>>n>>l>>t;
    for(int i=0;i<n;i++){
        cin>>pos[i];
        step[i]=1;
        if(pos[i]==l) step[i]=-step[i];
    }
    while(t--){
        for(int i=0;i<n;i++){
            pos[i]+=step[i];
        if(pos[i]==0||pos[i]==l)
            step[i]=-step[i];
        }
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                if(pos[i]==pos[j]){
                    step[i]=-step[i];
                    step[j]=-step[j];
                }
            }
        }
    }
    for(int i=0;i<n;i++)
        cout<<pos[i]<<' ';
    return 0;
}
```

## 2017-12-2

## 题目

```
试题编号：	201712-2
试题名称：	游戏
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。
　　游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。
　　例如，当n=5, k=2时：
　　1号小朋友报数1；
　　2号小朋友报数2淘汰；
　　3号小朋友报数3；
　　4号小朋友报数4淘汰；
　　5号小朋友报数5；
　　1号小朋友报数6淘汰；
　　3号小朋友报数7；
　　5号小朋友报数8淘汰；
　　3号小朋友获胜。

　　给定n和k，请问最后获胜的小朋友编号为多少？
输入格式
　　输入一行，包括两个整数n和k，意义如题目所述。
输出格式
　　输出一行，包含一个整数，表示获胜的小朋友编号。
样例输入
5 2
样例输出
3
样例输入
7 3
样例输出
4
数据规模和约定
　　对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 9。
```



## 题解

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int a[N];
int main(){
    int n,k;
    cin>>n>>k;
    int cur = 0,cnt=0,res,p=-1;
    while(1){
        p = (p+1)%n;
        if(a[p]==0) {
            cur++;
            if(cur%k==0||cur%10==k){
            a[p]=1;
            cnt++;
            }
        }
        if(cnt==n-1) break;
    }
    for(int i=0;i<n;i++) if(a[i]==0) res=i;
    cout<<res+1;
    return 0;
}
```

## 2017-09-2

## 题目

```
试题编号：	201709-2
试题名称：	公共钥匙盒
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　有一个学校的老师共用N个教室，按照规定，所有的钥匙都必须放在公共钥匙盒里，老师不能带钥匙回家。每次老师上课前，都从公共钥匙盒里找到自己上课的教室的钥匙去开门，上完课后，再将钥匙放回到钥匙盒中。
　　钥匙盒一共有N个挂钩，从左到右排成一排，用来挂N个教室的钥匙。一串钥匙没有固定的悬挂位置，但钥匙上有标识，所以老师们不会弄混钥匙。
　　每次取钥匙的时候，老师们都会找到自己所需要的钥匙将其取走，而不会移动其他钥匙。每次还钥匙的时候，还钥匙的老师会找到最左边的空的挂钩，将钥匙挂在这个挂钩上。如果有多位老师还钥匙，则他们按钥匙编号从小到大的顺序还。如果同一时刻既有老师还钥匙又有老师取钥匙，则老师们会先将钥匙全还回去再取出。
　　今天开始的时候钥匙是按编号从小到大的顺序放在钥匙盒里的。有K位老师要上课，给出每位老师所需要的钥匙、开始上课的时间和上课的时长，假设下课时间就是还钥匙时间，请问最终钥匙盒里面钥匙的顺序是怎样的？
输入格式
　　输入的第一行包含两个整数N, K。
　　接下来K行，每行三个整数w, s, c，分别表示一位老师要使用的钥匙编号、开始上课的时间和上课的时长。可能有多位老师使用同一把钥匙，但是老师使用钥匙的时间不会重叠。
　　保证输入数据满足输入格式，你不用检查数据合法性。
输出格式
　　输出一行，包含N个整数，相邻整数间用一个空格分隔，依次表示每个挂钩上挂的钥匙编号。
样例输入
5 2
4 3 3
2 2 7
样例输出
1 4 3 2 5
样例说明
　　第一位老师从时刻3开始使用4号教室的钥匙，使用3单位时间，所以在时刻6还钥匙。第二位老师从时刻2开始使用钥匙，使用7单位时间，所以在时刻9还钥匙。
　　每个关键时刻后的钥匙状态如下（X表示空）：
　　时刻2后为1X345；
　　时刻3后为1X3X5；
　　时刻6后为143X5；
　　时刻9后为14325。
样例输入
5 7
1 1 14
3 3 12
1 15 12
2 7 20
3 18 12
4 21 19
5 30 9
样例输出
1 2 3 5 4
评测用例规模与约定
　　对于30%的评测用例，1 ≤ N, K ≤ 10, 1 ≤ w ≤ N, 1 ≤ s, c ≤ 30；
　　对于60%的评测用例，1 ≤ N, K ≤ 50，1 ≤ w ≤ N，1 ≤ s ≤ 300，1 ≤ c ≤ 50；
　　对于所有评测用例，1 ≤ N, K ≤ 1000，1 ≤ w ≤ N，1 ≤ s ≤ 10000，1 ≤ c ≤ 100。
```



## 题解

```c++

```

## 2017-03-2

## 题目

```
试题编号：	201703-2
试题名称：	学生排队
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　体育老师小明要将自己班上的学生按顺序排队。他首先让学生按学号从小到大的顺序排成一排，学号小的排在前面，然后进行多次调整。一次调整小明可能让一位同学出队，向前或者向后移动一段距离后再插入队列。
　　例如，下面给出了一组移动的例子，例子中学生的人数为8人。
　　0）初始队列中学生的学号依次为1, 2, 3, 4, 5, 6, 7, 8；
　　1）第一次调整，命令为“3号同学向后移动2”，表示3号同学出队，向后移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 3, 6, 7, 8；
　　2）第二次调整，命令为“8号同学向前移动3”，表示8号同学出队，向前移动3名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 8, 3, 6, 7；
　　3）第三次调整，命令为“3号同学向前移动2”，表示3号同学出队，向前移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 3, 5, 8, 6, 7。
　　小明记录了所有调整的过程，请问，最终从前向后所有学生的学号依次是多少？
　　请特别注意，上述移动过程中所涉及的号码指的是学号，而不是在队伍中的位置。在向后移动时，移动的距离不超过对应同学后面的人数，如果向后移动的距离正好等于对应同学后面的人数则该同学会移动到队列的最后面。在向前移动时，移动的距离不超过对应同学前面的人数，如果向前移动的距离正好等于对应同学前面的人数则该同学会移动到队列的最前面。
输入格式
　　输入的第一行包含一个整数n，表示学生的数量，学生的学号由1到n编号。
　　第二行包含一个整数m，表示调整的次数。
　　接下来m行，每行两个整数p, q，如果q为正，表示学号为p的同学向后移动q，如果q为负，表示学号为p的同学向前移动-q。
输出格式
　　输出一行，包含n个整数，相邻两个整数之间由一个空格分隔，表示最终从前向后所有学生的学号。
样例输入
8
3
3 2
8 -3
3 -2
样例输出
1 2 4 3 5 8 6 7
评测用例规模与约定
　　对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 1000，所有移动均合法。
```



## 题解

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int a[N];
int main(){
    int n,k;
    cin>>n>>k;
    for(int i=1;i<=n;i++) a[i]=i;
    while(k--){
        int p,q,pos;
        cin>>p>>q;
        for(int i=1;i<=n;i++){
            if(a[i]==p){
              pos=i;
                           // cout<<"pos是"<<pos<<' '<<"i 是"<<i<<" p 是 "<<p;

              break;}
        }
        if(q>0){
            for(int i=pos;i<pos+q;i++){
                a[i]=a[i+1];
            }
            a[pos+q]=p;
        }
        if(q<0){
            for(int i=pos;i>pos+q;i--){
                a[i]=a[i-1];
               // cout<<a[i]<<' '<<a[i-1]<<' ';
            }
            a[pos+q]=p;
        }
    }
    for(int i=1;i<=n;i++) cout<<a[i]<<' ';
   
    return 0;
}
```

## 2016-12-2

## 题目

```
试题编号：	201612-2
试题名称：	工资计算
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　小明的公司每个月给小明发工资，而小明拿到的工资为交完个人所得税之后的工资。假设他一个月的税前工资（扣除五险一金后、未扣税前的工资）为S元，则他应交的个人所得税按如下公式计算：
　　1） 个人所得税起征点为3500元，若S不超过3500，则不交税，3500元以上的部分才计算个人所得税，令A=S-3500元；
　　2） A中不超过1500元的部分，税率3%；
　　3） A中超过1500元未超过4500元的部分，税率10%；
　　4） A中超过4500元未超过9000元的部分，税率20%；
　　5） A中超过9000元未超过35000元的部分，税率25%；
　　6） A中超过35000元未超过55000元的部分，税率30%；
　　7） A中超过55000元未超过80000元的部分，税率35%；
　　8） A中超过80000元的部分，税率45%；
　　例如，如果小明的税前工资为10000元，则A=10000-3500=6500元，其中不超过1500元部分应缴税1500×3%=45元，超过1500元不超过4500元部分应缴税(4500-1500)×10%=300元，超过4500元部分应缴税(6500-4500)×20%=400元。总共缴税745元，税后所得为9255元。
　　已知小明这个月税后所得为T元，请问他的税前工资S是多少元。
输入格式
　　输入的第一行包含一个整数T，表示小明的税后所得。所有评测数据保证小明的税前工资为一个整百的数。
输出格式
　　输出一个整数S，表示小明的税前工资。
样例输入
9255
样例输出
10000
评测用例规模与约定
　　对于所有评测用例，1 ≤ T ≤ 100000。
```



## 题解

```c++
#include<iostream>
using namespace std;
const int N = 2000;
int a[N];
int tax(int m){
    int tax = 0;
    int A= m-3500;
    if(A<0) tax=0;
    else{
        if(A<=1500) tax = A*0.03;
        else if(A<=4500) tax = 1500*0.03+(A-1500)*0.1;
        else if(A<=9000) tax = 1500*0.03+(4500-1500)*0.10+(A-4500)*0.2;
        else if(A<=35000) tax = 1500*0.03+(4500-1500)*0.10+(9000-4500)*0.2+(A-9000)*0.25;
        else if(A<=55000) tax = 1500*0.03+(4500-1500)*0.10+(9000-4500)*0.2+(35000-9000)*0.25+(A-35000)*0.30;
        else if(A<=80000) tax = 1500*0.03+(4500-1500)*0.1+(9000-4500)*0.2+(35000-9000)*0.25+(55000-35000)*0.30+(A-55000)*0.35;
        else tax = 1500*0.03+(4500-1500)*0.10+(9000-4500)*0.2+(35000-9000)*0.25+(55000-35000)*0.30+(80000-55000)*0.35+(A-80000)*0.45;
    }
    return tax;
}
int main(){
    for(int i=1;i<N;i++)
        a[i]=(i*100-tax(i*100));
    int m;
    cin>>m;
    for(int i=1;i<N;i++)
        if(a[i]==m) {cout<<i*100;break;}
    return 0;
}
```

## 2019-03-1

## 题目

```

```



## 题解

```c++

```



第三题

第三题

第四题

第五题

