第一题

2013-12-1

题目

试题编号：	201312-1
试题名称：	出现次数最多的数
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　给定n个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。
输入格式
　　输入的第一行只有一个正整数n(1 ≤ n ≤ 1000)，表示数字的个数。
　　输入的第二行有n个整数s1, s2, …, sn (1 ≤ si ≤ 10000, 1 ≤ i ≤ n)。相邻的数用空格分隔。
输出格式
　　输出这n个次数中出现次数最多的数。如果这样的数有多个，输出其中最小的一个。
样例输入
6
10 1 10 20 30 20
样例输出
10

题解



2014-03-1

题目

试题编号：	201403-1
试题名称：	相反数
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　有 N 个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数(a 和 -a 为一对相反数)。
输入格式
　　第一行包含一个正整数 N。(1 ≤ N ≤ 500)。
　　第二行为 N 个用单个空格隔开的非零整数,每个数的绝对值不超过1000,保证这些整数各不相同。
输出格式
　　只输出一个整数,即这 N 个数中包含多少对相反数。
样例输入
5
1 2 3 -1 -2
样例输出
2

题解





2014

题目



题解



2014-09-1

题目

题解

试题编号：	201409-1
试题名称：	相邻数对
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　给定n个不同的整数，问这些数中有多少对整数，它们的值正好相差1。
输入格式
　　输入的第一行包含一个整数n，表示给定整数的个数。
　　第二行包含所给定的n个整数。
输出格式
　　输出一个整数，表示值正好相差1的数对的个数。
样例输入
6
10 2 6 3 7 8
样例输出
3
样例说明
　　值正好相差1的数对包括(2, 3), (6, 7), (7, 8)。
评测用例规模与约定
　　1<=n<=1000，给定的整数为不超过10000的非负整数。

2014

题目

题解



2014

题目

题解



2014

题目

题解



2014

题目

题解



2017-09-1

题目

试题编号：	201709-1
试题名称：	打酱油
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　小明带着N元钱去买酱油。酱油10块钱一瓶，商家进行促销，每买3瓶送1瓶，或者每买5瓶送2瓶。请问小明最多可以得到多少瓶酱油。
输入格式
　　输入的第一行包含一个整数N，表示小明可用于买酱油的钱数。N是10的整数倍，N不超过300。
输出格式
　　输出一个整数，表示小明最多可以得到多少瓶酱油。
样例输入
40
样例输出
5
样例说明
　　把40元分成30元和10元，分别买3瓶和1瓶，其中3瓶送1瓶，共得到5瓶。
样例输入
80
样例输出
11
样例说明
　　把80元分成30元和50元，分别买3瓶和5瓶，其中3瓶送1瓶，5瓶送2瓶，共得到11瓶。

题解

    #include<iostream>
    #include<algorithm>
    
    using namespace std;
    
    
    int main(){
        int n,res=0;
        cin>>n;
        while(n>=50){
            n-=50;
            res+=7;
        }
        if(n>=30){
            n-=30;
            res+=4;
        }
        res+=(n/10);
        cout<<res;
        return 0;
    }



2017-12-1

题目

试题编号：	201712-1
试题名称：	最小差值
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　给定n个数，请找出其中相差（差的绝对值）最小的两个数，输出它们的差值的绝对值。
输入格式
　　输入第一行包含一个整数n。
　　第二行包含n个正整数，相邻整数之间使用一个空格分隔。
输出格式
　　输出一个整数，表示答案。
样例输入
5
1 5 4 8 20
样例输出
1
样例说明
　　相差最小的两个数是5和4，它们之间的差值是1。
样例输入
5
9 3 6 1 3
样例输出
0
样例说明
　　有两个相同的数3，它们之间的差值是0.
数据规模和约定
　　对于所有评测用例，2 ≤ n ≤ 1000，每个给定的整数都是不超过10000的正整数。

题解

    #include<iostream>
    #include<algorithm>
    
    using namespace std;
    
    const int N = 1010,MAX=10010;
    
    int a[N];
    int main(){
        int n;
        cin>>n;
        for(int i=0;i<n;i++) cin>>a[i];
        sort(a,a+n);
        int m = MAX;
        for(int i=1;i<n;i++){
             m = min(m,abs(a[i]-a[i-1]));
        }
        cout<<m;
        return 0;
    }



2018-03-1

题目

试题编号：	201803-1
试题名称：	跳一跳
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　近来，跳一跳这款小游戏风靡全国，受到不少玩家的喜爱。
　　简化后的跳一跳规则如下：玩家每次从当前方块跳到下一个方块，如果没有跳到下一个方块上则游戏结束。
　　如果跳到了方块上，但没有跳到方块的中心则获得1分；跳到方块中心时，若上一次的得分为1分或这是本局游戏的第一次跳跃则此次得分为2分，否则此次得分比上一次得分多两分（即连续跳到方块中心时，总得分将+2，+4，+6，+8...）。
　　现在给出一个人跳一跳的全过程，请你求出他本局游戏的得分（按照题目描述的规则）。
输入格式
　　输入包含多个数字，用空格分隔，每个数字都是1，2，0之一，1表示此次跳跃跳到了方块上但是没有跳到中心，2表示此次跳跃跳到了方块上并且跳到了方块中心，0表示此次跳跃没有跳到方块上（此时游戏结束）。
输出格式
　　输出一个整数，为本局游戏的得分（在本题的规则下）。
样例输入
1 1 2 2 2 1 1 2 2 0
样例输出
22
数据规模和约定
　　对于所有评测用例，输入的数字不超过30个，保证0正好出现一次且为最后一个数字。

题解

根据输入数据不同，判断不同的加分，因为数据规模不超过30，用一个30的for循环读入数据，当a==0退出循环,a=1时候，没跳中间，分数加1，讲连跳奖励score清0，当跳到中心，增加对应的连跳奖励，并更新连跳奖励score

    #include<iostream>
    #include<algorithm>
    
    using namespace std;
    
    int main(){
        int res=0,score=0;//res最终结果,score连跳加成
        for(int i=1;i<=30;i++){
            int a;
            cin>>a;
            if(a==0) break;
            if(a==1) 
            {
                res+=1;
                score=0;//清空连跳加成
            }
            if(a==2) 
            {
                score+=2;//更新连跳加成
                res+=score;
            }
        }
        cout<<res;
        return 0;
    }



2018-09-1

题目

试题编号：	201809-1
试题名称：	卖菜
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　在一条街上有n个卖菜的商店，按1至n的顺序排成一排，这些商店都卖一种蔬菜。
　　第一天，每个商店都自己定了一个价格。店主们希望自己的菜价和其他商店的一致，第二天，每一家商店都会根据他自己和相邻商店的价格调整自己的价格。具体的，每家商店都会将第二天的菜价设置为自己和相邻商店第一天菜价的平均值（用去尾法取整）。
　　注意，编号为1的商店只有一个相邻的商店2，编号为n的商店只有一个相邻的商店n-1，其他编号为i的商店有两个相邻的商店i-1和i+1。
　　给定第一天各个商店的菜价，请计算第二天每个商店的菜价。
输入格式
　　输入的第一行包含一个整数n，表示商店的数量。
　　第二行包含n个整数，依次表示每个商店第一天的菜价。
输出格式
　　输出一行，包含n个正整数，依次表示每个商店第二天的菜价。
样例输入
8
4 1 3 1 6 5 17 9
样例输出
2 2 1 3 4 9 10 13
数据规模和约定
　　对于所有评测用例，2 ≤ n ≤ 1000，第一天每个商店的菜价为不超过10000的正整数。

题解

读入数据，处理数据，输出数据，读入数组放a[N]，输出放b[N],首尾2个数取平均，中间三个数取平均

    #include<iostream>
    #include<algorithm>
    
    using namespace std;
    
    const int N = 1010;
    int a[N],b[N];
    int main(){
        int n;
        cin>>n;
        for(int i=0;i<n;i++) cin>>a[i];
        b[0]=(a[0]+a[1])/2;
        b[n-1]=(a[n-1]+a[n-2])/2;//首尾2个数取平均
        for(int i=1;i<n-1;i++) b[i]=(a[i]+a[i-1]+a[i+1])/3;//中间三个数取平均
        for(int i=0;i<n;i++) cout<<b[i]<<' ';
        return 0;
    }



2018-12-1

题目

试题编号：	201812-1
试题名称：	小明上学
时间限制：	1.0s
内存限制：	512.0MB
问题描述：	
题目背景
　　小明是汉东省政法大学附属中学的一名学生，他每天都要骑自行车往返于家和学校。为了能尽可能充足地睡眠，他希望能够预计自己上学所需要的时间。他上学需要经过数段道路，相邻两段道路之间设有至多一盏红绿灯。
　　京州市的红绿灯是这样工作的：每盏红绿灯有红、黄、绿三盏灯和一个能够显示倒计时的显示牌。假设红绿灯被设定为红灯 r 秒，黄灯 y 秒，绿灯 g 秒，那么从 0 时刻起，[0,r) 秒内亮红灯，车辆不许通过；[r, r+g) 秒内亮绿灯，车辆允许通过；[r+g, r+g+y) 秒内亮黄灯，车辆不许通过，然后依次循环。倒计时的显示牌上显示的数字 l（l > 0）是指距离下一次信号灯变化的秒数。
问题描述
　　一次上学的路上，小明记录下了经过每段路的时间，和各个红绿灯在小明到达路口时的颜色和倒计时秒数。希望你帮忙计算此次小明上学所用的时间。
输入格式
　　输入的第一行包含空格分隔的三个正整数 r、y、g，表示红绿灯的设置。这三个数均不超过 106。
　　输入的第二行包含一个正整数 n（n ≤ 100），表示小明总共经过的道路段数和看到的红绿灯数目。
　　接下来的 n 行，每行包含空格分隔的两个整数 k、t。k=0 表示经过了一段道路，耗时 t 秒，此处 t 不超过 106；k=1、2、3 时，分别表示看到了一个红灯、黄灯、绿灯，且倒计时显示牌上显示的数字是 t，此处 t 分别不会超过 r、y、g。
输出格式
　　输出一个数字，表示此次小明上学所用的时间。
样例输入
30 3 30
8
0 10
1 5
0 11
2 2
0 6
0 3
3 10
0 3
样例输出
70
样例说明
　　小明先经过第一段道路，用时 10 秒，然后等待 5 秒的红灯，再经过第二段道路，用时 11 秒，然后等待 2 秒的黄灯和 30 秒的红灯，再经过第三段、第四段道路，分别用时6、3秒，然后通过绿灯，再经过最后一段道路，用时 3 秒。共计 10 + 5 + 11 + 2 + 30 + 6 + 3 + 3=70 秒。
评测用例规模与约定
　　测试点 1, 2 中不存在任何信号灯。
　　测试点 3, 4 中所有的信号灯在被观察时均为绿灯。
　　测试点 5, 6 中所有的信号灯在被观察时均为红灯。
　　测试点 7, 8 中所有的信号灯在被观察时均为黄灯。
　　测试点 9, 10 中将出现各种可能的情况。

题解

模拟题，按照题意读取数据，使用res存储需要时间，对于不同的红绿灯分别判断即可

    #include<iostream>
    #include<algorithm>
    
    using namespace std;
    int main(){
        int r,y,g;
        cin>>r>>y>>g;
        int n;
        cin>>n;
        int res=0;
        while(n--){
            int k,t;
            cin>>k>>t;
            if(k==0) res+=t;//直路，直接加行走时间
            if(k==1) res+=t;//红灯，加上红灯时间       
            if(k==2) res+=(t+r);//黄灯，加上黄灯剩余时间和一个红灯的时间        
            if(k==3) res+=0;//绿灯，不加，可以删去这句
        }
        cout<<res;
        return 0;
    }



2019-03-1

题目





题解

思路

对于一个输入序列求解这个序列的最大值，中位数，最小值

首先思考如何存储数据，对于这一序列我们可以使用vector或者数组来存储，对于vetor可以动态扩容，不需要考虑开辟空间大小，对于数组在定义时候需要考虑开辟空间大小，观察输入数据范围为10^5级别，开辟一个100010大小的数组，对于函数题内部的变量会声明为局部变量，受到系统栈大小的限制函数内开辟大数组会爆栈，因此选择函数内开数组，定义为全局变量，放在堆空间上，受计算机内存大小的限制，对于数据输入规模防止看错，我们将其声明为一个常量N，修改起来更加方便。在读入数组时候，我们选择从a[1]-a[n]的存放，处理起来更加直观。

对于一个算法题代码主题框架基本上都是，读入数据，处理数据，输出结果，读入输出数据较为容易，我们主要解决处理数据的问题。

对于题目的要求，是有序的，要么升序，要么降序，他的最值只可能出现在数组的开头与结尾，二者中更大的便是最大值，反之则是最小值。

本题目的难点部分就在于中位数的处理，由于中位数当为奇数个个数时候就是最中间的元素，偶数时候就是最中间两个元素的平均数，当取平均时候需要输出四舍五入后的浮点数。需要通过判断语句来判断中位数应该如何计算。

    #include<iostream>
    #include<algorithm>
    using namespace std;
    
    const int N = 100010;//数据规模
    int a[N];
    int main(){
        int n;
        cin>>n;
        for(int i=1;i<=n;i++) cin>>a[i];
        int m,M, mid;//最小，最大，中位数
        bool tag = true;//是整数与否
        m = min(a[1],a[n]);
        M = max(a[1],a[n]);//二者较大是最大，较小是最小
        if(n%2==1) mid = a[(n+1)/2];//个数奇数，直接取中间
        else
        {//个数偶数，取中间两个的平均数
            if((a[n/2]+a[n/2+1])%2!=0) tag = false;//平均数不能整除
            mid = (a[n/2]+a[n/2+1])/2;
            
        }
        if(tag)//可以整除
        printf("%d %d %d",M,mid,m);
        else//不能整除
        printf("%d %d.5 %d",M,mid,m);
        return 0;
    }

第二题

第三题

第四题

第五题


