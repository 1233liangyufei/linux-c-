# 第2章：直接连接

> 不要想太遥远的事情。一次只能处理命运链中的一个链接。*-温斯顿·丘吉尔*

## 问题：连接到网络

在第1章中，我们看到网络由互连节点的链路组成。我们面临的一个基本问题是如何将两个节点连接在一起。我们还引入了“云”抽象来表示网络，而不会泄露其所有内部复杂性。因此，我们还需要解决将主机连接到云的类似问题。实际上，这是每个互联网服务提供商（ISP）在想要将新客户连接到其网络时所面临的问题。

无论我们是想用一个链路构建一个简单的双节点网络，还是将第十亿个主机连接到像Internet这样的现有网络，我们都需要解决一系列常见问题。首先，我们需要一些物理介质来进行连接。介质可以是一段导线，一段光纤，或一些不太有形的介质（例如空气），电磁辐射（例如，无线电波）可以通过该介质传输。它可以覆盖小区域（例如，办公楼）或广泛区域（例如，横贯大陆）。

但是，使用合适的介质连接两个节点只是第一步。在节点成功交换数据包之前必须解决另外五个问题，一旦解决，我们将提供*第2层*（L2）连接（使用OSI架构中的术语）。

第一种是*将*比特*编码*到传输介质上，以便接收节点可以理解它们。其次是将通过链路传输的比特序列描述为可以传递到端节点的完整消息的问题。这是*成帧* 问题，传递给终端主机的消息通常称为 *帧*（或有时是*数据包*）。第三，由于帧在传输过程中有时会被破坏，因此有必要检测这些错误并采取适当的措施; 这是*错误检测*问题。第四个问题是，尽管链接不时会破坏帧，但它仍然可靠。最后，在链接由多个主机共享的情况下 - 例如无线链路通常就是这种情况 - 有必要调解对此链接的访问。这是*媒体访问控制*问题。

- 比特编码，如何表示信息
- 如何组祯，数据包
- 祯出错了，如何检测
- 如何保证传输可靠
- 在多路访问时候如何解决多机共享问题

编码，成祯，错误检测，可靠传输，访问控制

尽管可以抽象地讨论这五个问题 - 编码，成帧，错误检测，可靠传递和访问中介 - 但它们是非常真实的问题，这些问题通过不同的网络技术以不同的方式解决。本章在特定网络技术的背景下考虑这些问题：点对点光纤链路（SONET是流行的例子）; 载波侦听多路访问（CSMA）网络（其中以太网是最着名的例子）; 无线网络（802.11是最普遍的标准）; 光纤到户（PON是主要标准）; 和移动无线（4G正在迅速变成5G）。

本章的目标是同时调查可用的链接级技术并探索这五个基本问题。我们将研究如何使各种不同的物理媒体和链接技术成为构建健壮，可扩展的网络的构建块。

# 2.1技术前景

在深入讨论本章开头问题陈述中提出的挑战之前，首先获得一个例子是有帮助的，其中包括各种各样的链接技术。这部分是由于用户尝试连接其设备的不同情况。

在频谱的一端，构建全球网络的网络运营商必须处理连接路由器的数百或数千公里的链路。另一方面，典型用户遇到的链接主要是将计算机连接到现有Internet的方式。有时此链接将是咖啡店中的无线（Wi-Fi）链接; 有时它是办公楼或大学的以太网链路; 有时它是连接到蜂窝网络的智能手机; 对于越来越大的人口，它是由ISP提供的光纤链路; 和许多其他人使用某种铜线或电缆连接。幸运的是，在这些看似不同的链接类型上使用了许多常用策略，因此它们都对协议栈中的更高层有用。

![img](https://book.systemsapproach.org/direct/figures/f02-01-9780123850591.png)最终用户对互联网的看法。

[图1](https://book.systemsapproach.org/direct/perspective.html#isp-access)展示了当今互联网中可能存在的各种类型的链接。在左侧，我们看到各种终端用户设备，从智能手机到平板电脑，再到通过各种方式连接到ISP的成熟计算机。虽然这些链接可能使用不同的技术，但在这张图片中它们看起来都是一样的 - 连接设备和路由器的直线。在ISP内部存在将路由器连接在一起的链路，以及将ISP连接到“Internet的其余部分”的链路，其中包括许多其他ISP以及它们连接的主机。

这些链接看起来都很相似，不仅因为我们不是很好的艺术家，而且因为网络架构的一部分作用是提供一个复杂多样的链接的共同抽象。这个想法是你的笔记本电脑或智能手机不必关心它连接的是什么类型的链接 - 唯一重要的是它有一个到互联网的链接。类似地，路由器不必关心什么类型的链路将其连接到其他路由器 - 它可以在链路上发送数据包，并且非常期望数据包将到达链路的另一端。

我们如何使所有这些不同类型的链接看起来与最终用户和路由器完全相同？从本质上讲，我们必须处理现实世界中存在的链接的所有物理限制和缺点。我们在本章的开头问题陈述中概述了其中的一些问题，但在我们讨论这些问题之前，我们首先需要介绍一些简单的物理。所有这些链接都是由一些可以传播信号的物理材料组成的，例如无线电波或其他种类的电磁辐射，但我们真正想做的是发送*比特*。在本章的后面部分中，我们将介绍如何编码位以在物理介质上传输，然后是上面提到的其他问题。到本章结束时，无论涉及哪种物理介质，我们都将了解如何通过几乎任何类型的链接发送完整的数据包。

那么，表征链路的一种方法是通过它们使用的介质 - 通常是某种形式的铜线，例如双绞线（电话）和同轴（电缆）; 光纤，用于光纤到户和互联网骨干中的许多长距离链路; 或用于无线链接的空间。

另一个重要的特性链路是*频率*，单位为赫兹，利用该电磁波振荡。通常以米为单位测量的一对相邻最大值或最小值之间的距离称为波的*波长*。由于所有电磁波都以光速（其依赖于介质）传播，因此该速度除以波的频率等于其波长。我们已经看到了一个语音级电话线的例子，它带有300赫兹到3300赫兹之间的连续电磁信号; 

通常，电磁波跨越更宽的频率范围，范围从无线电波到红外光，到可见光，到x射线和伽马射线。[图2](https://book.systemsapproach.org/direct/perspective.html#spectrum)描绘了电磁频谱并显示了哪些媒体通常用于携带哪些频带。

![img](https://book.systemsapproach.org/direct/figures/f02-02-9780123850591.png)电磁频谱。

到目前为止，我们理解了一种链接，它是一种以电磁波形式传输信号的物理媒介。这些链接为传输各种信息提供了基础，包括我们感兴趣的传输二进制数据（1和0）的数据类型。我们说二进制数据是在信号中*编码*的。将二进制数据编码到电磁信号上的问题是一个复杂的主题。为了使主题更易于管理，我们可以将其视为分为两层。下层涉及*调制* - 改变信号的频率，幅度或相位以实现信息的传输。调制的一个简单例子是改变单个波长的功率（幅度）。直观地说，这相当于打开和关闭灯。由于调制问题是我们讨论链路作为计算机网络构建模块的次要问题，我们简单地假设可以传输一对可区分的信号 - 将它们视为“高”信号和“低”信号 - 我们只考虑上层，它涉及将二进制数据编码到这两个信号上的更简单的问题。下一节将讨论此类编码。

对链接进行分类的另一种方法是使用它们的方式。各种经济和部署问题往往会影响找到不同链接类型的位置。大多数消费者通过无线网络（他们在咖啡店，机场，大学等中遇到）或通过ISP提供的所谓的*最后一英里*链接（或者替代地，*接入网络*）与互联网进行交互，[如图所示1](https://book.systemsapproach.org/direct/perspective.html#isp-access)。[表1](https://book.systemsapproach.org/direct/perspective.html#home)总结了这些链接类型。通常选择它们是因为它们是达到数百万消费者的经济有效的方式。例如，DSL（数字用户线）是一种较旧的技术，部署在现有的双绞线铜线上，已经存在普通的老式电话服务; G.Fast是一种通常用于多住宅公寓楼的铜基技术，而PON（无源光网络）是一种新技术，通常用于通过最近部署的光纤连接家庭和企业。



最后一英里连接到您家的公共服务。

|     服务     |     带宽     |
| :----------: | :----------: |
|  DSL（铜）   | 高达100 Mbps |
| G.Fast（铜） |  高达1 Gbps  |
| PON（光学）  | 高达10 Gbps  |

当然，还有*移动*或*蜂窝*网络（也称为4G，但正在迅速发展为5G），将我们的移动设备连接到互联网。这项技术还可以作为我们家庭或办公室的唯一互联网连接，但附带的好处是允许我们在从一个地方移动到另一个地方时保持互联网连接。

这些示例技术是与家庭或企业建立最后一英里连接的常用选项，但它们不足以从头开始构建完整的网络。要做到这一点，您还需要一些长途*骨干* 链接来互连城市。现代骨干链路现在几乎都是光纤，它们通常使用称为SONET（同步光纤网络）的技术，该技术最初是为满足电话运营商苛刻的管理要求而开发的。

最后，除了最后一英里，骨干网和移动联系，有你一个建筑物或发现里面的链接校园通常被称为*局域网*（LAN）的。以太网及其无线Wi-Fi是这一领域的主导技术。

# 2.2编码

将节点和链接转换为可用构建块的第一步是理解如何以可以从一个节点传输到另一个节点的方式连接它们。如前一节所述，信号通过物理链路传播。因此，任务是将源节点想要发送的二进制数据编码成链路能够携带的信号，然后将信号解码回接收节点处的相应二进制数据。我们忽略了调制的细节，并假设我们正在使用两个离散信号：高和低。实际上，这些信号可能对应于铜缆链路上的两个不同电压或光链路上的两个不同功率电平。

编码-解码

本章中讨论的大多数功能都是由*网络适配器*执行的 - 一个 将节点连接到链路的硬件。网络适配器包含信令组件，该信令组件实际上将比特编码为发送节点处的信号，并将信号解码为接收节点处的比特。因此， [如图1所示](https://book.systemsapproach.org/direct/encoding.html#node-link-1)，信号在两个信令组件之间的链路上传播，并且比特在网络适配器之间流动。

![img](https://book.systemsapproach.org/direct/figures/f02-03-9780123850591.png)信号在信号组件之间传播; 适配器之间的比特流。

让我们回到将位编码到信号上的问题。显而易见的事情是将数据值1映射到高信号，将数据值0映射到低信号。这正是被称为密码足够的*非归零*（NRZ）的编码方案所使用的映射。例如，[图2](https://book.systemsapproach.org/direct/encoding.html#nrz)示意性地描绘了NRZ编码的信号（底部），其对应于特定比特序列（顶部）的传输。

![img](https://book.systemsapproach.org/direct/figures/f02-04-9780123850591.png)NRZ编码比特流。

NRZ的问题在于连续几个1的序列意味着信号在链路上保持较长时间一段时间; 类似地，几个连续的0表示信号长时间保持低电平。由长串1或0引起的两个基本问题。首先是它导致了一种称为*基线漂移的情况*。具体地说，接收器保持它到目前为止所看到的信号的平均值，然后使用该平均值来区分低信号和高信号。只要信号明显低于此平均值，接收器就会得出它刚刚看到的0; 同样，显着高于平均值的信号被解释为1.当然，问题是太多的连续1或0导致该平均值发生变化，使得检测信号的显着变化更加困难。

问题

- 基线漂移，1 0 无法区分
- 时钟漂移，信号需要时钟同部，时钟同部也占据一半的带宽

第二个问题是需要从高到低的频繁转换， *反之亦然*，以便能够实现*时钟恢复*。直观地说，时钟恢复问题是编码和解码过程都由时钟驱动 - 每个时钟周期发送器发送一位，接收器恢复一点。发送方和接收方的时钟必须精确同步，以便接收方恢复发送方发送的相同位。如果接收器的时钟甚至比发送器的时钟略快或慢，则它不能正确解码信号。您可以想象通过单独的线路将时钟发送到接收器，但这通常可以避免，因为它会使布线成本增加两倍。因此，接收器从接收信号中获取时钟 - 时钟恢复过程。每当信号发生变化时，例如从1到0或从0到1的转换，然后接收器知道它处于时钟周期边界，并且它可以自己重新同步。但是，如果没有这种转换，很长一段时间会导致时钟漂移。因此，时钟恢复取决于信号中的大量转换，无论发送什么数据。

解决这个问题的一种方法，称为*非归零反转*（NRZI），发送器从当前信号转换为编码1并保持当前信号编码为0.这解决了连续1的问题，但显然对连续0没有任何作用。NRZI [如图3所示](https://book.systemsapproach.org/direct/encoding.html#encode-all)。另一种称为*曼彻斯特编码的方法*是通过发送NRZ编码数据和时钟的异或来更明确地将时钟与信号合并。（将本地时钟视为从低到高交替的内部信号;低/高对被认为是一个时钟周期。）曼彻斯特编码也[如图3](https://book.systemsapproach.org/direct/encoding.html#encode-all)所示。。观察到曼彻斯特编码导致0被编码为从低到高的转变，1被编码为从高到低的转变。因为0和1都导致向信号的转换，所以可以在接收器处有效地恢复时钟。（还有曼彻斯特编码的变体，称为*差分曼彻斯特*，其中1编码，信号的前半部分等于前一比特信号的后半部分，0用信号的前半部分编码与前一位信号的后半部分相反。）

![img](https://book.systemsapproach.org/direct/figures/f02-05-9780123850591.png)不同的编码策略。

曼彻斯特编码方案的问题在于它使链路上的信号转换速率加倍，这意味着接收器有一半的时间来检测信号的每个脉冲。信号变化的*速率*称为链路的*波特率*。在曼彻斯特编码的情况下，比特率是波特率的一半，因此编码被认为仅有50％的效率。请记住，如果接收器能够跟上[图3中](https://book.systemsapproach.org/direct/encoding.html#encode-all)曼彻斯特编码所需的更快波特率，那么NRZ和NRZI都可以在同一时间段内传输两倍的比特。

> 曼彻斯特编码表明，比特率不一定小于或等于波特率。如果调制方案能够利用（并识别）四个不同的信号，而不是仅仅两个例如“高”和“低” - 那么可以将两个比特编码到每个时钟间隔中，从而产生比特率这是波特率的两倍。类似地，能够在八个不同信号之间进行调制意味着能够在每个时钟间隔发送三个比特。

我们考虑的最终编码，称为*4B / 5B*，试图解决曼彻斯特编码的低效率，而不会遇到延长高或低信号持续时间的问题。4B / 5B的想法是在比特流中插入额外的比特，以便分解0或1的长序列。具体地，每4位实际数据以5位代码编码，然后发送到接收器; 因此，名称4B / 5B。选择5位代码，使得每个代码具有不超过一个前导0和不超过两个尾随0。因此，当背靠背发送时，没有一对5位代码导致发送多于三个连续的0。然后使用NRZI编码发送所得到的5位代码，这解释了为什么代码仅关注连续的0s-NRZI已经解决了连续1的问题。



4B / 5B编码。

| 4位数据符号 | 5位代码 |
| :---------: | :-----: |
|    0000     |  11110  |
|    0001     |  01001  |
|    0010     |  10100  |
|    0011     |  10101  |
|    0100     |  01010  |
|    0101     |  01011  |
|    0110     |  01110  |
|    0111     |  01111  |
|    1000     |  10010  |
|    1001     |  10011  |
|    1010     |  10110  |
|    1011     |  10111  |
|    1100     |  11010  |
|    1101     |  11011  |
|    1110     |  11100  |
|    1111     |  11101  |

[表1](https://book.systemsapproach.org/direct/encoding.html#4b5b)给出了对应于16个可能的4位数据符号中的每一个的5位代码。请注意，由于5位足以编码32个不同的代码，并且我们仅使用其中的16个用于数据，因此我们可以将16个代码用于其他目的。其中，代码`11111`在行空闲时使用，代码 `00000`对应于行何时死亡，并被`00100`解释为意味着停止。在剩余的13个代码中，其中7个无效，因为它们违反了“一个前导0，两个尾随0”规则，而另外6个代表各种控制符号。本章后面介绍的一些成帧协议使用这些控制符号。

# 2.3成帧

现在我们已经看到如何通过点对点链路传输一系列位 - 从适配器到适配器 - 让我们考虑[图1中](https://book.systemsapproach.org/direct/framing.html#host-link)的场景。回忆第1章我们关注的是分组交换网络，这意味着数据块（称为*帧）*在这个级别），不是比特流，在节点之间交换。网络适配器使节点能够交换帧。当节点A希望将帧发送到节点B时，它告诉其适配器从节点的存储器发送帧。这导致通过链路发送一系列比特。然后，节点B上的适配器将到达链路的比特序列收集在一起，并将相应的帧存放在B的存储器中。准确地识别什么位组成一个帧 - 即确定帧开始和结束的位置 - 是适配器面临的主要挑战。



![img](https://book.systemsapproach.org/direct/figures/f02-06-9780123850591.png)适配器之间的流，主机之间的帧。

帧定界

有几种方法可以解决框架问题。本节使用三种不同的协议来说明设计空间中的各个点。请注意，虽然我们在点对点链路的上下文中讨论了帧，但问题是一个必须在以太网和Wi-Fi等多址网络中解决的基本问题。

## 面向字节的协议（PPP）

最古老的成帧方法之一 - 它的根源是将终端连接到大型机 - 是将每个帧视为字节（字符）的集合而不是位集合。这种*面向字节的*协议的早期例子是 IBM在20世纪60年代末开发的二进制同步通信（BISYNC）协议，以及数字设备公司的DECNET中使用的数字数据通信消息协议（DDCMP）。（曾几何时，IBM和DEC等大型计算机公司也为其客户建立了专用网络。）广泛使用的点对点协议（PPP）是这种方法的最新例子。

在较高的层次上，有两种面向字节的框架方法。第一种是使用称为*哨兵角色的*特殊*字符* 指示帧的开始和结束位置。这个想法是通过发送一个特殊的SYN（同步）字符来表示帧的开始。然后，帧的数据部分有时包含在两个更特殊的字符之间：STX（文本开头）和ETX（文本结尾）。BISYNC使用了这种方法。当然，哨兵方法的问题在于其中一个特殊字符可能出现在帧的数据部分中。克服这个问题的标准方法是通过在角色出现在帧体内时将DLE（数据链接转义）字符置于其前面来“转义”该字符; DLE字符也在帧体中被转义（通过在其前面加上额外的DLE）。（C程序员可能会注意到，这类似于在字符串中出现引号时反斜杠转义的方式。*字符填充*因为在帧的数据部分中插入了额外的字符。

检测具有标记值的帧结束的替代方案是在帧头中包括帧开始处的帧中的字节数。DDCMP使用了这种方法。这种方法的一个危险是传输错误可能破坏计数字段，在这种情况下，将无法正确检测帧的结尾。（如果ETX字段被破坏，基于标记的方法也存在类似的问题。）如果发生这种情况，接收器将累积与坏计数字段指示的字节数一样多的字节，然后使用错误检测字段来确定帧是坏的。这有时被称为*帧错误*。接收器将等待，直到它看到下一个SYN字符开始收集构成下一帧的字节。因此，帧错误可能导致错误地接收背对背帧。

点对点协议（PPP）通常用于通过各种点对点链路承载因特网协议分组，它使用标记和字符填充。PPP帧的格式[如图2所示](https://book.systemsapproach.org/direct/framing.html#ppp)。

![img](https://book.systemsapproach.org/direct/figures/f02-08-9780123850591.png)PPP帧格式。

这个数字是本书中您将看到的用于说明帧或数据包格式的众多数据中的第一个，因此需要进行一些解释。我们将数据包显示为标记字段序列。每个字段上方是一个数字，表示该字段的长度（以位为单位）。注意，从最左边的字段开始发送分组。

特殊的文本开头字符，表示为`Flag`字段`01111110`。该`Address`和`Control`字段通常包含默认值，因此是无趣的。（协议）字段用于解复用; 它标识高级协议，例如IP。可以协商帧有效负载大小，但默认情况下为1500字节。该`Checksum`字段为2（默认情况下）或4字节长。

PPP帧格式是不寻常的，因为几个字段大小是协商而不是固定的。该协商由称为链路控制协议（LCP）的协议进行。PPP和LCP协同工作：LCP发送封装在PPP帧中的控制消息 - 这些消息由PPP（协议）字段中的LCP标识符表示 - 然后根据这些控制消息中包含的信息转换并更改PPP的帧格式。当双方都检测到链路上的通信是可能的时（例如，当每个光接收器检测到来自其连接的光纤的输入信号时），LCP还参与在两个对等体之间建立链路。

## 面向比特的协议（HDLC）

与面向字节的协议不同，面向位的协议不涉及字节边界 - 它只是将帧视为一组位。这些位可能来自某些字符集，例如ASCII; 它们可能是图像中的像素值; 或者它们可以是来自可执行文件的指令和操作数。IBM开发的同步数据链路控制（SDLC）协议是面向比特的协议的一个例子。SDLC后来被ISO标准化为高级数据链路控制（HDLC）协议。在下面的讨论中，我们使用HDLC作为例子; 其帧格式 [如图3所示](https://book.systemsapproach.org/direct/framing.html#hdlc)。

HDLC表示具有区分比特序列的帧的开始和结束`01111110`。在链路空闲的任何时间也发送该序列，以便发送器和接收器可以保持它们的时钟同步。这样，两种协议都基本上使用了哨兵方法。因为这个序列可能出现在帧的主体中 - 实际上，这些位`01111110` 可能跨越字节边界 - 面向位的协议使用DLE字符的模拟，这种技术称为*位填充*。

![img](https://book.systemsapproach.org/direct/figures/f02-10-9780123850591.png)HDLC帧格式。

HDLC协议中的比特填充如下。在发送方，任何时候从消息正文发送了五个连续的1（即，当发送方试图发送区分`01111110`序列时排除），发送方在发送下一位之前插入0。在接收方，如果连续五个1到达，则接收机根据它看到的下一个比特（即五个1之后的比特）作出决定。如果下一位为0，则必须填充，因此接收器将其删除。如果下一位是1，则两件事之一成立：这是帧结束标记或者已经在位流中引入了错误。通过看下*一个*位，接收器可以区分这两种情况。如果它看到0（即它看到的最后8位 `01111110`），则它是帧结束标记; 如果它看到1（即它看到的最后8位`01111111`），则必定存在错误并丢弃整个帧。在后一种情况下，接收器必须等待下一个`01111110`才能再次开始接收，结果，接收器可能无法接收两个连续的帧。显然，仍然存在未检测到帧错误的方法，例如当错误生成整个虚假帧结束模式时，但这些失败相对不太可能。在后面的部分中将讨论检测错误的强大方法。

比特填充以及字符填充的一个有趣特征是帧的大小取决于在帧的有效载荷中发送的数据。实际上不可能使所有帧的大小完全相同，因为可能在任何帧中携带的数据是任意的。（为了说服自己，考虑如果帧的主体的最后一个字节是ETX字符会发生什么。）下一小节中描述了一种确保所有帧大小相同的框架形式。

## 基于时钟的成帧（SONET）

第三种成帧方法以同步光纤网络（SONET）标准为例。由于缺乏广泛接受的通用术语，我们将此方法简称为*基于时钟的框架*。SONET最初由Bell Communications Research（Bellcore）提出，然后在美国国家标准协会（ANSI）下开发，用于光纤数字传输; 它已被ITU-T采用。SONET多年来一直是光网络上数据长距离传输的主要标准。

在我们进一步讨论之前，关于SONET的重要一点是，完整的规范要比本书大得多。因此，以下讨论必然仅涵盖标准的要点。此外，SONET解决了帧问题和编码问题。它还解决了对电话公司非常重要的问题 - 将多个低速链路复用到一个高速链路上。（事实上，SONET的大部分设计反映了这样一个事实，即电话公司必须关注多路传输大量传统上用于电话呼叫的64-kbps频道。）我们从SONET的构建方法开始，讨论以下其他问题。 。

与前面讨论的成帧方案一样，SONET帧具有一些特殊信息，告诉接收器帧的开始和结束位置; 然而，这就是相似之处。值得注意的是，不使用位填充，因此帧的长度不依赖于正在发送的数据。所以要问的问题是“接收器如何知道每帧开始和结束的位置？” 我们将这个问题考虑为最低速的SONET链路，称为STS-1，运行速率为51.84 Mbps。STS-1帧[如图4](https://book.systemsapproach.org/direct/framing.html#sonet-frame)所示。它被安排为9行，每行90个字节，每行的前3个字节是开销，其余的可用于通过链路传输的数据。帧的前2个字节包含一个特殊的位模式，正是这些字节使接收器能够确定帧的起始位置。但是，由于没有使用比特填充，因此没有理由为什么这种模式偶尔不会出现在帧的有效载荷部分中。为了防止这种情况，接收器一致地寻找特殊位模式，希望看到它每810字节出现一次，因为每帧是9\倍× 90 = 810字节长。当特殊模式在正确的位置出现足够的时间时，接收器断定它是同步的，然后可以正确地解释帧。

![img](https://book.systemsapproach.org/direct/figures/f02-11-9780123850591.png)SONET STS-1帧。

由于SONET的复杂性，我们没有描述的一件事是详细使用所有其他开销字节。部分复杂性可归因于SONET跨越运营商的光网络，而不仅仅是单个链路。（回想一下，我们正在掩盖运营商实施网络的事实，而我们正在关注这样一个事实，即我们可以从它们租用SONET链路，然后使用此链路构建我们自己的分组交换网络。）额外的复杂性事实上，SONET提供了比数据传输更丰富的服务。例如，为用于维护的语音信道留出64kbps的SONET链路容量。

使用NRZ对SONET帧的开销字节进行编码，NRZ是前一节中描述的简单编码，其中1为高，0为低。但是，为了确保有足够的转换允许接收器恢复发送器的时钟，有效负载字节被 *加扰*。这是通过计算要传输的数据的异或（XOR）并使用众所周知的位模式来完成的。位模式（127位长）具有从1到0的大量转换，因此使用传输的数据对其进行异或运算可能会产生具有足够转换的信号以启用时钟恢复。

SONET支持以下列方式多路复用多个低速链路。给定的SONET链路以一组有限的可能速率运行，范围从51.84 Mbps（STS-1）到39,813,120 Mbps（STS-786）。请注意，所有这些速率都是STS-1的整数倍。成帧的重要性在于单个SONET帧可以包含用于多个较低速率信道的子帧。第二个相关特征是每个帧是125\亩*μ*悠久。这意味着在STS-1速率下，SONET帧长810字节，而在STS-3速率下，每个SONET帧长2430字节。注意这两个特征之间的协同作用：3\倍× 810 = 2430，意味着三个STS-1帧恰好适合单个STS-3帧。

> STS代表*同步传输信号*，这是SONET谈论帧的方式。有一个并行术语 - *光载波* （OC） - 用于讨论承载SONET帧的基础光信号。我们说这两个术语是并行的，因为STS-3和OC-3使用一个具体的例子，都意味着传输速率为155.52 Mbps。由于我们专注于此处的帧，我们将坚持使用STS，但您更有可能听到有人通过其“OC”名称来引用光学链接。

直观地，STS-N帧可以被认为是由N个STS-1帧组成，其中来自这些帧的字节是交织的; 也就是说，发送来自第一帧的字节，然后发送来自第二帧的字节，依此类推。交织来自每个STS-N帧的字节的原因是为了确保每个STS-1帧中的字节均匀地起搏; 也就是说，字节在接收器处以平滑的51 Mbps显示，而不是在一个特定的1 / N期间全部聚集^ {}第*吨**ħ*的125-的\亩*μ*秒间隔。

![img](https://book.systemsapproach.org/direct/figures/f02-12-9780123850591.png)三个STS-1帧复用到一个STS-3c帧上。

尽管将STS-N信号视为用于复用N个STS-1帧是准确的，但是来自这些STS-1帧的有效载荷可以链接在一起以形成更大的STS-N有效载荷; 这样的链接表示为STS-Nc（用于*连接*）。开销中的一个字段用于此目的。[图5](https://book.systemsapproach.org/direct/framing.html#sonet1)示意性地描绘了在将三个STS-1帧连接成单个STS-3c帧的情况下的级联。SONET链路被指定为STS-3c而不是STS-3的重要性在于，在前一种情况下，链路的用户可以将其视为单个155.25-Mbps管道，而真正应该查看STS-3作为三个共享光纤的51.84-Mbps链路。

![img](https://book.systemsapproach.org/direct/figures/f02-13-9780123850591.png)SONET帧异相。

最后，前面对SONET的描述过于简单，因为它假定每帧的有效载荷完全包含在帧内。（为什么不是？）实际上，我们应该将刚刚描述的STS-1帧视为帧的占位符，其中实际有效载荷可以跨帧边界*浮动*。这种情况[如图6所示](https://book.systemsapproach.org/direct/framing.html#sonet3)。在这里，我们看到STS-1有效载荷漂浮在两个STS-1帧上，并且有效载荷向右移动了一些字节，因此缠绕在一起。帧开销中的一个字段指向有效负载的开头。这种能力的价值在于它简化了同步运营商网络中使用的时钟的任务，这是运营商花费大量时间担心的事情。

内容[面向字节的协议（PPP）](https://book.systemsapproach.org/direct/framing.html#byte-oriented-protocols-ppp)[面向比特的协议（HDLC）](https://book.systemsapproach.org/direct/framing.html#bit-oriented-protocols-hdlc)[基于时钟的成帧（SONET）](https://book.systemsapproach.org/direct/framing.html#clock-based-framing-sonet)

# 2.4错误检测

如第1章所述，有时会将误码引入帧中。例如，由于电气干扰或热噪声，会发生这种情况。虽然错误很少见，特别是在光链路上，但需要一些机制来检测这些错误，以便采取纠正措施。否则，最终用户会想知道为什么刚刚成功编译的C程序现在突然出现语法错误，而在此期间发生的所有事情都是在网络文件系统中复制的。

处理计算机系统中的位错误的技术历史悠久，可追溯到至少20世纪40年代。汉明和里德 - 所罗门代码是两个值得注意的例子，它们被开发用于打卡器读卡器，将数据存储在磁盘上和早期核心存储器中。本节介绍网络中最常用的一些错误检测技术。

检测错误只是问题的一部分。另一部分是在检测到错误后纠正错误。当消息的接收者检测到错误时，可以采取两种基本方法。一种是通知发件人邮件已损坏，以便发件人可以重新传输邮件的副本。如果位错误很少，那么重传的副本很可能没有错误。或者，某些类型的错误检测算法允许接收者即使在它被破坏后也能重建正确的消息; 这些算法依赖于*纠错码*，如下所述。

用于检测传输错误的最常用技术之一是称为*循环冗余校验*（CRC）的技术。它几乎用于本章讨论的所有链路级协议。本节概述了基本的CRC算法，但在讨论该方法之前，我们首先描述了几种Internet协议使用的更简单的*校验和*方案。

任何错误检测方案背后的基本思想是将冗余信息添加到帧中，该帧可用于确定是否已引入错误。在极端情况下，我们可以想象传输两个完整的数据副本。如果两个副本在接收器上是相同的，则可能两者都是正确的。如果它们不同，则会在其中一个（或两个）中引入错误，并且必须将它们丢弃。由于两个原因，这是一种相当差的错误检测方案。首先，它发送ñ*n个*冗余位ñ*n*位消息。其次，许多错误将不会被检测到 - 任何错误都会破坏消息的第一个和第二个副本中的相同位位置。通常，错误检测代码的目标是提供检测错误的高概率以及相对较少数量的冗余位。

幸运的是，我们可以比这个简单的方案做得更好。通常，我们可以在发送时提供非常强大的错误检测功能ķ*k个*冗余位ñ*n*位消息，在哪里ķ*k*比小得多ñ*n*。例如，在以太网上，携带多达12,000位（1500字节）数据的帧仅需要32位CRC码，或者通常表达的CRC码使用CRC-32。这样的代码将捕获绝大多数错误，我们将在下面看到。

我们说我们发送的额外位是冗余的，因为它们不会向消息添加新信息。相反，它们是使用一些明确定义的算法直接从原始消息派生的。发送方和接收方都确切知道该算法是什么。发送方将算法应用于消息以生成冗余位。然后它传输消息和那些额外的位。当接收者对接收的消息应用相同的算法时，它应该（在没有错误的情况下）得到与发送者相同的结果。它将结果与发件人发送给它的结果进行比较。如果它们匹配，则可以推断（很可能）在传输期间消息中没有引入错误。如果它们不匹配，则可以确定消息或冗余位已损坏，

关于这些额外位的术语的一个注释。通常，它们被称为*错误检测代码*。在特定情况下，当创建代码的算法基于添加时，它们可以称为 *校验和*。我们将看到Internet校验和被恰当地命名：它是一个使用求和算法的错误检查。不幸的是，单词*校验和*通常不精确地用于表示任何形式的错误检测代码，包括CRC。这可能会造成混淆，因此我们建议您仅使用单词*校验和*来应用实际使用添加的代码，并使用*错误检测代码*来引用本节中描述的一般代码类。

## 互联网校验和算法

我们的第一种错误检测方法是校验和。虽然它没有在链路级使用，但它提供了与CRC相同的功能，因此我们在此进行讨论。

校验和背后的想法非常简单 - 您将所有传输的单词相加，然后传输该总和的结果。结果是校验和。接收器对接收的数据执行相同的计算，并将结果与接收的校验和进行比较。如果任何传输的数据（包括校验和本身）被破坏，则结果将不匹配，因此接收方知道发生了错误。

你可以想象校验和的基本思想有很多不同的变化。因特网协议使用的确切方案如下工作。将数据校验为16位整数序列。使用16位的补码算法（下面解释）将它们加在一起，然后取结果的补码。该16位数是校验和。

在1的补码算术中，负整数（-x）表示为x的补码; 也就是说，x的每个位都被反转。在1的补码运算中添加数字时，需要将最多位的进位添加到结果中。例如，考虑在4位整数上加上-5和-3的补码运算：+5是0101，所以-5是1010; +3是0011，所以-3是1100.如果我们加上1010和1100，忽略进位，我们得到0110.在补码运算中，这个运算从最高位引起进位的事实导致我们增加结果，给出0111，这是我们所期望的-8的补码表示（通过反转1000中的位获得）。

以下例程简单地实现了Internet的校验和算法。该`count`参数给出了`buf`以16位为单位测量的长度 。例程假设`buf`已经用0填充到16位边界。

```c
u_short 
cksum(u_short *buf, int count) 
{
    register u_long sum = 0;

    while (count--) 
    {
        sum += *buf++;
        if (sum & 0xFFFF0000) 
        {
            /* carry occurred, so wrap around */
            sum &= 0xFFFF;
            sum++;
        }
    }
    return ~(sum & 0xFFFF);
}
```

此代码确保计算使用的是补码算术而不是大多数机器中使用的二进制补码。注意 循环`if`内的语句`while`。如果有一个进位到前16位`sum`，那么我们`sum`就像前面的例子一样增加。

与我们的重复代码相比，该算法在使用少量冗余比特时得分很好 - 对于任何长度的消息只有16个 - 但是对于错误检测的强度它没有得分。例如，一对单比特错误，其中一个增加一个字，另一个减少相同数量的另一个字，将不会被检测到。使用这样的算法的原因尽管其相对较弱的错误保护（例如与CRC相比）很简单：该算法在软件中更容易实现。经验表明，这种形式的校验和是足够的，但其充分的一个原因是该校验和是端到端协议中的最后一道防线。大多数错误都是由链路级别的更强大的错误检测算法（如CRC）捕获的。

## 循环冗余校验

现在应该清楚的是，设计错误检测算法的主要目标是仅使用少量冗余位来最大化检测错误的概率。循环冗余校验使用一些相当强大的数学来实现这一目标。例如，32位CRC可以防止数千字节长的消息中的常见位错误。循环冗余校验的理论基础植根于一个称为*有限域*的数学分支。虽然这可能听起来令人生畏，但基本的想法可以很容易理解。

首先，将（n + 1）位消息视为由a表示 ñ*n次* 多项式，即最高阶项为的多项式 的x ^ {N}*X* *ñ*。通过使用消息中每个比特的值作为多项式中每个项的系数，该消息由多项式表示，从最高有效位开始表示最高位项。例如，由位10011010组成的8位消息对应于多项式

M（x）=（1 \乘x ^ 7）+（0 \乘x ^ 6）+（0 \乘x ^ 5）+（1 \乘x ^ 4）+（1 \乘x ^ 3）+ （0 \次x ^ 2）+（1 \次x ^ 1）+（0 \次x ^ 0）*中号*（*X* ）= （1 × *X* 7）+ （0 × *X* 6）+ （0 × *X* 5）+ （1 × *X* 4）+ （1 × *X* 3）+ （0 × *X* 2）+（1×*X*1）+（0×*X*0）

M（x）= x ^ 7 + x ^ 4 + x ^ 3 + x ^ 1*中号*（*X* ）= *X* 7 + *X* 4 + *X* 3 + *X* 1

因此，我们可以将发送者和接收者视为彼此交换多项式。

出于计算CRC的目的，发送方和接收方必须就*除数*多项式达成一致，C（x）的*C* （*x* ）。C（x）的*C* （*x* ）是度的多项式ķ*k*。例如，假设C（x）= x ^ 3 + x ^ 2 + 1*Ç* （*X* ）= *X* 3 + *X* 2 + 1。在这种情况下， K = 3*k* = 3。问题的答案“哪里做了C（x）的*C* （*x* ）来自？“在大多数实际案例中，”你在书中查找它。“事实上，选择 C（x）的*如下所述，C* （*x* ）对可以可靠地检测到哪种类型的错误具有显着影响。有一些除数多项式是各种环境的非常好的选择，并且通常作为协议设计的一部分进行确切选择。例如，以太网标准使用32级的众所周知的多项式。

当发件人希望传送邮件时 M（x）的*M* （*x* ）是n + 1位长，实际发送的是（n + 1）位消息加ķ*k*位。我们称完整的传输消息，包括冗余位， P（x）的*P* （*x* ）。我们要做的是设法使多项式代表P（x）的*P* （*x* ）完全可被整除C（x）的*C* （*x* ） ; 我们将在下面解释如何实现这一点。如果P（x）的*P* （*x* ）通过链路传输，并且在传输期间没有引入错误，然后接收器应该能够分割P（x）的*P* （*x* ） byC（x）的确切地说是*C*（*x*），剩下零。另一方面，如果引入了一些错误P（x）的在传输期间*P*（*x*），然后很可能接收的多项式将不再被完全整除C（x）的*C* （*x* ），因此接收器将获得非零余数，暗示已发生错误。

如果你对多项式算术有所了解，将有助于理解以下内容; 它与普通整数算术略有不同。我们在这里处理一类特殊的多项式算术，其中系数可以只有一个或零，并且使用模2算法对系数进行操作。这被称为“多项式算术模2”。由于这是一本网络书籍，而不是数学文本，因此我们将重点放在这类算术的关键属性上（我们要求您接受信仰）：

- 任何多项式 B（x）的*B* （*x* ）可以除以除数多项式C（x）的*C* （*x* ） 如果B（x）的*B* （*x* ）的程度高于C（x）的*C* （*x* ）。
- 任何多项式 B（x）的*B* （*x* ）可以用除数多项式除一次 C（x）的*C* （*x* ）如果B（x）的*B* （*x* ）的程度与C（x）的*C* （*x* ）。
- 剩余时间获得 B（x）的*B* （*x* ）除以C（x）的通过对每对匹配系数执行异或（XOR）运算来获得*C*（*x*）。

例如，多项式 x ^ 3 + 1*X* 3 + 1可以通过被划分x ^ 3 + x ^ 2 + 1*X* 3 + *X* 2 + 1 （因为它们都是等级3的），其余的将是 0 \次x ^ 3 + 1 \次x ^ 2 + 0 \次x ^ 1 + 0 \次x ^ 0 = x ^ 20 × *X* 3 + 1 × *X* 2 + 0 × *X* 1 + 0 × *X* 0 = *X* 2（通过异或每个术语的系数获得的）。就消息而言，我们可以说1001可以除以1101并留下0100的余数。您应该能够看到余数只是两条消息的按位异或。

现在我们知道了划分多项式的基本规则，我们可以进行长除法，这对于处理更长的消息是必要的。下面是一个例子。

回想一下，我们想要创建一个从原始消息派生的传输多项式 M（x）的*M* （*x* ），是ķ*k*位长于 M（x）的*M* （*x* ），并且可以被整除C（x）的*C* （*x* ）。我们可以通过以下方式执行此操作：

1. 乘 M（x）的*M* （*x* ） by的x ^ {K}*X* *ķ* ; 也就是说，添加ķ消息结尾处的*k为* 0。调用此零扩展消息T（x）的*T* （*x* ）。
2. 划分 T（x）的*T* （*x* ） byC（x）的*C* （*x* ）并找到余数。
3. 从中减去剩余部分 T（x）的*T* （*x* ）。

显而易见的是，此时剩下的是一条可被整除的消息 C（x）的*C* （*x* ）。我们可能还会注意到生成的消息包含M（x）的*M* （*x* ）后跟在步骤2中得到的余数，因为当我们减去余数时（可以不超过 ķ*k比*特长），我们只是把它与XORķ*k*零在步骤1中添加。这部分将通过示例变得更加清晰。

考虑一下这条消息 x ^ 7 + x ^ 4 + x ^ 3 + x ^ 1*X* 7 + *X* 4 + *X* 3 + *X* 1，或10011010.我们首先乘以X ^ 3*X* 3，因为我们的除数多项式程度3.这给10011010000.我们通过这种划分C（x）的*C* （*x* ），在这种情况下对应于1101。[图1](https://book.systemsapproach.org/direct/error.html#crcalc)显示了多项式长除法运算。给定上面描述的多项式算法的规则，长除法运算的进行与我们分割整数的情况相同。因此，在我们的例子的第一步中，我们看到除数1101将一次分成消息的前四位（1001），因为它们具有相同的度数，并留下100的余数（1101 XOR 1001）。下一步是从消息多项式中删除一个数字，直到我们得到另一个具有相同度数的多项式C（x）的*C* （*x* ），在这种情况下为1001.我们再次计算余数（100）并继续直到计算完成。请注意，出现在计算顶部的长除法的“结果”实际上并不是很有意义 - 最后的剩余部分很重要。

你可以从[图1的](https://book.systemsapproach.org/direct/error.html#crcalc)最底部看到示例计算的其余部分是101.所以我们知道10011010000减去101将被完全整除C（x）的*C* （*x* ），这就是我们发送的内容。多项式算术中的减运算是逻辑XOR运算，因此我们实际发送10011010101.如上所述，这结果只是原始消息，其中附加了长除法计算的余数。收件人将收到的多项式除以C（x）的*C* （*x* ）和，如果结果为0，则断定没有错误。如果结果非零，则可能需要丢弃损坏的消息; 对于一些代码，可以*纠正*小错误（例如，如果错误仅影响一位）。能够*纠错的代码*称为*纠错码*（ECC）。

![img](https://book.systemsapproach.org/direct/figures/f02-15-9780123850591.png)使用多项式长除法进行CRC计算。

现在我们将考虑多项式在哪里的问题 C（x）的*C* （*x* ）来自。直观地，我们的想法是选择这个多项式，这样它就不太可能均匀地划分成一个引入错误的消息。如果传输的消息是P（x）的*P* （*x* ），我们可能会将错误的引入视为另一个多项式的加法E（X）*E* （*x* ），所以收件人看到了P（x）+ E（x）*P* （*x* ）+ *E* （*x* ）。错误可能被未检测到的唯一方法是，如果收到的消息可以被均匀地除以C（x）的*C* （*x* ），因为我们知道P（x）的*P* （*x* ）可以均匀地除以 C（x）的*C* （*x* ），这只有在发生时才会发生E（X）*E* （*x* ）可以均匀分配 C（x）的*C* （*x* ）。诀窍是挑选C（x）的*C* （*x* ）因此对于常见类型的错误来说这是不太可能的。

一种常见的错误类型是单比特错误，可以表示为 E（x）= x ^ i*È* （*X* ）= *X* *我*当它影响比特位置一世*我*。如果我们选择C（x）的*C* （*x* ） 使得第一个和最后一个术语（即，的x ^ķ*X* *ķ*和的x ^ 0*X* 0 项）是非零的，那么我们已经有两任多项式不能均匀地划分为一个任期E（X）*E* （*x* ）。这样的C（x）的因此，*C*（*x*）可以检测所有单比特错误。通常，可以证明a可以检测到以下类型的错误C（x）的具有所述属性的*C*（*x*）：

- 所有单比特错误，只要 的x ^ {K}*X* *ķ*和的x ^ {0}*X* 0术语具有非零系数
- 所有双位错误，只要 C（x）的*C* （*x* ）具有至少三个项的因子
- 任何奇数个错误，只要 C（x）的*C* （*x* ）包含因子 （x + 1）（*x* + 1 ）

我们已经提到，可以使用不仅检测错误存在而且还能够纠正错误的代码。由于这些代码的细节需要比理解CRC所需的更复杂的数学，我们在此不再赘述。但是，值得考虑校正与检测的优点。

乍一看，似乎校正总是更好，因为通过检测，我们被迫丢弃消息，并且通常要求传输另一个副本。这会占用带宽，并且可能在等待重传时引入延迟。但是，校正有一个缺点，因为它通常需要更多的冗余位来发送纠错码，该纠错码与仅检测到的代码一样强（即能够处理相同的错误范围）错误。因此，虽然误差检测需要更多的比特发生错误时发送，纠错需要更多的比特来发送*所有的时间*。因此，当（1）错误非常可能时，纠错往往是最有用的，例如，在无线环境中，或者（2）重传的成本太高，例如，因为延迟涉及通过卫星链路重传数据包。

在网络中使用纠错码有时被称为*前向纠错*（FEC），因为错误的纠正是通过发送额外信息“提前”处理的，而不是等待错误发生并在以后通过重传来处理它们。 。FEC通常用于802.11等无线网络。

- 突发长度小于的任何“突发”错误（即连续错误位序列） ķ*k*位（大多数突发错误的长度大于ķ也可以检测到*k*位。）

六个版本 C（x）的*C* （*x* ）广泛用于链路级协议。例如，以太网使用CRC-32，其定义如下：

- CRC-32 = x ^ {32} + x ^ {26} + x ^ {23} + x ^ {22} + x ^ {16} + x ^ {12} + x ^ {11} + x ^ {10} + x ^ 8 + x ^ 7 + x ^ 5 + x ^ 4 + x ^ 2 + x + 1*X* 32 + *X* 26 + *X* 23 + *X* 22 + *X* 16 + *X* 12 + *X* 11 + *X* 10 + *X* 8+ *X* 7 + *X* 5 + *X* 4 + *X* 2 + *X* + 1

最后，我们注意到CRC算法虽然看似复杂，但很容易在硬件中使用 ķ*k*位移位寄存器和XOR门。移位寄存器中的位数等于生成多项式的次数（ķ*k*）。[图2](https://book.systemsapproach.org/direct/error.html#crc-hard)显示了将用于生成器的硬件x ^ 3 + x ^ 2 + 1*X* 3 + *X* 2 + 1从前面的例子。消息从左侧移入，从最高位开始，以字符串结束ķ附加到消息的*k个*零，就像在长除法示例中一样。当所有位都已移入并进行适当的异或后，寄存器包含余数 - 即CRC（右侧最高有效位）。XOR门的位置确定如下：如果移位寄存器中的位标记为0到k-1的*k* - 1，从左到右，然后在位前放置一个异或门ñ*ñ*如果有一个术语X ^ N*X* *Ñ*在生成多项式。因此，我们在发电机的位置0和2前面看到一个异或门x ^ 3 + x ^ 2 + x ^ 0*X* 3 + *X* 2 + *X* 0。

![img](https://book.systemsapproach.org/direct/figures/f02-16-9780123850591.png)使用移位寄存器的CRC计算。

# 2.5可靠的传输

正如我们在上一节中看到的那样，帧在传输过程中有时会被破坏，错误代码如CRC用于检测此类错误。虽然一些错误代码足够强以纠正错误，但实际上开销通常太大而无法处理可在网络链路上引入的位和突发错误的范围。即使使用纠错码（例如，在无线链路上），一些错误也将太严重而无法纠正。结果，必须丢弃一些损坏的帧。想要可靠地传送帧的链路级协议必须以某种方式从这些丢弃（丢失）的帧中恢复。

值得注意的是，可靠性是*可以*在链路级提供的功能，但许多现代链接技术省略了此功能。此外，经常在更高级别提供可靠的交付，包括运输和有时是应用层。应该提供的确切位置是一些争论的问题，取决于许多因素。我们在这里描述了可靠交付的基础知识，因为这些原则在各层之间很常见，但您应该知道我们不只是在讨论链路层功能。

可靠的交付通常使用两种基本机制 - *确认*和*超时*的组合来完成。确认（简称ACK）是一个小的控制帧，协议发回给它的对等体，说它已收到一个较早的帧。通过控制帧，我们指的是没有任何数据的报头，尽管协议可以在数据帧上*搭载* ACK，它恰好在相反的方向上发送。收到确认表明原始帧的发送方已成功传送其帧。如果发送方在合理的时间后没有收到确认，则它会 *重新发送*原始帧。这种等待合理时间的动作称为a*超时*。

使用确认和超时实现可靠传递的一般策略有时称为*自动重复请求* （缩写为ARQ）。本节描述了使用通用语言的三种不同的ARQ算法; 也就是说，我们不提供有关特定协议标头字段的详细信息。

## 停止并等待

最简单的ARQ方案是*停止等待*算法。停止等待的想法很简单：在发送一帧之后，发送方在发送下一帧之前等待确认。如果确认在一段时间后没有到达，则发送方超时并重新发送原始帧。

![img](https://book.systemsapproach.org/direct/figures/f02-17-9780123850591.png)时间轴显示停止等待算法的四种不同场景。（a）在计时器到期之前收到ACK; （b）原始帧丢失; （c）ACK丢失; （d）超时过早发射。

[图1](https://book.systemsapproach.org/direct/reliable.html#ack-timeout)显示了此基本算法产生的四种不同场景的时间线。发送侧表示在左侧，接收侧表示在右侧，时间从顶部到底部流动。[图1（a）](https://book.systemsapproach.org/direct/reliable.html#ack-timeout)显示了在定时器到期之前接收到ACK的情况; （b）和（c）分别表示原始帧和ACK丢失的情况; （d）显示超时过早发生的情况。回想一下，“丢失”是指帧在传输过程中被破坏，这种损坏是由接收器上的错误代码检测到的，随后帧被丢弃。

本节中显示的数据包时间线是教学，解释和设计协议中常用工具的示例。它们很有用，因为它们可视化地捕获分布式系统随时间的行为 - 这可能很难分析。在设计协议时，您经常需要为意外做好准备 - 系统崩溃，消息丢失，或者您希望快速发生的事情需要花费很长时间。这些类型的图表通常可以帮助我们了解在这种情况下可能出现的问题，从而帮助协议设计人员为每种可能性做好准备。

停止等待算法中有一个重要的微妙之处。假设发送方发送帧并且接收方确认它，但是确认在到达时丢失或延迟。这种情况在[图1的](https://book.systemsapproach.org/direct/reliable.html#ack-timeout)时间线（c）和（d）中说明 。在这两种情况下，发送方超时并重新发送原始帧，但接收方将认为它是下一帧，因为它正确接收并确认了第一帧。这有可能导致传递帧的重复副本。为了解决这个问题，停止和等待协议的标题通常包括1位序列号 - 也就是说，序列号可以取值0和1 - 并且用于每个帧的序列号交替，如在示出的 [图2中](https://book.systemsapproach.org/direct/reliable.html#stop-wait)。因此，当发送方重新发送帧0时，接收方可以确定它正在看到帧0的第二个副本而不是帧1的第一个副本，因此可以忽略它（如果第一个ACK丢失，接收方仍然会对其进行确认） ）。

![img](https://book.systemsapproach.org/direct/figures/f02-18-9780123850591.png)使用1位序列号进行停止等待的时间线。

停止等待算法的主要缺点是它允许发送者一次只在链路上有一个未完成的帧，这可能远低于链路的容量。例如，考虑具有45毫秒往返时间的1.5-Mbps链路。此链接有延迟\倍×带宽乘积为67.5 Kb，或约为8 KB。由于发送方每个RTT只能发送一个帧，并假设帧大小为1 KB，这意味着最大发送速率为

每帧位数/每帧时间= 1024 x 8 / 0.045 = 182 kbps

或约为链接容量的八分之一。为了完全使用链接，我们希望发送者能够在等待确认之前发送多达8个帧。



重点



延迟的意义 \倍×带宽产品是指它可以传输的数据量。我们希望能够在不等待第一次确认的情况下发送这么多数据。这里的工作原理通常被称为 *保持管道满*。以下两个小节中介绍的算法就是这样做的。

## 滑动窗口

再次考虑链接有延迟的情况 \倍× 8 KB的带宽积和帧大小为1 KB。我们希望发送者准备好在第一帧的ACK到达的同一时刻发送第九帧。允许我们执行此操作的算法称为*滑动窗口*，[图3中](https://book.systemsapproach.org/direct/reliable.html#slide-win)给出了说明性时间轴。

![img](https://book.systemsapproach.org/direct/figures/f02-19-9780123850591.png)滑动窗口算法的时间轴。

### 滑动窗口算法

滑动窗口算法的工作原理如下。首先，发送者分配一个*序列号*，来表示`SeqNum`，每一帧。现在，让我们忽略`SeqNum`由有限大小的头字段实现的事实，而不是假设它可以无限大地增长。发送方维护三个变量：表示的*发送窗口大小*`SWS`给出发送方可以发送的未完成（未确认）帧数的上限; `LAR` 表示*收到*的*最后一次确认*的序列号; 并 `LFS`表示*发送*的*最后一帧*的序列号。发件人还维护以下不变量：

```
LFS - LAR <= SWS
```

这种情况[如图4所示](https://book.systemsapproach.org/direct/reliable.html#sw-sender)。

![img](https://book.systemsapproach.org/direct/figures/f02-20-9780123850591.png)发送者的滑动窗口。

当确认到达时，发送方向`LAR`右移动，从而允许发送方发送另一帧。此外，发送方将定时器与其发送的每个帧相关联，并且如果定时器在接收到ACK之前到期，则它重新发送帧。请注意，发送方必须愿意缓冲`SWS` 帧，因为它必须准备好重新发送它们，直到它们被确认为止。

接收器保持以下三个变量：表示的*接收窗口大小*`RWS`给出接收器愿意接受的无序帧数的上限; `LAF`表示*最大可接受帧*的序列号; 并且`LFR`表示*接收*的*最后一帧*的序列号。接收器还保持以下不变量：

```
LAF - LFR <= RWS
```

这种情况[如图5所示](https://book.systemsapproach.org/direct/reliable.html#sw-rcvr)。

![img](https://book.systemsapproach.org/direct/figures/f02-21-9780123850591.png)接收器上的滑动窗口。

当具有序列号的帧`SeqNum`到达时，接收器采取以下动作。如果`SeqNum <= LFR`或 `SeqNum > LAF`，那么框架在接收器窗口之外并被丢弃。如果`LFR < SeqNum <= LAF`，则帧在接收者的窗口内并被接受。现在接收器需要决定是否发送ACK。设`SeqNumToAck`表示尚未确认的最大序列号，以便`SeqNumToAck`接收序列号小于或等于的所有帧。`SeqNumToAck`即使已收到更高编号的数据包，接收方也会确认收到。据说这种承认是累积的。然后设置`LFR = SeqNumToAck`和调整`LAF = LFR + RWS`。

例如，假设`LFR = 5`（即，接收者发送的最后一个ACK是序列号5），和`RWS = 4`。这意味着`LAF = 9`。如果第7帧和第8帧到达，它们将被缓冲，因为它们位于接收器的窗口内。但是，由于帧6尚未到达，因此不需要发送ACK。据说框架7和8已经无序到达。（从技术上讲，接收器可以在第7帧和第8帧到达时重新发送第5帧的ACK。）第6帧然后到达 - 可能是因为第一次丢失并且必须重新传输，或者可能只是延迟了 - 接收器确认帧8，碰到`LFR`8，并设置 `LAF`为12.如果帧6实际上丢失了，则发送器将发生超时，导致它重新发送帧6。

> 数据包不可能在点对点链路上延迟，同样的算法用于可能存在此类延迟的多跳连接。

我们观察到，当发生超时时，传输中的数据量会减少，因为发送方无法推进其窗口，直到确认第6帧为止。这意味着当发生数据包丢失时，此方案不再保持管道满。注意到丢包发生的时间越长，这个问题就越严重。

请注意，在此示例中，一旦第7帧到达，接收器可能已经为帧6 发送了*否定确认*（NAK）。但是，这是不必要的，因为发送方的超时机制足以捕获这种情况，并且发送NAK会给接收方增加额外的复杂性。另外，正如我们所提到的，当第7帧和第8帧到达时，发送第5帧的附加确认是合理的。在某些情况下，发件人可以使用重复的ACK作为丢失帧的线索。这两种方法都有助于通过允许早期检测数据包丢失来提高性能。

该方案的另一个变体是使用*选择性确认*。也就是说，接收器可以确切地确认它已经接收到的帧，而不仅仅是按顺序接收的最高编号帧。因此，在上面的示例中，接收方可以确认帧7和8的接收。向发送方提供更多信息使得发送方可能更容易保持管道满，但增加了实现的复杂性。

根据我们希望在给定时间在链接上有多少帧，选择发送窗口大小; `SWS`对于给定的延迟，很容易计算\倍×带宽产品。另一方面，接收器可以设置`RWS`为它想要的任何东西。两个常见的设置是`RWS = 1`，这意味着接收器不会缓冲任何无序到达的帧`RWS = SWS`，这意味着接收器可以缓冲发送器发送的任何帧。设置是没有意义的，`RWS > SWS` 因为不可能有多个`SWS`帧不按顺序到达。

### 有限序列数和滑动窗口

我们现在回到我们引入算法的一个简化 - 我们假设序列号可以无限大。当然，在实践中，帧的序列号在某个有限大小的头字段中指定。例如，3比特字段意味着有八个可能的序列号，0..7。这使得有必要重用序列号，或者换句话说，序列号环绕。这引入了能够区分相同序列号的不同化身的问题，这意味着可能的序列号的数量必须大于允许的未完成帧的数量。例如，stop-and-wait一次允许一个未完成的帧，并且具有两个不同的序列号。

假设我们的序列号空间中有一个数字比我们可能有优秀的帧数多一个; 也就是说，可用序列号的数量`SWS <= MaxSeqNum - 1`在哪里`MaxSeqNum`。这够了吗？答案取决于 `RWS`。如果`RWS = 1`，那就`MaxSeqNum >= SWS + 1`足够了。如果`RWS`等于`SWS`，那么`MaxSeqNum`只有一个大于发送窗口大小的不够好。为了看到这一点，考虑我们有八个序列号0到7的情况，和 `SWS = RWS = 7`。假设发送方发送帧0..6，它们被成功接收，但ACK丢失。接收器现在期望帧7,0..5，但发送器超时并发送帧0..6。不幸的是，接收器期望帧0..5的第二个化身，但获得这些帧的第一个化身。这正是我们想要避免的情况。

事实证明，发送窗口大小不能超过可用序列号的一半大`RWS = SWS`，或者更确切地说，

```
SWS < (MaxSeqNum + 1)/ 2
```

直观地说，这就是滑动窗口协议在序列号空间的两半之间交替，就像在序列号0和1之间的停止和等待交替一样。唯一的区别是它在两半之间连续滑动而不是在它们之间离散地交替。

请注意，此规则特定于其中的情况`RWS = SWS`。我们把它作为一个练习确定为任意值的工作更普遍的规则`RWS`和`SWS`。还要注意窗口大小和序列号空间之间的关系取决于一个很容易忽略的假设，即框架在传输过程中不重新排序。这不会发生在直接的点对点链路上，因为在传输过程中一帧无法超越另一帧。但是，我们将看到在不同环境中使用的滑动窗口算法，我们需要设计另一个规则。

### 滑动窗口的实现

以下例程说明了如何实现滑动窗口算法的发送和接收方。这些例程取自一个名为“滑动窗口协议（SWP）”的工作协议。为了不关心协议图中的相邻协议，我们将位于SWP之上的协议表示为高级协议（HLP），并将位于SWP之下的协议表示为链路级协议（LLP）。

我们首先定义一对数据结构。首先，帧头非常简单：它包含序列号（`SeqNum`）和确认号（`AckNum`）。它还包含一个`Flags` 字段，指示帧是ACK还是携带数据。

```c
typedef u_char SwpSeqno;

typedef struct {
    SwpSeqno   SeqNum;   /* sequence number of this frame */
    SwpSeqno   AckNum;   /* ack of received frame */
    u_char     Flags;           /* up to 8 bits worth of flags */
} SwpHdr;
```

接下来，滑动窗口算法的状态具有以下结构。用于协议的发送侧，此状态包括变量`LAR`和`LFS`，如在本节中，以及保持已传输但尚未确认（帧队列前面所述`sendQ`）。发送状态还包括一个名为的*计数信号量*`sendWindowNotFull`。我们将在下面看到如何使用它，但通常信号量是支持`semWait`和 `semSignal`操作的同步原语。每次调用`semSignal` 都会使信号量增加1，并且每次调用`semWait` 减量`s`如果调用进程被阻塞（暂停），则减少信号量会导致其值变为小于0. `semWait`一旦`semSignal`执行了足够的操作来提高值，就会允许在调用期间被阻塞的进程恢复信号量高于0。

对于协议的接收方，状态包括变量 `NFE`。这是*预期*的*下一帧*，该帧的序列号比最后一帧接收的帧数（LFR）多一个，如本节前面所述。还有一个队列来保存已经无序接收的帧（`recvQ`）。最后，尽管未示出，发送器和接收器滑动窗口大小分别由常数`SWS`和定义来定义`RWS`。

```c
typedef struct {
    /* sender side state: */
    SwpSeqno    LAR;        /* seqno of last ACK received */
    SwpSeqno    LFS;        /* last frame sent */
    Semaphore   sendWindowNotFull;
    SwpHdr      hdr;        /* pre-initialized header */
    struct sendQ_slot {
        Event   timeout;    /* event associated with send-timeout */
        Msg     msg;
    }   sendQ[SWS];

    /* receiver side state: */
    SwpSeqno    NFE;       /* seqno of next frame expected */
    struct recvQ_slot {
        int     received;  /* is msg valid? */
        Msg     msg;
    }   recvQ[RWS];
} SwpState;
```

SWP的发送方通过程序实现`sendSWP`。这个例程很简单。首先，`semWait`导致此过程阻塞信号量，直到可以发送另一个帧。一旦允许继续，`sendSWP`在帧的头部设置序列号，在发送队列（`sendQ`）中保存帧的副本，调度超时事件以处理帧未被确认的情况，并将帧发送到下一个- 低级协议，我们称之为`LINK`。

值得注意的一个细节是呼叫`store_swp_hdr`之前的呼叫`msgAddHdr`。此例程将保存SWP header（`state->hdr`）的C结构转换为可以安全地附加到message（`hbuf`）前面的字节字符串。此例程（未显示）必须将标头中的每个整数字段转换为网络字节顺序，并删除编译器已添加到C结构的任何填充。字节顺序的问题是一个非常重要的问题，但是现在足以假设该例程将多字整数的最高位置于具有最高地址的字节中。

这个例程的另一个复杂因素是使用 `semWait`和`sendWindowNotFull`信号量。 `sendWindowNotFull`初始化为发送方滑动窗口的大小`SWS`（此初始化未显示）。每次发送方发送帧时，`semWait`操作都会递减此计数，并在计数结果为0时阻止发送方。每次收到ACK时，`semSignal`调用的操作`deliverSWP`（见下文）会增加此计数，从而解除阻塞任何等待的发送方。

```c
static int 
sendSWP(SwpState *state, Msg *frame) 
{
    struct sendQ_slot *slot;
    hbuf[HLEN];

    /* wait for send window to open */
    semWait(&state->sendWindowNotFull);
    state->hdr.SeqNum = ++state->LFS;
    slot = &state->sendQ[state->hdr.SeqNum % SWS];
    store_swp_hdr(state->hdr, hbuf);
    msgAddHdr(frame, hbuf, HLEN);
    msgSaveCopy(&slot->msg, frame);
    slot->timeout = evSchedule(swpTimeout, slot, SWP_SEND_TIMEOUT);
    return send(LINK, frame);
}
```

在继续接收SWP的接收方面之前，我们需要调和看似不一致的问题。一方面，我们一直在说高级协议通过调用`send`操作来调用低级协议的服务，因此我们期望想要通过SWP发送消息的协议会调用`send(SWP, packet)`。另一方面，调用实现SWP发送操作的过程，`sendSWP`其第一个参数是状态变量（`SwpState`）。是什么赋予了？答案是操作系统提供粘合代码，将通用调用转换 `send`为特定于协议的调用`sendSWP`。这个粘合代码将第一个参数`send`（魔术协议变量`SWP`）映射到一个函数指针`sendSWP` 以及指向SWP完成其工作所需的协议状态的指针。我们让高级协议通过泛型函数调用间接调用特定于协议的函数的原因是我们想要限制高级协议在其中编码有关低级协议的信息量。这使得在将来的某个时间更改协议图配置变得更加容易。

现在我们继续讨论SWP特定于协议的`deliver`操作实现，该 过程在程序中给出 `deliverSWP`。此例程实际上处理两种不同类型的传入消息：先前从此节点发送的帧的ACK和到达此节点的数据帧。从某种意义上说，这个例程的ACK一半与给定的算法的发送方相对应`sendSWP`。通过检查`Flags`报头中的字段来确定传入消息是ACK还是数据帧。注意，该特定实现不支持在数据帧上搭载ACK。

当传入帧是ACK时，`deliverSWP`只需找到与`sendQ`ACK对应的传输队列（）中的槽，取消超时事件，并释放该槽中保存的帧。这项工作实际上是在循环中完成的，因为ACK可能是累积的。关于这种情况唯一需要注意的是调用子程序 `swpInWindow`。下面给出的该子例程确保被确认帧的序列号在发送者当前期望接收的ACK范围内。

当传入帧包含数据时，`deliverSWP`首先调用`msgStripHdr`并`load_swp_hdr`从帧中提取标题。常规`load_swp_hdr`是`store_swp_hdr`前面讨论过的对应物 ; 它将字节字符串转换为保存SWP标头的C数据结构。`deliverSWP` 然后调用`swpInWindow`以确保帧的序列号在它期望的序列号范围内。如果是，则例程循环接收它所接收的一组连续帧，并通过调用`deliverHLP`例程将它们传递给更高级别的协议 。它还将累积ACK发送回发送方，但是通过循环接收队列（它不使用`SeqNumToAck`本节前面给出的散文描述中使用的变量）来执行此操作。

```c
static int 
deliverSWP(SwpState state, Msg *frame) 
{
    SwpHdr   hdr;
    char     *hbuf;

    hbuf = msgStripHdr(frame, HLEN);
    load_swp_hdr(&hdr, hbuf) 
    if (hdr->Flags & FLAG_ACK_VALID) 
    {
        /* received an acknowledgment—do SENDER side */
        if (swpInWindow(hdr.AckNum, state->LAR + 1, state->LFS)) 
        {
            do 
            {
                struct sendQ_slot *slot;

                slot = &state->sendQ[++state->LAR % SWS];
                evCancel(slot->timeout);
                msgDestroy(&slot->msg);
                semSignal(&state->sendWindowNotFull);
            } while (state->LAR != hdr.AckNum);
        }
    }

    if (hdr.Flags & FLAG_HAS_DATA) 
    {
        struct recvQ_slot *slot;

        /* received data packet—do RECEIVER side */
        slot = &state->recvQ[hdr.SeqNum % RWS];
        if (!swpInWindow(hdr.SeqNum, state->NFE, state->NFE + RWS - 1)) 
        {
            /* drop the message */
            return SUCCESS;
        }
        msgSaveCopy(&slot->msg, frame);
        slot->received = TRUE;
        if (hdr.SeqNum == state->NFE) 
        {
            Msg m;

            while (slot->received) 
            {
                deliver(HLP, &slot->msg);
                msgDestroy(&slot->msg);
                slot->received = FALSE;
                slot = &state->recvQ[++state->NFE % RWS];
            }
            /* send ACK: */
            prepare_ack(&m, state->NFE - 1);
            send(LINK, &m);
            msgDestroy(&m);
        }
    }
    return SUCCESS;
}
```

最后，`swpInWindow`是一个简单的子程序，它检查给定的序列号是否落在某个最小和最大序列号之间。

```c
static bool 
swpInWindow(SwpSeqno seqno, SwpSeqno min, SwpSeqno max) 
{
    SwpSeqno pos, maxpos;

    pos    = seqno - min;       /* pos *should* be in range [0..MAX) */
    maxpos = max - min + 1;     /* maxpos is in range [0..MAX] */
    return pos < maxpos;
}
```

### 框架顺序和流程控制

滑动窗口协议可能是计算机网络中最着名的算法。然而，对该算法容易混淆的是它可以用于服务三种不同的角色。第一个角色是我们在本节中一直关注的角色 - 可靠地在不可靠的链接上传递帧。（通常，该算法可用于在不可靠的网络上可靠地传递消息。）这是算法的核心功能。

滑动窗口算法可以服务的第二个角色是保持帧的传输顺序。这在接收器上很容易做到 - 因为每个帧都有一个序列号，接收器只是确保它不会将帧传递到下一个更高级别的协议，直到它已经通过所有具有较小序列的帧为止数。也就是说，接收器缓冲（即，不传递）无序帧。本节中描述的滑动窗口算法的版本确实保留了帧顺序，尽管我们可以想象一种变化，其中接收器将帧传递到下一个协议而不等待所有先前的帧被传递。我们应该问自己的一个问题是，我们是否真的需要滑动窗口协议来保持链接级别的帧顺序，或者是否相反，

滑动窗口算法有时会扮演的第三个角色是支持*流控制* - 一种反馈机制，接收器可以通过该机制来限制发送方。这种机制用于防止发送器超过接收器 - 也就是说，不发送比接收器能够处理的数据更多的数据。这通常通过增加滑动窗口协议来实现，使得接收器不仅确认它已经接收到的帧，而且还通知发送器它有多少帧可以接收。接收器能够接收的帧数对应于它具有多少可用缓冲空间。与有序交付的情况一样，我们需要确保在将其合并到滑动窗口协议之前在链路级别进行流量控制。



重点



从这个讨论中拿走的一个重要概念是我们称之为*关注点分离*的系统设计原则。也就是说，您必须小心区分有时在一种机制中汇总的不同函数，并且必须确保每个函数都是必需的并且以最有效的方式得到支持。在这种特殊情况下，可靠的交付，有序交付和流量控制有时会组合在一个滑动窗口协议中，我们应该问自己，这是否是在链接级别做的正确的事情。

## 并发逻辑通道

原始ARPANET中使用的数据链路协议提供了滑动窗口协议的有趣替代方案，因为它能够在仍然使用简单的停止和等待算法的同时保持管道满。这种方法的一个重要结果是通过给定链路发送的帧不以任何特定顺序保存。该协议也没有涉及流量控制。

ARPANET协议的基本思想，我们称之为 *并发逻辑信道*，是将多个逻辑信道复用到单个点对点链路上，并在每个逻辑信道上运行停止和等待算法。在任何逻辑信道上发送的帧之间没有保持关系，但是因为在几个逻辑信道中的每一个上不同的帧可以是未完成的，所以发送者可以保持链路满。

更确切地说，发送方为每个通道保留3位状态：布尔值，表示通道当前是否正忙; 下一次在该逻辑信道上发送帧时使用的1比特序列号; 以及到达此通道的帧上的下一个序列号。当节点有一个要发送的帧时，它使用最低空闲信道，否则它的行为就像停止等待一样。

实际上，ARPANET在每个地面链路上支持8个逻辑信道，在每个卫星链路上支持16个逻辑信道。在地面链路情况下，每帧的标题包括3比特信道号和1比特序列号，总共4比特。这正是滑动窗口协议在链路上支持多达8个未完成帧所需的位数`RWS = SWS`。

# 2.6多址网络

以太网由Xerox Palo Alto研究中心（PARC）的研究人员于20世纪70年代中期开发，最终成为主流的局域网络技术，从一系列竞争技术中脱颖而出。如今，它主要与802.11无线网络竞争，但在校园网络和数据中心仍然非常受欢迎。以太网背后技术的更通用的名称是载波侦听，具有冲突检测的多路访问（CSMA / CD）。

如CSMA名称所示，以太网是多址网络，这意味着一组节点通过共享链路发送和接收帧。因此，您可以将以太网视为具有插入多个站的总线。CSMA / CD中的“载波侦听”意味着所有节点都可以区分空闲和繁忙链路，“冲突检测”意味着节点在发送时进行监听，因此可以检测到它正在发送的帧何时受到干扰（与另一个节点发送的帧冲突）。

以太网的根源在于早期的分组无线电网络，称为Aloha，由夏威夷大学开发，用于支持夏威夷群岛的计算机通信。与Aloha网络一样，以太网面临的根本问题是如何公平有效地调解对共享介质的访问（在Aloha中，介质是大气层，而在以太网中，介质最初是同轴电缆）。Aloha和以太网的核心思想是控制每个节点何时可以传输的算法。

有趣的是，现代以太网链路现在基本上是点对点的; 也就是说，它们将一台主机连接到以太网*交换机*，或者它们互连交换机。因此，“多址”算法在当今的有线以太网中并未得到很多应用，但它现在用于无线网络，例如802.11网络（也称为Wi-Fi）。由于以太网的巨大影响，我们选择在此描述其经典算法，然后在下一节中解释它如何适应Wi-Fi。我们还将在别处讨论以太网交换机。目前，我们将关注单个以太网链路的工作原理。

数字设备公司和英特尔公司于1978年联合施乐公司定义了一个10-Mbps以太网标准。该标准随后形成了IEEE标准802.3的基础，该标准还定义了一个更广泛的物理介质集合，以太网可以在其上运行，包括100- Mbps，1 Gbps，10 Gbps，40 Gbps和100 Gbps版本。

## 物理特性

以太网段最初使用长度达500米的同轴电缆实现。（现代以太网使用双绞铜线，通常称为“5类”特定类型或光纤，在某些情况下可能比500米长很多。）此电缆类似于有线电视使用的类型。主机通过点击连接到以太网段。甲*收发器*，直接连接到抽头的小型装置，当检测到线路是空闲的并且开着当主机正在发送信号。它还接收到输入信号。反过来，收发器连接到插入主机的以太网适配器。该配置[如图1](https://book.systemsapproach.org/direct/ethernet.html#tap)所示。

![img](https://book.systemsapproach.org/direct/figures/f02-22-9780123850591.png)以太网收发器和适配器

多个以太网段可以通过*中继器*连接在一起。转发器是一种转发数字信号的设备，就像放大器转发模拟信号一样; 中继器不理解位或帧。在任何一对主机之间可以放置不超过四个中继器，这意味着传统以太网的总距离仅为2500米。例如，在任何一对主机之间仅使用两个中继器支持类似于[图2](https://book.systemsapproach.org/direct/ethernet.html#net-repeat)中[所示](https://book.systemsapproach.org/direct/ethernet.html#net-repeat)的配置- 即，沿着每个楼层上具有段的建筑物的脊柱向下延伸的段。

![img](https://book.systemsapproach.org/direct/figures/f02-23-9780123850591.png)以太网中继器。

也可以创建一个多路中继器，有时称为 *集线器*，[如图3所示](https://book.systemsapproach.org/direct/ethernet.html#hub)。像转发器一样，集线器只是重复它在其他所有端口上的一个端口上听到的任何信号。集线器的重要之处在于它们可以用于将节点连接到共享以太网而无需使用分接头，这意味着链路可以用光纤或双绞线铜缆实现，而不是同轴电缆。这对于实现更高的以太网性能水平是必要的。

主机在以太网上发出的任何信号都通过整个网络广播; 也就是说，信号在两个方向上传播，并且中继器和集线器在所有传出段上转发信号。连接到每个段末端的终结器吸收信号并防止其反弹并干扰拖尾信号。原始以太网规范使用前面部分中描述的曼彻斯特编码方案，而4B / 5B编码（或类似的8B / 10B）方案现在用于更高速的以太网。

![img](https://book.systemsapproach.org/direct/figures/f02-24-9780123850591.png)以太网集线器

重要的是要了解给定以太网是跨越单个段，由中继器连接的线性序列段，还是由集线器以星形配置连接的多个段，由该以太网上的任何一个主机发送的数据到达所有其他主机。这是个好消息。坏消息是所有这些主机都在竞争访问相同的链接，因此，据说它们处于相同的*冲突域中*。以太网的多址接入部分都是关于处理冲突域中出现的链路的竞争。

## 访问协议

我们现在将注意力转向控制对共享以太网链路的访问的算法。该算法通常称为以太网的 *媒体访问控制*（MAC）。它通常在网络适配器上的硬件中实现。我们不会描述硬件*本身*，而是专注于它实现的算法。然而，首先，我们描述了以太网的帧格式和地址。

### 帧格式

每个以太网帧都由[图4中](https://book.systemsapproach.org/direct/ethernet.html#enet-format)给出的格式定义 。64位前同步码允许接收器与信号同步; 它是0和1交替的序列。源主机和目标主机都使用48位地址标识。分组类型字段用作解复用密钥; 它确定了应该传递这个帧的许多更高级协议。每帧最多包含1500个字节的数据。最低限度，帧必须包含至少46个字节的数据，即使这意味着主机必须在传输帧之前填充帧。这种最小帧尺寸的原因是帧必须足够长以检测碰撞; 我们在下面讨论这个。最后，每个帧包括32位CRC。与前面部分中描述的HDLC协议一样，以太网是面向比特的成帧协议。请注意，从主持人的角度来看，以太网帧有一个14字节的标题：两个6字节地址和一个2字节类型字段。发送适配器在发送之前附加前导码和CRC，并且接收适配器将它们删除。

![img](https://book.systemsapproach.org/direct/figures/f02-25-9780123850591.png)以太网帧格式。

### 地址

以太网上的每个主机 - 实际上，世界上的每个以太网主机 - 都具有唯一的以太网地址。从技术上讲，地址属于适配器，而不是主机; 它通常被烧成ROM。以太网地址通常以人类可以读取的形式打印，作为由冒号分隔的六个数字的序列。每个数字对应于6字节地址的1个字节，由一对十六进制数字给出，一个用于字节中的每个4位半字节; 领先0被删除。例如，`8:0:2b:e4:b1:2`是以太网地址的人类可读表示

```pseudo
00001000  00000000  00101011  11100100  10110001  00000010
```

为了确保每个适配器都获得唯一的地址，每个以太网设备制造商都分配了一个不同的前缀，必须在它们构建的每个适配器上添加前缀。例如，已为Advanced Micro Devices分配了24位前缀`080020`（或`8:0:20`）。然后，给定的制造商确保它产生的地址后缀是唯一的。

在以太网上传输的每个帧都由连接到该以太网的每个适配器接收。每个适配器都识别寻址到其地址的帧，并仅将这些帧传递给主机。（也可以将适配器编程为以*混杂*模式运行，在这种情况下，它将所有接收到的帧传送到主机，但这不是正常模式。）除了这些*单播*地址之外，还会处理由全1组成的以太网地址。作为*广播*地址; 所有适配器都将寻址到广播地址的帧传递给主机。类似地，将第一位设置为1但不是广播地址的地址称为*多播*地址。给定主机可以对其适配器进行编程以接受一组多播地址。多播地址用于将消息发送到以太网上的某些主机子集（例如，所有文件服务器）。总而言之，以太网适配器接收所有帧并接受

- 帧到自己的地址
- 寻址到广播地址的帧
- 如果已指示侦听该地址，则寻址到多播地址的帧
- 所有帧，如果它已被置于混杂模式

它仅向主机传递它接受的帧。

### 发射机算法

正如我们刚才看到的，以太网协议的接收方很简单; 真正的智能在发送方实施。发射机算法定义如下。

当适配器有一个要发送的帧并且线路空闲时，它立即发送帧; 没有与其他适配器协商。消息中1500字节的上限意味着适配器只能占用该行一段固定的时间。

当适配器有一个要发送的帧并且线路忙时，它会等待线路空闲然后立即发送。（更确切地说，所有适配器等待9.6\亩*μ*的始前一帧的结束后传输下一个帧。这对于第一帧的发送方以及监听线路变为空闲的节点都是如此。）以太网被认为是*1持久*协议，因为具有要发送的帧的适配器每当发送概率为1时忙线空转。通常，*p-持久*算法以概率发送 0 \ le p \ le 10 ≤ *p* ≤ 1的线之后变为空闲，并用概率推迟 q = 1 - p*q* = 1 - *p*。选择背后的原因P <1*p* < 1是可能有多个适配器等待忙线变为空闲，我们不希望它们全部同时开始传输。如果每个适配器立即以33％的概率发送，则最多可以有三个适配器等待发送，并且可能只有一个适配器在线路空闲时才开始发送。尽管有这样的推理，以太网适配器总是在注意到网络已经空闲并且非常有效地发送之后立即发送。

完成故事 p*p-*持久协议的情况 P <1*p* < 1，您可能想知道丢失硬币翻转（即决定推迟）的发送者必须等多久才能发送。最初开发这种协议风格的Aloha网络的答案是将时间划分为离散时隙，每个时隙对应于传输完整帧所需的时间长度。每当节点具有要发送的帧并且它感测到空（空闲）时隙时，它就以概率发送p*p*并且以概率推迟到下一个时隙q = 1 - p*q* = 1 - *p*。如果该下一个时隙也是空的，则该节点再次决定以概率发送或推迟p*p*和q*q*，分别。如果下一个时隙不为空 - 也就是说，某个其他站已经决定发送 - 那么该节点只是等待下一个空闲时隙并且算法重复。

回到我们对以太网的讨论，因为没有集中控制，两个（或更多）适配器可能同时开始传输，因为它们都发现线路空闲或两者都在等待忙线路变得空闲。当发生这种情况时，据说两个（或更多）帧在网络上*发生冲突*。由于以太网支持冲突检测，每个发送方都能够确定正在进行冲突。当适配器检测到其帧与另一个帧发生冲突时，它首先确保发送32位干扰序列然后停止传输。因此，在发生冲突的情况下，发送器将最低限度地发送96位：64位前同步码加上32位干扰序列。

适配器只发送96位的一种方法 - 有时称为*欠幅帧* - 如果两个主机彼此靠近则是这样。如果两个主机相距较远，则在检测到碰撞之前，它们必须传输更长时间，从而发送更多位。事实上，最糟糕的情况发生在两台主机位于以太网的两端。为了确保它刚刚发送的帧不与另一帧发生冲突，发送器可能需要发送多达512位。并非巧合的是，每个以太网帧的长度必须至少为512位（64字节）：标头的14个字节加上46个字节的数据加上4个字节的CRC。

为什么是512位？答案与您可能会询问有关以太网的另一个问题有关：为什么它的长度仅限于2500米？为什么不是10公里或1000公里？这两个问题的答案都与两个节点相距较远的事实有关，即一个节点发送的帧到达另一个节点所需的时间越长，并且网络在此期间容易发生冲突。

![img](https://book.systemsapproach.org/direct/figures/f02-26-9780123850591.png)最坏情况：（a）A在时间t发送一个帧; （b）A帧在时间t + d到达B; （c）B在时间t + d开始发射并与A的帧发生碰撞; （d）B的欠幅（32位）帧在时间t + 2d到达A.

[图5](https://book.systemsapproach.org/direct/ethernet.html#worst)说明了最坏情况，主机A和B位于网络的两端。假设主机A在时间t开始发送帧，如（a）所示。它使得到达主机B的帧有一个链路延迟（让我们将延迟表示为d）。因此，A帧的第一位在时间t + d到达B，如（b）所示。假设在主机A的帧到达之前的瞬间（即，B仍然看到空闲线路），主机B开始发送其自己的帧。B的帧将立即与A的帧发生碰撞，主机B（c）将检测到此碰撞。如上所述，主机B将发送32位干扰序列。（B的框架将是一个侏儒。）不幸的是，主机A将不知道碰撞发生直到B的帧到达它，这将发生一个链路延迟，在时间t + 2\倍× d，如（d）所示。主机A必须继续发送直到此时才能检测到冲突。换句话说，主机A必须传输2\倍× d确保它检测到所有可能的碰撞。考虑到最大配置的以太网长度为2500米，并且任意两台主机之间最多可能有四个中继器，往返延迟已确定为51.2\亩*μ* s，这在一个10 Mbps以太网对应于512位。另一种看待这种情况的方法是我们需要将以太网的最大延迟限制在一个相当小的值（例如，51.2）\亩*μ* S）用于接入算法工作; 因此，以太网的最大长度必须大约为2500米。

一旦适配器检测到碰撞并停止其传输，它将等待一段时间并再次尝试。每次尝试传输但失败时，适配器会在再次尝试之前将等待的时间加倍。这种将每次重传尝试之间的延迟间隔加倍的策略是称为*指数退避*的一般技术 。更确切地说，适配器首先延迟0或51.2\亩*μ* S，随机选择。如果此尝试失败，则等待0,51.2,102.4或153.6\亩*μ*又在发尝试之前（随机选择的）; 这是k\倍× 51.2表示k = 0..3。在第三次碰撞后，它等待k\倍k = 0.2时× 51.2^ 33 -1，随机再次选择。通常，算法随机选择0到2之间的ak^ N*Ñ* -1并等待ķ\倍× 51.2\亩*μ* s，其中ñ*n*是到目前为止经历的碰撞次数。适配器在给定次数的尝试后放弃，并向主机报告传输错误。尽管退避算法有限，但适配器通常最多重试16次ñ上述公式中的*n*为10。

## 以太网的寿命

30多年来，以太网一直是主导的局域网技术。今天它通常是点对点部署，而不是采用同轴电缆，它通常以1或10 Gbps而不是10 Mbps的速度运行，并且它允许使用高达9000字节数据而不是1500字节的巨型数据包。但是，它仍然向后兼容原始标准。这值得说几句关于为什么以太网如此成功，以便我们可以理解我们应该尝试用任何试图取代它的技术模拟的属性。

首先，以太网非常易于管理和维护：没有路由或配置表可以保持最新，并且很容易将新主机添加到网络中。很难想象一个更简单的网络来管理。其次，它很便宜：电缆/光纤相对便宜，唯一的其他成本是每台主机上的网络适配器。由于这些原因，以太网变得根深蒂固，任何渴望取代它的基于交换机的方法都需要额外投资基础设施（交换机），而不仅仅是每个适配器的成本。基于交换机的以太网变体最终成功取代了多接入以太网，

# 2.7 无线网络

无线技术在某些重要方面与有线链路不同，同时共享许多常见属性。与有线链路一样，比特错误的问题非常令人担忧 - 由于大多数无线链路的不可预测的噪声环境，通常更是如此。还必须解决帧和可靠性问题。与有线链路不同，功率对于无线来说是一个大问题，特别是因为无线链路经常被小型移动设备（如电话和传感器）使用，这些设备对电源的访问有限（例如，小型电池）。此外，您无法使用无线电发射器以任意高功率进行爆破 - 存在对与其他设备干扰的担忧，并且通常会规定设备在任何给定频率下可以发出多少功率。

无线媒体本身也是多址的; 很难将您的无线电传输指向一个接收器或避免从您附近有足够功率的任何发射器接收无线电信号。因此，媒体访问控制是无线链路的核心问题。并且，由于在通过无线传输时很难控制谁接收到您的信号，因此也可能需要解决窃听问题。

有一种令人困惑的各种不同的无线技术，每种技术都在各个方面做出不同的权衡。对不同技术进行分类的一种简单方法是通过它们提供的数据速率以及通信节点之间的距离。其他重要的差异包括它们使用的电磁频谱的哪一部分（包括它是否需要许可证）以及它们消耗的电量。在本节中，我们将讨论两种主要的无线技术：Wi-Fi（更正式地称为802.11）和蓝牙。下一节将讨论ISP访问服务环境中的蜂窝网络。[表1](https://book.systemsapproach.org/direct/wireless.html#wirelessTechnologiesTable) 概述了这些技术以及它们如何相互比较。



领先的无线技术概述

|                | 蓝牙（802.15.1）       | Wi-Fi（802.11）        | 4G Cellular          |
| -------------- | ---------------------- | ---------------------- | -------------------- |
| 典型的链接长度 | 10米                   | 100米                  | 几十公里             |
| 典型数据速率   | 2 Mbps（共享）         | 54 Mbps（共享）        | 1-5 Mbps（每个连接） |
| 典型用途       | 将外围设备链接到计算机 | 将计算机链接到有线基座 | 将手机连接到有线塔   |
| 有线技术类比   | USB                    | 以太网络               | PON                  |

您可能还记得，带宽有时意味着以赫兹为单位的频段宽度，有时也意味着链路的数据速率。由于这两个概念都出现在无线网络的讨论中，我们将在其更宽的频带宽度中使用*带宽* - 并使用术语*数据速率*来描述每秒可以发送的比特数链接，如[表1所示](https://book.systemsapproach.org/direct/wireless.html#wirelessTechnologiesTable)。

## 基本问题

由于无线链路都共享相同的介质，因此面临的挑战是如何有效地共享该介质，而不会过度干扰彼此。大多数这种共享是通过沿着频率和空间的维度进行划分来实现的。可以将特定地理区域中的特定频率的独占使用分配给诸如公司的个体实体。限制电磁信号覆盖的区域是可行的，因为这些信号随着距其原点的距离而减弱或*衰减*。要减小信号覆盖的面积，请降低变送器的功率。

这些分配通常由政府机构确定，例如美国的联邦通信委员会（FCC）。特定频带（频率范围）被分配给某些用途。有些乐队留待政府使用。其他频段保留用于诸如AM收音机，FM收音机，电视，卫星通信和蜂窝电话之类的用途。然后，这些频段内的特定频率被许可给各个组织，以便在某些地理区域内使用。最后，为不需要许可证的免许可使用频带留出了几个频段。

使用免许可证频率的设备仍然受到某些限制，以便进行无约束的共享工作。其中最重要的是对传输功率的限制。这限制了信号的范围，使其不太可能干扰另一个信号。例如，无绳电话（普通的未经许可的设备）可能具有大约100英尺的范围。

当频谱在许多设备和应用之间共享时，一个显示出很多想法的是*扩频*。扩频背后的想法是在更宽的频带上扩展信号，以便最小化来自其他设备的干扰的影响。（扩频最初设计用于军事用途，因此这些“其他设备”经常试图阻塞信号。）例如，*跳频*是一种扩频技术，涉及通过随机频率序列发送信号; 也就是说，首先以一个频率发送，然后是第二个，然后是第三个，依此类推。频率序列不是真正随机的，而是由伪随机数发生器在算法上计算。接收方使用与发送方相同的算法，并使用相同的种子对其进行初始化; 因此，它能够与发射机同步跳频，以正确接收帧。该方案通过使两个信号不太可能使用相同频率而不是不频繁的隔离位来减少干扰。

第二种扩频技术称为*直接序列*，它增加了冗余度，以实现更大的干扰容限。每个数据位由发送信号中的多个比特表示，因此，如果一些发送的比特被干扰损坏，则通常有足够的冗余来恢复原始比特。对于发送方想要发送的每个比特，它实际上发送该比特的异或和n个随机比特。与跳频一样，随机比特序列由发送器和接收器都知道的伪随机数发生器产生。被称为n比特*码片*的发送值将信号扩展到比本来需要的帧宽n倍的频带上。[图1](https://book.systemsapproach.org/direct/wireless.html#chipping) 给出了4位切片序列的示例。

![img](https://book.systemsapproach.org/direct/figures/f02-27-9780123850591.png)示例4位切片序列。

电磁波谱的不同部分具有不同的特性，使得一些更适合于通信，而另一些则不那么适合。例如，有些可以穿透建筑物，有些则不能。政府只管理主要的通信部分：无线电和微波范围。随着对主要频谱的需求增加，人们对可用的频谱产生了浓厚的兴趣，因为模拟电视逐渐被淘汰，有利于数字化。

在今天的许多无线网络中，我们观察到有两种不同类型的端点。一个端点（有时称为*基站*）通常没有移动性，但具有到Internet或其他网络的有线（或至少高带宽）连接，[如图2](https://book.systemsapproach.org/direct/wireless.html#wirelessBaseStation)所示。链路另一端的节点（此处显示为客户端节点）通常是移动的，并且依赖于其到基站的链路，以便与其他节点进行所有通信。

注意，在[图2中，](https://book.systemsapproach.org/direct/wireless.html#wirelessBaseStation)我们使用波浪线对来表示在两个设备之间（例如，在基站和其客户端节点之间）提供的无线“链路”抽象。无线通信的一个有趣方面是它自然支持点对多点通信，因为一个设备发送的无线电波可以被许多设备同时接收。但是，为更高层协议创建点对点链接抽象通常很有用，我们将在本节后面看到如何工作的示例。

注意，在[图2中](https://book.systemsapproach.org/direct/wireless.html#wirelessBaseStation)，非基站（客户端）节点之间的通信是通过基站路由的。尽管由一个客户端节点发射的无线电波很可能被其他客户端节点接收，但是公共基站模型不允许客户端节点之间的直接通信。

![img](https://book.systemsapproach.org/direct/figures/f02-28-9780123850591.png)使用基站的无线网络。

该拓扑结构意味着三种不同的移动性水平。第一级不具有移动性，例如当接收器必须处于固定位置以从基站接收定向传输时。第二级是基站范围内的移动性，与蓝牙的情况一样。第三个层次是基地之间的移动性，就像手机和Wi-Fi一样。

![img](https://book.systemsapproach.org/direct/figures/f02-29-9780123850591.png)无线ad hoc或网状网络。

一种越来越受关注的替代拓扑是*网状* 或*ad hoc*网络。在无线网状网络中，节点是对等节点; 也就是说，没有特殊的基站节点。只要每个节点在前一节点的范围内，就可以通过对等节点链转发消息。这在[图3中](https://book.systemsapproach.org/direct/wireless.html#wirelessMesh)说明。这允许网络的无线部分延伸超出单个无线电的有限范围。从技术之间的竞争角度来看，这使得短程技术可以扩展其范围并可能与更长距离的技术竞争。网格还通过为消息从A点到B点提供多条路径来提供容错。网状网络可以递增扩展，增加成本。另一方面，网状网络要求非基本节点在其硬件和软件中具有一定程度的复杂性，可能增加每单位成本和功耗，这是电池供电设备的关键考虑因素。无线网状网络具有相当大的研究兴趣，但与具有基站的网络相比，它们仍处于相对初级阶段。

现在我们已经介绍了一些常见的无线问题，让我们来看看两种常见无线技术的细节。

## 802.11 /无线网络连接

大多数读者将使用基于IEEE 802.11标准的无线网络，通常称为*Wi-Fi*。Wi-Fi在技术上是一个商标，由一个名为Wi-Fi Alliance的贸易集团拥有，该集团证明产品符合802.11标准。与以太网一样，802.11设计用于有限的地理区域（家庭，办公楼，校园），其主要挑战是调解对共享通信媒体的访问 - 在这种情况下，信号通过空间传播。

### 物理特性

802.11定义了许多不同的物理层，这些物理层在不同的频段工作，并提供一系列不同的数据速率。在撰写本文时，802.11n提供最高的最大数据速率，最高可达600 Mbps。

最初的802.11标准定义了两个基于无线电的物理层标准，一个使用跳频（超过79个1-MHz宽的频率带宽），另一个使用直接序列扩频（具有11位码片序列）。两者都提供了2 Mbps范围内的数据速率。随后添加了物理层标准802.11b。使用直接序列的变体，802.11b提供高达11 Mbps的速率。这三个标准都在免许可证的2.4GHz频段的电磁频谱中运行。然后是802.11a，使用称为*正交频分复用（OFDM）*的FDM变体提供高达54 Mbps的速率; 802.11a运行在免许可证的5-GHz频段。一方面，该频带使用较少，因此干扰较少。另一方面，信号的吸收更多，并且仅限于几乎视线。遵循802.11g; 802.11g还使用OFDM，提供高达54 Mbps的速率，并向后兼容802.11b（并返回到2.4 GHz频段）。

最近，802.11n出现在现场，其标准于2009年获得批准（尽管也存在预标准产品）。802.11n使用多个天线实现了最大可能数据速率的显着进步，并允许更大的无线信道带宽。对于多输入多输出，多天线的使用通常被称为*MIMO*。

商业产品通常支持多种802.11的风格; 一些基站支持所有四种变体（a，b，g和n）。这不仅可以确保与支持任何一种标准的任何设备兼容，而且还可以使两种此类产品为特定环境选择最高带宽选项。

值得注意的是，虽然所有802.11标准都定义了可支持的 *最大*比特率，但它们也主要支持较低的比特率; 例如，802.11a允许比特率为6,9,12,18,24,36,48和54 Mbps。在较低的比特率下，在存在噪声的情况下更容易解码发送的信号。使用不同的调制方案来实现各种比特率; 另外，改变纠错码形式的冗余信息量。更多的冗余信息意味着以降低有效数据速率为代价来提高对比特错误的恢复能力（因为更多的传输比·特是冗余的）。

系统试图根据它们自己发现的噪声环境选择最佳比特率; 比特率选择的算法可能非常复杂。有趣的是，802.11标准并未指定特定方法，而是将算法留给各个供应商。选择比特率的基本方法是通过直接测量物理层的信噪比（SNR）或通过测量数据包成功传输和确认的频率来估计SNR来估计误码率。在某些方法中，发送方有时会通过以该速率发送一个或多个数据包来探测更高的比特率，以查看它是否成功。

### 避免碰撞

乍一看，似乎无线协议将遵循与以太网相同的算法 - 等待直到链路在发送之前变为空闲并且在发生冲突时退回 - 并且，首先，这是802.11所做的。无线的额外复杂性在于，虽然以太网上的节点接收每个其他节点的传输并且可以同时发送和接收，但这些条件都不适用于无线节点。这使得对碰撞的检测更加复杂。无线节点通常不能同时（在相同频率上）发送和接收的原因是发射机产生的功率远高于接收到的任何接收电路并因此淹没接收电路。节点可能不接收来自另一节点的传输的原因是因为该节点可能太远或被障碍物阻挡。这种情况比最初出现的情况稍微复杂一些，如下面的讨论所示。

![img](https://book.systemsapproach.org/direct/figures/f02-30-9780123850591.png)隐藏节点问题。虽然A和C彼此隐藏，但它们的信号可能在B处发生碰撞。（B的触及范围未显示。）

考虑[图4](https://book.systemsapproach.org/direct/wireless.html#wifiHiddenNode)中描述的情况，其中A和C都在B的范围内但不在彼此的范围内。假设A和C都希望与B通信，因此它们每个都发送一帧。A和C互不了解，因为它们的信号没有那么远。这两个帧在B处相互冲突，但与以太网不同，A和C都不知道这种冲突。A和C被认为是相对于彼此的*隐藏节点*。

![img](https://book.systemsapproach.org/direct/figures/f02-31-9780123850591.png)暴露的节点问题。虽然B和C暴露在彼此的信号中，但是如果B发送到A而C发送到D，则没有干扰。（A和D的到达未显示。）

在[图5](https://book.systemsapproach.org/direct/wireless.html#wifiExposedNode)所示的情况下发生称为*暴露节点问题的*相关问题，其中四个节点中的每一个都能够发送和接收仅到达其左右的节点的信号。例如，B可以用A和C交换帧但是它不能到达D，而C可以到达B和D而不是A.假设B正在向A发送。节点C知道这种通信，因为它听到B的传输。然而，如果C得出结论认为它无法传播给任何人只是因为它可以听到B的传输，那将是一个错误。例如，假设C想要发送到节点D.这不是问题，因为C到D的传输不会干扰A从B接收的能力。它会干扰A发送到B，但B在我们的例子中发送。）

802.11通过使用CSMA / CA来解决这些问题，其中CA代表冲突*避免*，与以太网上使用的CSMA / CD 的冲突*检测*相反。有一些部分可以完成这项工作。

载波侦听部分看起来很简单：在发送数据包之前，发射机会检查是否可以听到任何其他传输; 如果没有，它发送。然而，由于隐藏节点问题，仅等待来自其他发射器的信号的缺失不能保证从接收器的角度不会发生冲突。因此，CSMA / CA的一部分是从接收方到发送方的显式ACK。如果数据包被成功解码并在接收器处传递其CRC，则接收器将ACK发送回发送器。

请注意，如果确实发生了冲突，它将使整个数据包无效。出于这个原因，802.11添加了一个名为RTS-CTS（准备发送 - 清除发送）的可选机制。这在某种程度上解决了隐藏节点问题。发送方向目标接收方发送RTS-短数据包，如果成功接收到该数据包，则接收方以另一个短数据包CTS响应。即使隐藏节点可能没有听到RTS，CTS也可能是。这有效地告知接收器范围内的节点他们不应该发送任何东西 - 预期传输的时间量包括在RTS和CTS分组中。在该时间加上小间隔过去之后，可以假定载波再次可用，并且另一个节点可以自由尝试发送。

当然，两个节点可能检测到空闲链路并尝试同时发送RTS帧，导致它们的RTS帧相互冲突。发送者意识到当他们在一段时间之后没有收到CTS帧时发生了冲突，在这种情况下，他们每次等待一段随机的时间再重试。给定节点延迟的时间量由指数退避算法定义，非常类似于以太网上使用的算法。

在成功进行RTS-CTS交换之后，发送方发送其数据包，如果一切顺利，则接收该数据包的ACK。在没有及时确认的情况下，发送方将再次尝试使用上述相同的过程再次请求使用该信道。当然，此时，其他节点也可能再次尝试访问该频道。

### 分发系统

如上所述，802.11适用于具有网状（*ad hoc*）拓扑的网络，并且用于网状网络的802.11s标准的开发即将完成。然而，目前，几乎所有802.11网络都使用面向基站的拓扑。

不是将所有节点创建为相同，而是允许一些节点漫游（例如，您的笔记本电脑），并且一些节点连接到有线网络基础设施。802.11称这些基站*接入点*（AP），它们通过所谓的*分配系统*相互连接。[图6](https://book.systemsapproach.org/direct/wireless.html#wireless2)示出了连接三个接入点的分发系统，每个接入点为一些区域中的节点提供服务。每个接入点在适当频率范围内的某个信道上运行，并且每个AP通常与其邻居在不同的信道上。

![img](https://book.systemsapproach.org/direct/figures/f02-32-9780123850591.png)连接到分发系统的接入点。

分发系统的细节对于此讨论并不重要 - 例如，它可以是以太网。唯一重要的一点是，分发网络在链路层运行，与无线链路的协议层相同。换句话说，它不依赖于任何更高级别的协议（例如网络层）。

虽然两个节点可以在彼此可达的范围内彼此直接通信，但是这种配置背后的想法是每个节点将自己与一个接入点相关联。例如，对于节点A与节点E通信，A首先向其接入点（AP-1）发送帧，该接入点通过分发系统将帧转发到AP-3，AP-3最终将帧发送到E.如何AP -1知道将消息转发到AP-3超出了802.11的范围; 它可能使用了桥接协议。802.11指定的是节点如何选择其接入点，更有趣的是，该算法如何根据从一个小区移动到另一个小区的节点来工作。

选择AP的技术称为*扫描*，涉及以下四个步骤：

1. 节点发送`Probe`帧。
2. 触手可及的所有AP都使用`Probe Response`框架进行回复。
3. 节点选择一个接入点并向该AP发送一 `Association Request`帧。
4. AP用`Association Response`框架回复。

每当节点加入网络时，以及当它对其当前AP变得不满意时，节点就会参与该协议。例如，这可能发生，因为来自其当前AP的信号由于节点远离它而减弱。每当节点获得新AP时，新AP通过分发系统向旧AP通知该改变（这在步骤4中发生）。

![img](https://book.systemsapproach.org/direct/figures/f02-33-9780123850591.png)节点移动性。

考虑[图7](https://book.systemsapproach.org/direct/wireless.html#wireless3)所示的情况，其中节点C从AP-1服务的小区移动到AP-2服务的小区。当它移动时，它发送`Probe`帧，最终导致`Probe Response`来自AP-2的帧。在某些时候，C优先于AP-1而不是AP-1，因此它将自己与该接入点联系起来。

刚刚描述的机制称为*主动扫描，*因为节点正在主动搜索接入点。AP还定期发送一个 `Beacon`广告接入点功能的帧; 这些包括AP支持的传输速率。这称为 *被动扫描*，并且节点可以`Beacon`简单地通过将`Association Request`帧发送回接入点来基于帧改变到该AP 。

### 帧格式

大多数802.11帧格式（[如图8](https://book.systemsapproach.org/direct/wireless.html#802.11-format)所示 ）正是我们所期望的。该帧包含源节点地址和目的节点地址，每个地址长度为48位; 最多2312个字节的数据; 和32位CRC。该 `Control`字段包含三个感兴趣的子字段（未示出）：`Type`指示帧是否携带数据的6比特字段，是RTS或CTS帧，还是由扫描算法使用，以及一对1比特字段 -叫做`ToDS`和`FromDS`- 如下所述。

![img](https://book.systemsapproach.org/direct/figures/f02-34-9780123850591.png)802.11帧格式。

802.11帧格式的独特之处在于它包含四个而不是两个地址。如何解释这些地址取决于帧的字段中的位`ToDS`和`FromDS`位 的设置`Control`。这是为了考虑帧必须通过分发系统转发的可能性，这意味着原始发送者不一定与最近的发送节点相同。类似的推理适用于目标地址。在最简单的情况下，当一个节点直接发送到另一个节点时，这两个`DS`位都是0，`Addr1`标识目标节点，并`Addr2` 标识源节点。在最复杂的情况下，两者都有`DS`比特设置为1，表示消息从无线节点进入分发系统，然后从分发系统进入另一个无线节点。设置两个比特，`Addr1`识别最终目的地，`Addr2`识别直接发送者（将帧从分发系统转发到最终目的地的那个），`Addr3`识别中间目的地（从无线节点接收帧并将其转发到的目的地）。分配系统），并`Addr4`确定原始来源。就[图6中](https://book.systemsapproach.org/direct/wireless.html#wireless2)给出的示例而言，`Addr1` 对应于E，`Addr2`标识AP-3，`Addr3`对应于AP-1，并且`Addr4`标识A.

### 无线链路的安全性

与电线或光纤相比，无线链路的一个相当明显的问题是，您无法确定数据的去向。您可以弄清楚它是否被预期的接收器接收，但是没有人知道有多少其他接收器也可能已经接收到您的传输。因此，如果您担心数据的隐私性，无线网络将面临挑战。

即使您不关心数据隐私 - 或者可能以其他方式处理它 - 您可能会担心未经授权的用户将数据注入您的网络。如果不出意外，这样的用户可能会消耗您希望自己消耗的资源，例如您家和ISP之间的有限带宽。

由于这些原因，无线网络通常具有某种机制来控制对链路本身和传输数据的访问。这些机制通常被归类为*无线安全性。* 广泛采用的WPA2在第8章中描述。

## 蓝牙（802.15.1）

蓝牙填补了移动电话，PDA，笔记本电脑和其他个人或外围设备之间短距离通信的空白。例如，蓝牙可用于将移动电话连接到耳机或笔记本电脑连接到键盘。粗略地说，蓝牙是用线连接两个设备的更方便的替代方案。在这些应用中，没有必要提供很大的范围或带宽。这意味着蓝牙无线电可以使用相当低的功率传输，因为传输功率是影响带宽和无线链路范围的主要因素之一。这与蓝牙设备的目标应用程序相匹配 - 其中大多数是电池供电的（例如无处不在的电话耳机），因此重要的是它们不会消耗太多电力。

蓝牙在2.45 GHz的免许可频段运行。蓝牙链路的典型带宽约为1至3 Mbps，范围约为10 m。出于这个原因，并且因为通信设备通常属于一个个人或组，所以蓝牙有时被归类为个人区域网（PAN）。

蓝牙由称为*蓝牙特别兴趣小组*的行业协会指定。它指定了一整套协议，超出了链路层，可以为一系列应用定义应用程序协议（称为*配置文件）*。例如，存在用于使PDA与个人计算机同步的简档。另一个配置文件使移动计算机以802.11的方式访问有线局域网，尽管这不是蓝牙的最初目标。IEEE 802.15.1标准基于蓝牙，但不包括应用协议。

基本的蓝牙网络配置称为*微微网*，由一个主设备和多达七个从设备组成，[如图9](https://book.systemsapproach.org/direct/wireless.html#wirelessBluetoothPiconet)所示 。任何通信都在主站和从站之间进行; 奴隶不直接相互沟通。由于从站具有更简单的角色，因此其蓝牙硬件和软件可以更简单，更便宜。

![img](https://book.systemsapproach.org/direct/figures/f02-35-9780123850591.png)蓝牙微微网。

由于蓝牙工作在免许可证频段，因此需要使用扩频技术来处理频段内可能的干扰。它使用79个*频道*（频率）的跳频，每个*频道*用于625\亩*μ* s的时间。这为蓝牙提供了用于同步时分复用的自然时隙。帧占用1个，3个或5个连续时隙。只有主设备才能开始在奇数时隙中发送。从设备可以开始在偶数时隙中发送 - 但仅响应于在前一时隙期间来自主设备的请求，从而防止从设备之间的任何争用。

从设备可以*停放* ; 也就是说，它被设置为非活动的低功耗状态。停放的设备无法在微微网上通信; 它只能由主人重新激活。除了活动的从设备之外，微微网最多可以拥有255个驻留设备。

在低功耗，短距离通信领域，除了蓝牙之外还有一些其他技术。其中之一是ZigBee，由ZigBee联盟设计并标准化为IEEE 802.15.4。它专为带宽要求低且功耗必须非常低以提供非常长的电池寿命的情况而设计。它还旨在比蓝牙更简单和更便宜，使其可以并入更便宜的设备，如*传感器*。传感器正在成为一种越来越重要的联网设备，随着技术的发展，可以大量部署非常便宜的小型设备来监控建筑物中的温度，湿度和能耗等因素。

# 2.8接入网络

除了以太网和Wi-Fi连接之外，我们通常使用家庭，工作，学校和许多公共场所连接互联网，我们大多数人通过我们购买的*接入*或 *宽带*服务连接到互联网一个ISP。本节介绍两种此类技术：*无源光网络*（PON），通常称为光纤到户，以及 连接我们移动设备的*蜂窝网络*。在这两种情况下，网络都是多址的（如以太网和Wi-Fi），但正如我们将看到的，他们调解访问的方法是完全不同的。

为了设置更多的背景，ISP（通常是电信公司或有线电视公司）经常运营国家骨干网，并且连接到该骨干网的外围的是数百或数千个边缘站点，每个站点服务于城市或社区。这些边缘站点通常被称为Telco世界中的*中心局*和有线世界中的*Head Ends*，但尽管它们的名称暗示“集中式”和“层级根”，但这些站点位于ISP网络的最边缘; 直接连接到客户的最后一英里的ISP端。PON和蜂窝接入网络固定在这些设施中。

> DSL是PON的传统铜基对应物。DSL链路也在电信中心办公室终止，但我们没有描述这项技术，因为它正在逐步淘汰。

## 无源光网络

PON是最常用于向家庭和企业提供基于光纤的宽带的技术。PON采用点对多点设计，这意味着网络结构为树状，单个点从ISP的网络开始，然后扇出到最多1024个家庭。PON的名称源于分路器是被动的：它们在下行和上行转发光信号而不主动存储和转发帧。通过这种方式，它们是经典以太网中使用的中继器的光学变体。然后，在ISP的场所中，在称为*光线路终端*（OLT）的设备中以及在各个家庭的端点处，在称为*光网络单元*（ONU）的设备中发生成帧。

[图1](https://book.systemsapproach.org/direct/access.html#pon)显示了一个示例PON，简化为仅描绘一个ONU和一个OLT。在实践中，中央办公室将包括连接到数千个客户家庭的多个OLT。为了完整起见， [图1](https://book.systemsapproach.org/direct/access.html#pon)还包括有关PON如何连接到ISP主干（以及因此连接到Internet的其余部分）的另外两个细节。在*此Agg交换机*聚集的流量从一组的OLT，而*BNG*（宽带网络网关）是一块电信设备的是，在许多其他事情，米互联网流量进行计费的缘故。顾名思义，BNG实际上是接入网络（BNG左侧的所有内容）和互联网（BNG右侧的所有内容）之间的网关。

![img](https://book.systemsapproach.org/direct/figures/access/Slide1.png)将中央办公室中的OLT连接到家庭和企业中的ONU的示例PON。

由于分路器是无源的，因此PON必须实现某种形式的多址协议。它采用的方法可归纳如下。首先，上游和下游流量在两个不同的光波长上传输，因此它们完全相互独立。下行流量从OLT开始，信号沿PON中的每个链路传播。结果，每个帧到达每个ONU。然后，该设备查看通过波长发送的各个帧中的唯一标识符，并保留帧（如果标识符是用于它）或丢弃它（如果不是）。加密用于防止ONU窃听其邻居的流量。

然后在上游波长上对上游业务进行时分复用，每个ONU周期性地进行发送。因为ONU分布在相当宽的区域（以千米为单位）并且与OLT的距离不同，所以它们基于同步时钟进行传输是不实际的，如在SONET中那样。相反，ONT 向各个ONU 发送*授权*，给予它们可以发送的时间间隔。换句话说，单个OLT负责集中实现共享PON的循环共享。这包括OLT可以授予每个ONU不同时间份额的可能性，从而有效地实现不同级别的服务。

从某种意义上说，PON类似于以太网，它定义了一种随着时间的推移而发展的共享算法，以适应越来越高的带宽。G-PON（Gigabit-PON）是目前部署最广泛的，支持2.25-Gbps的带宽。XGS-PON（10千兆位-PON）刚刚开始部署。

## 蜂窝网络

虽然蜂窝电话技术的根源在于模拟语音通信，但基于蜂窝标准的数据服务现已成为常态，这在很大程度上要归功于智能手机日益增长的功能。与Wi-Fi一样，蜂窝网络在无线电频谱中以特定带宽发送数据。与Wi-Fi不同，Wi-Fi允许任何人使用2.4或5 GHz的频道（你所要做的就是建立一个基站，就像我们许多人在我们家中所做的那样），已经拍卖了各种频段的独家使用关闭并授权给服务提供商，服务提供商又向其订户销售移动接入服务。

用于蜂窝网络的频带在世界各地各不相同，并且由于ISP经常同时支持旧/传统技术和新/下一代技术这两个频带占用不同的频带而变得复杂。高级概述是传统蜂窝技术的范围从700MHz到2400MHz，新的中频分配现在发生在6GHz，毫米波（mmWave）分配在24GHz以上。一个有趣的脚注是，在北美还有一个名为*Citizens Broadband Radio Service*（CBRS）的3.5 GHz无牌频段，任何拥有蜂窝无线电的人都可以使用。这为建立私人蜂窝网络打开了大门。

与802.11一样，蜂窝技术依赖于使用连接到有线网络的基站。在蜂窝网络的情况下，基站通常被称为*宽带基站单元* （BBU），连接到它们的移动设备通常被称为*用户设备*（UE），并且该组BBU锚定在*演进分组上。核心*（EPC）托管在中央办公室。EPC服务的无线网络通常称为*无线电接入网络*（RAN）。

> BBU目前通过另一个名称-Evolved NodeB，通常缩写为eNodeB或eNB-其中NodeB是在蜂窝网络的早期化身中被称为无线电单元（并且已经发展）。鉴于蜂窝世界继续快速发展并且有充分的理由相信eNB不久就会过时，我们决定使用更通用且更不神秘的BBU。

[图2](https://book.systemsapproach.org/direct/access.html#ran)描绘了端到端场景的一种可能配置，其中包含一些额外的细节。EPC具有多个子组件，包括MME（移动性管理实体），HSS（归属用户服务器）和S / PGW（会话/分组网关）对; 第一个跟踪和管理整个RAN中UE的移动，第二个是包含订户相关信息的数据库，网关对在RAN和Internet之间处理和转发数据包（它形成EPC的*用户平面）*）。我们说“一种可能的配置”，因为蜂窝标准允许给定MME负责的S / PGW的多少变化，使得单个MME可以管理由多个中心局服务的广泛地理区域的移动性。最后，虽然[图2中](https://book.systemsapproach.org/direct/access.html#ran)未明确说明 ，但有时会使用ISP的PON网络将远程BBU连接回中央办公室。

![img](https://book.systemsapproach.org/direct/figures/access/Slide2.png)无线电接入网络（RAN）将一组蜂窝设备（UE）连接到中央办公室中托管的演进分组核心（EPC）。

BBU天线服务的地理区域称为*小区*。BBU可以服务于单个小区或使用多个定向天线来服务多个小区。细胞没有清晰的边界，它们重叠。在它们重叠的地方，UE可能与多个BBU通信。然而，在任何时间，UE仅与一个BBU通信并且在其控制下。当设备开始离开细胞时，它移动到与一个或多个其他细胞重叠的区域。当前的BBU检测到来自电话的弱化信号，并将设备控制到从哪个基站接收到来自它的最强信号。如果设备当时涉及呼叫或其他网络会话，则必须将会话转移到所谓的*切换中*的新基站。切换的决策过程属于MME的范围，MME历来是蜂窝设备供应商的专有方面（尽管开源MME实现现在开始可用）。

已经有多代协议实现了蜂窝网络，俗称1G，2G，3G等。前两代仅支持语音，3G定义了向宽带接入的过渡，支持以数百千比特每秒测量的数据速率。今天，该行业处于4G（支持数据速率通常以每秒几兆比特为单位测量），并且正在向5G过渡（有望将数据速率提高十倍）。

从3G开始，世代指定实际上对应于3GPP（第三代合作伙伴计划）定义的标准。尽管其名称中包含“3G”，但3GPP仍在继续定义4G和5G的标准，每个标准都对应于该标准的发布。现已发布的第15版被认为是4G和5G之间的分界点。另一个名称，这个版本和代的序列称为LTE，代表*长期演进*。主要内容是，虽然标准是作为一系列离散版本发布的，但整个行业现在处于一个相当明确的进化路径上，称为LTE。

LTE 5G空中接口的主要创新之处在于它提供的灵活性。5G使用称为OFDMA（正交频分多址）的混合复用方案，其直观地组合频分复用（将频带划分成多个重叠的子信道）和时分复用（将一个或多个子信道分配给a）给定UE一段时间）。OFDMA还使用称为LDPC（低密度奇偶校验）的编码方案，其确保相邻子信道上的传输的符号间干扰的概率为零。考虑LDPC的另一种方式是将比特编码到信号上的方式包括足够的冗余（即，FEC的形式）以确保接收器即使在信号重叠时也能够恢复原始数据。此外，BBU还具有增加/减少其用于传输的功率的能力，有效地允许它们动态地改变小区大小。这使得可以在运行中将UE从一个小区移动到另一个小区。

总而言之，这为RAN提供了三个自由度（频率，时间，功率），从而提高了其从有限频谱中挤出最大容量的能力。更重要的是，这种灵活性为ISP提供了向其订户提供新服务的机会，支持从需要大量带宽的视频和虚拟/增强现实到对延迟敏感的自动驾驶汽车和物联网等各种应用。5G的挑战是如何控制和最好地利用这种灵活性。

# 2.9更广泛的视角

## 争夺边缘

当我们开始探索软件化如何改变网络时，我们应该认识到，正是接入网络将家庭，企业和移动用户连接到正在经历最激进变革的互联网。[2.8节中](https://book.systemsapproach.org/direct/access.html)描述的光纤到户和蜂窝网络目前由复杂的硬件设备（例如，OLT，BNG，BBU，EPC）构成。这些设备不仅历史上是封闭的和专有的，而且销售它们的供应商通常在每个设备中捆绑了广泛而多样的功能集。结果，它们构建起来变得昂贵，操作复杂并且变化缓慢。

作为回应，网络运营商正在积极地从这些专用设备过渡到在商用服务器，交换机和接入设备上运行的开放软件。这项计划通常被称为*CORD*，它是**C** entral **O** ffice **R** e-architected as **D** atacenter 的首字母缩写，顾名思义，其构想是建立Telco中心办公室（或电缆头端，导致首字母缩略词*HERD*）使用与构成云的大型数据中心完全相同的技术。

运营商实现这一目标的动机部分是受益于用商品硬件替换专用设备所带来的成本节约，但主要是由于加快创新步伐的需要。他们的目标是实现新的边缘服务类别 - 例如，公共安全，自动驾驶汽车，自动化工厂，物联网（IoT），沉浸式用户界面 - 从最终用户的低延迟连接中受益，更重要的是，这些用户所围绕的设备越来越多。这导致类似于[图1中](https://book.systemsapproach.org/direct/trend.html#cord)所示的多层云。

![img](https://book.systemsapproach.org/direct/figures/access/Slide3.png)新兴的多层云包括基于数据中心的公共云，IXP托管的分布式云和基于访问的边缘云，例如CORD。虽然全球有150个IXP托管云，但我们可以预期会有数千甚至数万个边缘云。

这是将功能从数据中心移出并更接近网络边缘的增长趋势的一部分，这一趋势使云提供商和网络运营商陷入冲突。追求低延迟/高带宽应用的云提供商正在走出数据中心并走向边缘，同时网络运营商正在将云的最佳实践和技术应用到已经存在的边缘，并实施接入网络。不可能说这会随着时间的推移如何发挥作用; 这两个行业都有其特殊的优势。

一方面，云提供商认为，通过利用边缘集群饱和城域区域并抽象出接入网络，他们可以构建具有足够低延迟和足够高带宽的边缘存在，以服务于下一代边缘应用。在这种情况下，接入网络仍然是一个愚蠢的位管道，允许云提供商在他们最擅长的方面表现出色：在商用硬件上运行可扩展的云服务。

另一方面，网络运营商认为，通过使用云技术构建下一代接入网络，他们将能够在接入网络中共同定位边缘应用。此方案具有内置优势：现有且分布广泛的物理占用空间，现有运营支持以及对移动性和有保证服务的本机支持。

虽然承认这两种可能性，但第三个结果不仅值得考虑，而且值得努力：*网络边缘*的*民主化。*我们的想法是让任何人都可以访问边缘云，而不是严格意义上的现有云提供商或网络运营商的域。有三个理由对这种可能性持乐观态度：

1. 用于接入网络的硬件和软件正在变得商品化和开放。这是我们刚才谈到的关键推动因素。如果它能帮助电信公司和CableCos保持敏捷，那么它可以为任何人提供相同的价值。
2. 有需求。汽车，工厂和仓库领域的企业越来越希望为各种物理自动化用例部署私有5G网络（例如，远程代客停放车库或使用自动化机器人的工厂车间）。
3. 频谱正在变得可用。5G开放用于美国和德国的未经许可或轻微许可的模式，作为两个主要的例子，其他国家很快就会效仿。这意味着5G应具有大约100-200 MHz的频谱供私人使用。

简而言之，接入网络历史上一直是电信公司，CableCos以及销售专有机箱的供应商的范围，但接入网络的软化和虚拟化为任何人（从智能城市到服务欠缺的农村地区到公寓）打开了大门。复杂到制造工厂）建立一个接入边缘云并将其连接到公共互联网。我们希望它能像今天一样容易地部署WiFi路由器。这样做不仅可以将访问边缘带入新的（更加边缘化的）环境，而且还有可能为开发人员打开访问网络，这些开发人员本能地去有创新机会的地方。



 更广泛的视角



要继续阅读有关Internet的云化的信息，请参阅 [虚拟网络](https://book.systemsapproach.org/internetworking/trend.html)。

要了解有关接入网络中发生的转变的更多信息，我们建议：

- [CORD：中央办公室重新设计为数据中心](https://wiki.opencord.org/display/CORD/Documentation?preview=/1278027/1966399/PETERSON_CORD.pdf)。*IEEE通信*，2016年10月。
- [使网络边缘民主化](https://ccronline.sigcomm.org/2019/democratizing-the-network-edge/)。*SIGCOMM CCR*，2019年4月。
