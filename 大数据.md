# 第一章 概论

## 第一讲 大数据概论

### 数据的历史

- 60年代 网状数据库 层次数据库
- 80年代 关系数据库
- 关系数据管理
- CAD 面向对象数据库
- 文本与多媒体数据库
- 数据分析与挖掘
- 21世纪 web xml
- 云计算 大数据
- 业务启动

大数据

- 数据集用传统方法无法处理

大数据

海量数据，无法在传统软件下实现数据的处理工作

来源：

- 用户的操作数据
- 生产活动

做什么：原油

互联网每天产生大量数据

### 大数据系统

用于大数据分析的软件系统

大是相对的

100MbB但是1毫秒内完成复杂数据分析也超出了传统设备的能力

大数据是永恒的话题

有限的计算资源，针对的问题规模在给定的时间内给出计算的结果

数据超过计算能力或者容忍的时间

人 机器 软件数据三流汇聚

### 企业与大数据

数据管理的企业

- 金融
- 航空

结构化数据

非结构化数据

数据治理的无政府组织

学者眼中的大数据

计算机科学中的一个旗帜

最火的大数据实验室

- 伯克利
- 机器学习
- 操作系统
- 数据库

数据工程->数据科学

知识工程 认知科学

数据仓库 数据分析

在线事务 在线分析 商务智能

数据科学就是从数据当中发现知识

## 第二节 大数据典型应用

危险边缘 人与机器知识的对决

4TB信息

大数据故事

沃尔玛 啤酒与尿片

谷歌对流感的预测

奥巴马连任

奥斯卡预测

林彪也玩大数据

孙膑 10万个锅 到 5千个 增兵建灶 

## 第三节 大数据的特点

大在哪？

- 数据规模
  - 物联网收集数据
- 多样的数据类型
  - 结构化数据
  - 半结构数据
  - 非结构化数据 大数据主题
- 生命周期
  - 获取
  - 清洗
  - 集成
  - 建模
- 问题
  - 异构
  - 规模
  - 时效
  - 隐私
  - 协同
- 深度加工
  - 数据
  - 信息
  - 知识
  - 智慧
- 处理方式
  - 批量
  - 实时
  - 在线
- 用户
  - 内部
  - 外部
- 质量
  - 精确性
  - 一致性
  - 完整性
  - 时效性

价值

- 新浪微博1亿条信息
- 红楼梦72万字 更加密集
- 大数据数据密度较低
- 春秋航空利用大数据避免了事故
- 马航说明还有很多要做

## 第四节 大数据技术体系

- 可视化
- 分析与挖掘
- 存储
- 集成
- 隐私与安全
- 计算范型

数据质量：无法避免的挑战

- 传统ETL 抽取转换 加载 解析 分析
- 分布式环境如何保证全局数据的一致性
- 流数据中保持时效性
- 大数据中保证绝对的质量并不现实

数据存储

- 哈希大于扫描
- 但副本转向多副本
- 单阶段到多阶段
- 压缩不在解压

**大数据的特点**

- 发生了啥   将要发生生命
- 规模小到大规模复杂的数据
- 简单模型到复杂的模型
- 因果分析到关联分析

**三个问题**

- 监控流数据，跟踪动态数据
- 与数据科学家一块工作
- 分析工具集成到核心业务

可视化的挑战

讲数据信息可视化的展示出来

数据的洞察

**计算范型**

- 数据找程序   程序找数据
- 传统计算到云计算
- cpu 到 HPU
- 并行计算

安全与隐私

- 斯诺登棱镜计划
- 苹果安全漏洞

大数据及其挑战

- 人因与大数据的迭代过程

## 第五节 大数据生态系统

Hadoop生态系统

伯克利大数据处理平台

Spark

Spark优势

用户学习成本低

RDD 内存处理高速

大数据结构框架标准化

## 第六讲 大数据技术挑战

2007年 数据库科研的拐点的到来

出现了大数据的概念

2013年

充分的讨论与一致的意见

数据的大不是数据科学面临的全部挑战

数据的处理时效性

数据隐私的可用性

数据科学刚刚起步

## 第七讲 课程主要内容

系统工具的原理与实现

设计新的系统工具

数据库操作系统网络知识

知识结构体系

动手能力高

实验贯穿整个课程

# 第二章 云计算

## 第一讲 概述

大数据是实现大数据非常好的解决方法

云计算的商业模式

虚拟化技术 云计算的核心技术

- 计算
- 网络
- 存储

openstack

大数据

- 数量大
- 变化大
- 产生速度大
- 价值密度低

需求

- 海量计算与存储
- 快读计算
- 快速传输
- 灵活
- 低成本

如何实现需求

- 并行化
- 规模经济
- 虚拟化

大数据软硬件架构

硬件

- 计算
- 存储
- 网络

虚拟化层

云层

大数据框架 并行化的思想 抽象

## 第二讲 大数据与云计算

摩尔定律 18个月晶体管集成度翻一翻

Joy定律 2002后不在正确

并行化理念存在于计算机方方面面

并行请求 多个计算机

并行线程 多个核心

并行指令 流水线

并行数据 多个数据项

硬件描述 所有门电路

## 第三讲 规模经济

**仓库规模计算机**

主要部件

- 存储 计算 供电 制冷 网络

优势

- 规模经济
- 提高使用率

挑战

- 运维
- 能耗PUE 总体能量/用在电脑上的能量 国内超过了2

谷歌数据中心外部

- 水电
- 数据中心

网络连接的存储与计算资源

复杂网络架构

虚拟机

特点

- 同质硬件和系统软件平台
- 共享系统管理
- 应用程序中间件系统软件自主开发
- 运行小数目的大型程序
- 通用的资源管理架构增强了部署灵活性

## 第四讲 云

wsc到云：多租户

多租户多应用如何管理

任何计算机科学问题都可能增加层来解决

- 虚拟化

每一个用户认为他有一个网络，事实上跟别人是共享的

## 第五讲 云计算的商业模式

SaaS模式 作为服务通过互联网提供的应用程序，以及位于数据中心的硬件与软件

云 数据中心软硬件

公有云 即用即付 开放大众

私有云：企业组织使用

公用计算：

- 给人无限资源
- 细粒度

云计算商业模式

- 按需要服务
- 资源池
- 可测量的服务

云计算发展的技术推动

- 数据中心 WSC
- 宽带网络普及化
- 分布式系统
- 虚拟化技术
- 开源软件

云计算市场条件

互联网应用 社交网络

- 规模经济
- 需求增长
- 无法预测增长速度
- 大数据应用
  - 日志分析
  - 机器学习应用

## 第六讲 云计算的商业模式

云计算的商业价值

传统数据中心：浪费严重

SLA服务质量需要足够的资源

白天晚上访问量不同，你所需要的资源必须按照最高流量情况考虑。

损失了收益，损失了用户

静态的数据中心容量是固定的

云计算的计算资源是动态的，每个人的需求是不同的，可以动态的调整

云计算本身提升了资源的利用率

## 第七讲 云计算的分类方法

提供的抽象层

- 指令集的虚拟机
- 运行时的系统虚拟机
- 框架性虚拟机 可以直接写程序，分布式的架构
- 折中：灵活与可以执行 内置的功能
- EC2 AppEngine
- 灵活与效率

普遍发方法

- 软件即服务SaaS  应用程序
- 平台即服务PaaS 自己编写程序
- 基础设施即服务IaaS 自己组建网络

大部分是PaaS与IaaS之间的服务

新技术的炒作曲线

先热门 顶峰  冷门  缓慢升温
云计算先炒作起来，后来缓慢升温，慢慢成熟起来

## 第八讲 虚拟化技术

为什么要虚拟化

- 分区   一个机器给各个部门使用，大资源打包
- 抽象   很多的体系架构，需要抽象来同意

现阶段的增加

- 资源池
  - 资源聚合
  - 动态分配
- 隔离
  - VPN虚拟专用网络
- 便于管理
  - 测试
  - 备份
  - 镜像

虚拟化的概念

- 用户
- 应用程序
- 桌面
- 服务
- 操作系统
- 服务器
- 存储
- 网络

数据中心

- 网络
- 计算
- 存储

## 第九讲 虚拟化技术

计算话技术

- 主操作系统
- 客户操作系统
- Hypervisor VMM 管理客户操作系统的
  - 运行在主操作系统 VMWARE
  - 运行在真实机器上 直接控制客户操作系统
  - 结合二者，Linux KVM



服务器虚拟化考虑的三个问题

- 指令集的翻译（缓存）
  - 如何快速执行（缓存)
  - 如何执行更高全线的指令
- I/O设备的仿真
  - 访问不支持的硬件
  - 保护I/O性能
- 保护处理器的数据结构 影子处理器

核心问题

内存的保护管理

- 程序
  - 代码
  - 数据
  - 堆
  - 栈
- 翻译映射 虚拟地址 到 物理地址

MMU来管理，硬件转换 寻址 页表 谁来维护

解决方式

- 半虚拟化
  - 修改操作系统操作系统，不能操作的不做，需要改操作系统
- 影子页表
  - 拒绝对操作系统页表的访问
  - 捕获访问请求，在软件中仿真
- 硬件支持的虚拟化(主流)
  - 二级地址转换表
    - AMD
    - Intel



## 第十讲 网络虚拟化

实际物理网络与虚拟网络

一个大的交换机上的二级网络

上课喊一嗓子 广播

人多了 设置班级 安排班长（交换机）间接管理

网络安全

网络虚拟化VLAN

限制广播域

- 端口分属于不同VLAN
- 多个VLAN共享一个端口
  - Trunk模式
  - VLAN标签 802.1Q头
    - VLANID  4096个头

12bit 4096个VLAN口

- tag不够用
- 支持广泛
- 硬件成本低

网络硬件标准不太好改

VxLAN

- 三层隧道实现
- 广播->组播
- 再打包 VxLAN 24bit
- VTEPs负责打包与解包

## 第十一讲 软件定义网络

实现网络虚拟化的一个手段

传统网络

- 控制面与数据面集成再一个设备
- 不同网络之间通过协议来转发

交换机

- 线卡
- 交换结构

软件定义网络

- 控制面集中管理，放在服务器
- 数据面与控制面分开

实现距离 OpenFlow

机器通讯在软件定义网络中

交换机不需要控制层

控制器 DST 目标地质

收到包以后询问控制器，控制器监控整个网络，汇聚交换机，核心交换机，互联网

每次都问，如何加速：

- 缓存

## 第十二讲 虚拟化技术距离

PortLand 大规模二层网络

大曾网络的挑战

- 规模 广播
- 地址解析
- 交换机要记住大量状态
- MAC地址是不连续的

PortLand实现

- 与位置有关的虚拟地址
- 通过SND地址解析

PortLand地址解析过程

- 网络解惑所有ARP
- MAC映射为位置有关的地址
- 转发数据包
- 发给服务器之后改回来原来的MAC

虚拟网络

虚拟机 虚拟网络

OPenVSwitch

虚拟的交换机

网桥 桥接

## 第十三讲 存储虚拟化

用户结构

意义

- 独立于数据位置
  - 扩展性强，容量大
  - 易于管理
  - 提升磁盘利用率
- 独立于物理存储技术
  - 易于升级
  - 可用性的优化（冗余，负载均衡）
  - 易于维护（备份，恢复）

存储虚拟化的三类接口

- 块接口
  - 本地块存储
    - 本地磁盘
    - 本地磁盘阵列
  - 远程存储接口
    - 光线
- 文件接口
  - 文件系统
  - 网络文件接口（NFS，CIF,HDFD)
- 对象存储接口
  - openstack swift
  - 亚马逊 S2

块接口协议

谁来拥塞控制？

S3对象存储

- HTTP协议 REST接口

  GET POST

- 扁平的命名空间 key value

## 第十四讲  分布式存储的实现

SAN NAS

存储区域网络SAN

- 稳定
- 直接用网络连接存储服务

网络附接存储

- 便宜
- 通过网络来访问存储

SAN 

- 完整的网络
- 跑 快的协议
- 贵

NAS

- In Band所有控制通过虚拟装置 
- Out Band数据直接在主机和存储来流动
  - AFS 只管解析 只指路 大数据文件系统都用这个

## 第十五将 发展趋势

- 优势
  - 统一，抽象，隐藏了硬件
  - 灵活，软件定义
  - 易于管理，保证安全
- 劣势
  - 额外的开销
  - 性能没有实现隔离，cpu好切分，磁盘不好切分
  - 多层抽象，难以调试

发展趋势:软件定义数据中心

- 网络功能虚拟化
  - 防火墙虚拟化
- 资源管理调度
- 空调虚拟化，供电虚拟化，建筑虚拟化

目标：性能+灵活性+管理

## 第十六将 openstack

API

- 用户虚拟机
- 消息队列
- 调度器（负载均衡）
- 镜像存储服务
- 计算节点通过消息队列起一个网络
- 共享磁盘卷

## 第十七讲 总结

云计算

- 性能 并行
- 经济 规模化
- 可管理 虚拟化

虚拟化 抽象

- 计算
- 网络
- 存储

独立设备 分布式编程

分布式架构，计算框架

文件系统 gfd 虚拟了硬盘

Hadoop 

云计算系统

- 用户忘记底层
- 好的大数据系统 忘记今天讲的内容

# 第三章 文件存储

## 第一节 分布式文件系统

本地文件系统

分布式文件系统

GFS文件系统

**文件系统概述**

为什么文件系统

cpu 内存数据暂时的，加电才有

硬盘接口复杂，文件系统提供了一个抽象，保存数据，长期储存

**文件系统名字空间**

目录树 win d:\ D:\

linux /根目录

文件树型结构

C:\window\notepad.exe

根目录一级一级访问

/home/mike/a.txt

根目录一级一级访问树的遍历 

**名字空间的操作**

树数据结构的操作 插入删除节点

创建 删除目录

树的遍历   目录的理出

**文件读写操作**

open read write close

open内核记录打开事件，offset文件偏移置为0，记录打开文件这个事件

close 删除这个数据结构

size大小 buffer缓冲区

namespace 

## 第二讲 **文件系统的设计**

**文件系统的下层接口**

磁盘读写接口，磁盘的地址  磁盘就是数据块数组，一个512字节，数组上，

R(address)->Data

写入（address,Data)

两个操作

磁盘暴露给应用程序，对于使用者不方便

**文件系统下层接口**

- 目录树的组织  字符串->位置，helo word
- 文件数据的读写

**文件系统的本质**

文件名字翻译到具体的位置，完成文件的读写

第三讲 **文件系统接口标准化**

**虚拟文件系统**

物理文件系统与服务的一个中间层

文件系统

- 内核层
- 应用层

操作系统支持不同文件系统 FAT NFS

u盘 FAT 不同协议操作系统可以共存

虚拟化 java interface

vfs隔离，隐藏了细节，exe文件系统



## 第三讲 文件系统 磁盘数据结构

文件系统磁盘数据组织

文件系统名字解析

启动快，不同快组

快

- 超级快，描述一些信息
- 快描述
- 位图4KB标记快是否被使用了
- Inode 代表文件 目录 每个文件的信息 0 不存在 1 存在
- inode table
  - owner
  - c tiime
  - address size

文件系统 名字解析

inode不包含文件名字

/home/mike/a.text

名字解析过程

- 根目录 where node 指向的数据块
  - 所有子目录名字的ionde号
  - 类似于链表的操作

## 第四讲 文件系统讨论

**磁盘块大小**

512字节

文件系统 4KB 快

快读写，一个文件一个块，1个B必须占用4KB,粒度越小，浪费越少

磁盘管理复杂性，每一个磁盘块需要一个数据结构来描述，管理更复杂

一个1GB的文件 512B划分，文件碎片散落在各个角落，磁盘头疯狂读写，性能很差。

1MB一块，管理容易，磁道随机读写性能更好。

磁盘块大小与文件的特点有关

**缓存**

缓存加速，利用了时间空间局部性

**磁盘系统优化**

磁盘读写与随机访问

盘片 面 磁道 磁盘读写 磁头频繁移动

尽量顺序读写，而不是随机读写

顺序读写100mb 随机1mb 快的多

## 第五讲 分布式文件与本地文件

分布式文件系统的功能

- 目录树
- 读写

建立的基础

- 直接读写磁盘 OS自带了文件系统，可以构建在文件系统之上
- 分布式文件系统的地址（host机器locolPC +DIskl）

分布文件：

- 目录树翻译为具体结点，磁盘定位靠本地来做

## 第六讲 最简单分布式文件系统

NFS网络文件系统

mount NFSServer 名字

NFS a.txt 内核 VFS接口模块 

NFS Server  ext2 vfs hard driver

vfs中间商转发 

不典型 提供数据服务的只有一个

## 第七讲 AFS 文件系统

运行在广义网上的服务器

afs系统

games

/afs/tsinghua.cn/dsct/hpc/ufs.game

访问根-> 下一级别服务器，afs定位服务器

## 第八讲 谷歌文件系统

分布式文件系统

建立搜索引擎，需要存储互联网容量的数据，支持快速写入到分布式文件系统中

为了支持查询，需要对大量数据进行处理，建立倒排索引，进行网页数据进行排序

应用驱动，需要建立一个新的分布式文件系统

需求

- 存储大量的数据
  - 集群建立在x86集群中，数千个节点，但是容易出错
- 现有文件系统无法满足需求
  - 整个硬件许多模块都会出错
  - 有时一个超大规模文件，文件超过了百GB
- 读写模式（优先考虑）
- - 文件一次写入，多次读取
  - 高延迟，高带宽
  - 写入并发，并发读取

## 第九讲 设计文件系统

目标

- 文件系统 目录树 文件读写
- 利用底层资源 负载均衡
- 容错 
- 系统简洁 不能复杂到无法控制 不利于扩展

基本设计

- 数据块
  - 由于文件规模大，文件划分为64MB数据块
- 性能设计
  - 全局动态信息，负载均衡
- 可靠性
  - 保证数据可靠，数据块保留备份，一般会保存3个以上节点
- 系统简化设计
  - 主节点master，调整整个系统的访问流程

## 第十讲 分布式文件系统的基础设计

一台机器来存储目录树，只存储元数据，关于数据路由的信息，存放数据。

主服务器 master

chunkserver其他服务器

主服务器

元数据

- 命名空间
- 文件chunk id
- chunk->服务器，考虑可靠性，一个chunk对应多个服务器

API编程接口

创建一个目录

chunk index

ID号对应存储服务器，chunk handle chunk locations 

单点节点问题 master可能成为性能瓶颈

## 第十一讲 GFS性能问题

快服务器负载均衡问题

- 不能让负载压在一块
- 负载均衡
- master来负载均衡
- 热点增加副本数目

块服务器的扩展性问题

- 服务器增加难度
- 由于有master 扩展很简单

主服务器的性能负载问题

- 元数据的计算过程
- 64MB->64B 存储是否够
- overhand 访问速度问题
- 文件系统10PB 10GB的目录元数据，现代服务器有32G的内存，可以保存在内存当中，速度还挺快。
- cliant master 一次1000个chunk 元数据不会成为瓶颈

## 第十二讲 GFS可靠性

快服务器可靠性问题

- 块服务器出错
- 一个块服务器出现错误，副本数目恢复所需要的时间
- 副本下线时候 2个恢复到3个副本
- 恢复两个T数据，顺序读写 200MB,2*1024*1024/200=10000s 两个小时，不同副本备份可以并行进行，64MB/1000Mb 不到一秒

主服务器可靠性问题

- 内存数据的可恢复性（日志操作），写操作按照日志写到磁盘里面，定期刷到硬盘，最新元数据
- 单个节点主服务器可恢复性
- 影子服务器，shadow操作，记录日志，提供service
- shadow 切换到主服务器，需要几分钟来进行



## 第十三将 一致性要求

三个副本一致性要求 一致性要求，保证一样

传统文件一致性问题 没有

更改数据的操作

- write（fd,buffer,size,offset)
- 数据原子性的append操作接口

如何保证数据一致的写入操作

数据块修改与一致性维护

目标 维护所有数据完全一样

方法 初始数据块都没有数据，之后以相同的操作顺序执行客户端的操作

手段：一致性协商，由master负责 负担过重，由副本自己解决，主要副本有一个tickt，死了以后立马要另一个人顶上，操作顺序由主要副本来定，数据块操作是一致的。

## 第十四将 放松的一致性

一致的 三个副本一致

append write 

原子性的追加

F写入  A B

64MB

并发写入是一致的，但是数据并不一定是明确的，追加操作，一致的但是不明确

## 第十五将 GFX POSIX兼容性

GFS不是标准文件系统，不兼容与POSIX

兼容性哲学：通用的一般不是最优的策略。

特点

垃圾搜集

- 删除数据就是本地删除，本地不会有垃圾
- master垃圾数据块的清理

总结

- 设计内建错误容忍机制
- 大文件优化
- 现有文件系统的扩展
- 简化的设计，易于维护



# 第四章 处理框架

大数据处理框架

mapreduce 

编程模式

实现方法

性能讨论

pig latin

语言

编写大型成或许

并行

**大数据分析工具**

批处理工具

实时数据梳理

结构化

非结构化

**批处理非结构化工具**

**数据并行**

重要观点

- 数据存于成百上千服务器
- 大数据减少元数据的开销
- 使用商用硬件
- 没有复杂的一致性模型
- 单写者
- 避免互相等待
- 简单才可靠

数据并行化DLP

硬盘大量数据进行并行化处理 尴尬的并行

词频统计

问题

- 共享状态
  - 吞吐量 多个进程同时改变
  - 同步 修改需要锁
  - 通讯成本很高，元数据管理和复杂
- 批量通讯 局部计数，最后汇总
- 全局状态也切分开，都并行
- 失败的机器，防止失败
- mapreduce模型
- 易用性
- 通用性
- 抽象层次

## 第二讲 MapReduce模型

数据并行的分治策略

Map

- 数据分割为shards，分配给不同的接待你

reduce

- 收集，合并子问题的解

易于使用

- 开发者集中处理数据处理
- 系统负责细节

基本实现

map

- 处理输入的中间键值对 key value 
  - list(out ket,intermediate value)
  - 处理输入键值对
  - 生成中间的结果集

reduce

- reduce
- 合并所有值

第一步 map 切分数据

切分，map函数

第二节 shuffle reduce1 reduce2

collect 合并 append一起

mapreduce 很简单

## 第三讲  mapreduce过程

输入数据分割Mk块，每块愤怒时调用map()

- 通常每个数据块16MB
- 取决于GFS数据块大小
- 输入数据由不同服务器并行处理
- 中间结果分割，每块分布式调用

MR数目由用户指定

M>>servers R>servers

很大m有利于负载均衡，快速恢复

每个R调用，对应于单独的输出文件，R不宜过大

mapreduce

细粒度任务 map任务远大于机器个数

桶排序

group by key

emit(key,value)

外存排序

mergesort

shuffle过程

## 第四讲 数据流过程

基于谷歌的任务调度，GFS,Hadoop

数据流问题

启动

master进程

worker map reduce hash

排序 进行调用函数

输出

并行化

网络与cpu

并行化思想

## 第五讲 性能问题

整个任务完成时间受最慢的节点来决定的

解决问题 冗余任务

- 谁先完成，谁获胜
- 投机执行

影响：增加缩短任务完成时间

- 资源增加3个点，大型任务速度提升30

independent 独立的

idempoent 幂等的

mapreduce故障处理

计算节点故障

- 控制节点通过周期性心跳来检测
- 重新执行

主节点故障

- 目前没有解决

健壮性

- 丢失1800的160仍然完成了任务

## 第六节 Hadoop mapreduce开源实现

Hadoop系统 开源实现

谷歌有分布式架构 gfd 资源管理调度任务 配置文件 由其他服务来提高

hadoop自己实现了文件系统 mapreduce 

master 接受任务，分配任务，监控任务，处理错误

worker 任务描述 多个map reduce 进程 task独立的进程，运行了一些函数，报告进度，小监工



- hdfs拷贝文件
- 提交任务
- 得到文件
- 切分
- 上传作业
- 提交任务
- 初始化任务 任务队列
- 创建reduce map 分割多个任务
- 分配任务
- 取得一个进程
- 心跳汇报自己活着呢

## 第七讲 MapReduce 总结

- 切分任务，数据并行，不需要通信数据之间
- 操作确定的
- 操作幂等的
- 操作的输出存储于硬盘上

mapreduce用来做什么

**gogle**

建立索引

文章聚类

统计性机器翻译

**Yahoo**

建立索引

垃圾检测

**facebook**

数据发掘

广告优化

垃圾检测

**优点**

分布式过程完全透明

- 没有分布式编程

自动容错

- 操作准确性
- 中间节点容忍错误
- 收缩扩容
- 负载均衡

mapreduce**缺点**

- 严格的数据流
- 常见操作手写代码
- 程序语义隐藏在mapreduce函数中

## 第八讲 pig latin语言简介

数据分析任务

用户最常访问

group by 并表 mapreduce 

加载 group by url foreach url generatecount 

load url info join on url

group by category

mapreduce的结合 生成10个url的代码，代码复用性差，难优化，

pig latin

更高级的编程语言

- 快捷的mapreduce流程
- 关系型数据库
- java嵌入

mapreduce的集成软件

## 第九讲 pig latin基本语法

数据流

visits

gvisit

visitCounts

urlinfo 

visitCounts

gCategories 

topUrls

文件操作，用户可以自己定义函数，可以用于任何构造过程中

## 第十讲 嵌套的数据结构

支持嵌套的数据类型2

原子   元组   包   映射

优势

- 更自然
- 避免代价昂贵的joins操作

group by url作为一个独立操作

共同分组 GoGroup

## 第十一讲 实现与优化技巧

部署

pig 优化与重写为hadppo map reduce

sql pig hadoop 加一层抽象

# 第五章 内存计算

## 第九讲 spark

**如何抽象多台机器的内存**

分布不是共享内存 DSM

- 多个机器统一地址空间

- 容错低

  

分布式健值存储  piccolo RAMCloud

- 允许细粒度访问
- 可以修改数据
- 容错开销大

容错机制

- 副本或log
  - 对于数据密集应用来说开销很大
  - 比内存慢10 - 100倍



## 第十讲 解决方案

RDD 

- 基于数据集合，而不是单个数据 一次操作数据集但是记录一次
- 由确定性的粗粒度操作产生
- 数据产生就不能修改
- 修改数据就要通过数据集变换来产生新的数据集

高效容错方法

数据产生就不会变化

- 重复计算来恢复数据
- 记住生成过程就行了，一次Log用于很多数据，不出错没有开销

## 第十一讲 并行系统

限制了编程模型来换取容错与性能

性能与修改粒度

## 第十二讲 spark编程接口

scala语言 

类似java 函数语言

控制台交互使用

也支持java python

基于rdd操作

一种是transformation

- map
- reduce
- filter
- group by
- sort
- distinct
- sample
- 等



一种是 action

## 第十二讲 log挖掘案例

数据从文件调入内存，进行交互式的查询

内存上进行5秒 如果在硬盘上需要170秒

**逻辑回归**

spark性能远远高于hadoop

利用了cache的spark tql

## 第十五 spark实现技术

延值估值

## 第十六 复杂DAG

数据划分

优化后性能继续提高

## 第十七 性能调优

重用RDD使用Persist和cache提高性能

## 第十八讲 spark

mesos

hadoop

spark

hive

shark

streaming

graphx

mlbase



mapreduce 通用

pregel giraph 图计算

tez

strom 流计算

spark 统一框架支持多种模式

## 第十九讲 spark 局限

图的遍历算法

数据更新需要复制操作 rdd只读，更新是重新复制，太占内存了

# 第六章 健值存储系统

cassandra

健值存储系统原理

nosql运动

- 1986年
- 非关系型数据库

cassandra

分布式NoSQL

来源

- Google bigtable
- amazon
- 用于instagram

特点与定位

- 无单点故障
- 高可用
- 可配置的一致性

时间序列

物联网

社交媒体

## 第二讲 数据模型

健空间 列族的容器

列族 动态拼接积木

列

行

嵌套的键值对

thrift

暴露了系统接口，抽象成都不足

暴露了内存结构，迭代不方便

cql r3复合类型

## 第三节 架构

去中心化 p2p

- 分布式关系分布架构
- 单机停机不会对整个系统有影响，最多影响性能
- 扩展能力强

不同节点相互感知

hadoop主从架构，主结点管理

caj捷键了dynamo架构，利用grossip协议来发现集群节点的位置，状态

gossip 瘟疫算法，一传十，十传百

**grossip**交换信息三种模式

- 推
- 拽
- 推拽

## 第四节 一致性哈希与数据分区

一致性哈希方法

- 同样哈希函数计算数据对象和节点哈希值
- 哈希对象不知数据，还有节点

环形拓扑

- 集群所有数据形成一个环

区间range

- 区间数量等于节点数量
- 节点存储本身与相邻区间

数据放在哪个节点？

顺时针绕环

优点

- 客户端自己决定存放哪个节点，不需要控制器来分配
- 节点改变也不需要重新分配
  - 删除，临近机器接管删除节点数据
  - 增加节点，临近节点分摊

## 第五讲 数据副本

全副本 每个节点存储一个完整数据库

数据存储次数分为副本因子



简单策略

机架感知策略

数据中心感知

副本优点

- 可用性
- 并行化
- 减少传输

缺点

- 增加更新成本
- 增加并发控制策略

**数据分区与副本**

管理副本一致性

- 副本数
- 写副本数
- 读副本数

## 第六讲 存储结构

LSM tree结构

写操作日志

数据持久化文件

内存的数据表

mem数据排序

sstable写入不修改

缓存

# 第七章 流计算

## 第一节 概论

- 复杂性
- 必要性
- 实例

流计算需求

挑战

实现模式

实例

雅虎 1-s4

2 - strom

## 第二讲流计算需求

批处理，全读入处理

mr

spark

graphlab

特征

- 数据太大，放不下全部数据（10年的词频统计）
- 数据太快以致于来不及处理
- 批处理框架性能成本不合适

## 第三讲 应用

twitter

每天5亿

对里面进行统计

## 第四讲 适合流计算

F(x+ΔX)=F(X)op H(ΔX)

对于历史数据与新增数据操作来简化操作，而不是要重新计算

这样的处理方式就是流计算，只计算增长的部分，而不是全局

## 第五章 流计算的技术挑战

目标

- 实时性/扩展性
- 容错
  - 数据错误
  - 系统故障
- 编程性

实时性

批处理任务

- 固定规模数据
- 执行时间几十小时

流处理

- 数据速率很大
- 能够处理所有数据
- 预先定义好降级处理方法

批处理任务

- 数据错误靠清洗阶段
- 故障有重算与检查点设置

流计算

- 错误实时处理
- 系统故障容错机制低开销，满足实时性

可编程性

- 描述自然
- 表达能力强
- 无需关注容错机制与负载均衡

## 第六节

## 第七节 一种实现 worker+queue

worker 处理单元

queue 缓存+路由

解决生产者消费者的不均衡问题

问题

- 不易扩展
- 难容错
- 编码难



## 第八节 流计算的实例 s4

简单的编程接口，处理key value

有限容错

- 出错后重新在备用结点
- 当前进程状态丢失，支持非协调式
- 运行期间不能增加或删除系统结点

处理模型

- actor模型

PE

通过event进行通信

PE状态不可见

s4框架负责产生pe流

设计

- 基于 key arrtibute流
- 输入ka 进行计算，产生中间结果，输出另一个流

PE 由PE代码和配置文件定义

处理的事件类型

k a

每个key值对应与PE

- 遇到一个新词创建一个PE

pe垃圾收集是一个挑战的问题

PN概念

zookeeper保存信息



## 第九节 流计算的实例 strom

数据类型 tuple key value

stream

数据类型 所有primitive type

spout

bolt

- ilters
- aggregation
- joins
- 访问数据库
- 运行自定义函数

Stream Grouping

随机

健值选取

分发所有任务

发给最小id的任务

topplogy



容错问题

- 一个消息处理 at least



## 第十节 对比s4和strom

编程模型

- s4简单，编写key就完事
- strom保存处理更多东西

推还是拉好

- s4推
- strom拉

容错

- s4不管消息消失，可以恢复状态
- strom保证消息处理一次

社区

strom是apache是顶级项目，社区非常活跃

s4还是孵化项目，雅虎使用

