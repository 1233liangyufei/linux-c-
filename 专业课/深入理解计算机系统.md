# 深入理解计算机系统》｜ 计算机系统漫游

![img](https://upload.jianshu.io/users/upload_avatars/3010486/d9eee8450714.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[唐鱼的学习探索](https://www.jianshu.com/u/0129e34fa381)关注

0.2882016.09.20 10:16:03字数 1,343阅读 693



![img](https://upload-images.jianshu.io/upload_images/3010486-beb9e3578511ae3c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

#### ［阅读本书的目的］

​     我们傻傻的编写程序，其实并不知道计算机是如何将源代码文件编译链接成可执行的程序，也不知道指令是如何被加载，如何一条一条的执行，到最后显示出结果。在这一过程中，写代码的人如何能编写出健壮的代码、如何很好的利用操作系统的特性优化代码、发生了问题如何学会自己去分析，而不做拿来主义google式的程序猿。这本书也许是这些终极问题的最好解答，正如作者在开篇说的一样：“如果你全力投入学习本书的概念中去，完全理解底层计算机系统以及它对程序的影响，那么你将逐渐成为凤毛麟角的**权威**程序猿”。

#### ［笔记内容］

​     本章从一个程序的生命周期讲起，分别对程序的创建、编译、执行、输出、终止进行了详细的解读，从中引出了关于信息上下文、编译系统、高速缓存、操作系统等重要概念，并对上述问题进行了简单的讲解，其中作为程序猿应该要好好理解和利用的部分正是：高速缓存。

**1.信息就是如何解释：**



![img](https://upload-images.jianshu.io/upload_images/3010486-fb6db27c8033f6d4.png?imageMogr2/auto-orient/strip|imageView2/2/w/267/format/webp)

在我们编写程序源代码的时候，计算机系统其实为我们完成了源码与 ascii码的一一对应



![img](https://upload-images.jianshu.io/upload_images/3010486-500d05bb226665bd.png?imageMogr2/auto-orient/strip|imageView2/2/w/918/format/webp)

其实在计算机系统的内部，所有的信息——包括磁盘文件、程序、以及网络中的数据都是由一串位表示的，区分不同信息的关键在于对于这些内容如何解释，就比如同样的一串01010101，可以解释成：整数、浮点数甚至指令。

**2.编译系统**



![img](https://upload-images.jianshu.io/upload_images/3010486-886cce1b35696eaf.png?imageMogr2/auto-orient/strip|imageView2/2/w/622/format/webp)

预处理－编译器－汇编器－链接器

这里简单讲解了从源程序：hello.c到可执行文件到四个阶段。每个阶段完成的工作和对应生成文件。

1］预处理的工作比较简单：对应的就是展开＃include中的.h头文件；

2］编译器其实包含了一个**汇编语言程序**，讲程序语言转化成汇编语言；

3］汇编阶段：生成可重定位的.o二进制目标文件，这一步完成汇编语言转机器指令；

4］链接阶段：合并许多的.o文件，主要是我们在源程序中用到过的如：printf.o

**3.高速缓存**





![img](https://upload-images.jianshu.io/upload_images/3010486-cd3e4810333392e5.png?imageMogr2/auto-orient/strip|imageView2/2/w/570/format/webp)

产生原因是：程序需要大量复制信息

举一个例子来讲述我们为什么需要高速缓存技术：“我们在月球上建立了一间厨房，可以做出许多美味的食物。由于月球离地球的距离太遥远，我们要炒一个番茄炒蛋，需要大老远大从地球上通过宇宙飞船运输过去，而厨师真正开始炒菜需要的时间并不多。如果这样来回的运输食材，厨师大部分时间上空闲的在等待食材，这对高薪聘请的厨师来说，实在是太浪费了。有没有什么办法能够加快厨师做菜的速度呢？在这个例子中厨师就相当于cpu，而食材就相当于数据，而解决方案就是：高速缓存”

我们先来看看没用高速缓存中一个程序的运行干了什么：





![img](https://upload-images.jianshu.io/upload_images/3010486-5c89f1ca07af043b.png?imageMogr2/auto-orient/strip|imageView2/2/w/707/format/webp)

从程序的加载执行到最后显示结果：大量到复制信息

当我们从外壳执行hello程序的时候，首先是将程序的数据和代码**从磁盘复制到主存**，处理器开始执行指令，并将需要显示的数据**从主存复制到寄存器**中，最后需要显示是**将寄存器的数据复制到显示设备**，最终显示出来的。这些复制操作就是开销，减缓了程序真正的工作。因此就需要高速缓存技术：暂时集结区域。

我们来看看高速缓存存储器的位置：





![img](https://upload-images.jianshu.io/upload_images/3010486-bf38e155ba4e12ef.png?imageMogr2/auto-orient/strip|imageView2/2/w/776/format/webp)

高速缓存存储器

由于机械原理，访问速度越快的存储设备造价相对越高，拿硬盘和主存来说。硬盘的造价可能是主存的1000倍，但是访问的开销却要比主存大10000000倍。高速缓存就是为了存放可能经常访问到的数据，这就大大提高了访问的速度，减小了开销。

主要思想是：**一层上的存储器作为低一层存储器的高速缓存**





![img](https://upload-images.jianshu.io/upload_images/3010486-03b782596f248726.png?imageMogr2/auto-orient/strip|imageView2/2/w/795/format/webp)

**4.操作系统**





![img](https://upload-images.jianshu.io/upload_images/3010486-d0f27e35de0e5bac.png?imageMogr2/auto-orient/strip|imageView2/2/w/832/format/webp)

操作系统是软硬件之间的抽象

操作系统提供了软件与硬件之间的一层抽象，既可以防止程序滥用硬件也方便了我们对于程序的编写。这里的抽象主要是指：1］对运行中程序的抽象（进程）；2］对于存储器的抽象（虚拟存储器）；3］对输入输出的抽象（文件）甚至包括网络；4］虚拟机等。

这里的很多内容都是简单的提了一下，后续章节中还有详细的讲解。

漫游至此，对于本书要讲解的内容有了大概的了解，本书的出发点是很好的，正如《圣经》[约翰福音](https://link.jianshu.com/?t=https://www.baidu.com/s?wd=%E7%BA%A6%E7%BF%B0%E7%A6%8F%E9%9F%B3&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1dWPHf3mW-BmyndnW6zm1wW0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnW0dP1D1rjDs)中说的一样：你们必晓得真理，真理必叫你们得以自由。

# 《深入理解计算机系统》| 信息的表示和处理

![img](https://upload.jianshu.io/users/upload_avatars/3010486/d9eee8450714.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[唐鱼的学习探索](https://www.jianshu.com/u/0129e34fa381)关注

0.1422016.10.10 17:52:52字数 6,744阅读 1,462

####  



![img](https://upload-images.jianshu.io/upload_images/3010486-823554809fb06457.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/600/format/webp)

本章目录

#### **[学习信息的存储（编码）和处理有什么用？]**

研究数字在计算机中是如何存储的，以及值的范围和算术属性，有助于我们跨越不同的机器、系统以及编译器获得更好的可移植性。了解这些细节非常重要，程序员有责任和义务编写健壮的程序，了解其内部如何工作，其不良行为背后的原因，对于安全领域也有非常高的价值。

#### **[本章是如何展开的？]**

本章首先对计算机是如何存储信息（编码）进行了讨论，中间涉及了二进制、十六进制数据的表示、大小以及如何顺序存储、布尔运算等，然后研究了三种重要的编码方式：无符号、补码（有符号）以及浮点数的编码。

#### **[主要笔记]** 

#### **一、信息的存储：编码**





![img](https://upload-images.jianshu.io/upload_images/3010486-9a6a6156cec80a6f.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/380/format/webp)

已字节为最小寻址单元进行数据的存储

单个的位没啥用处，当把位组合在一起（字节8个位），再进行某种解释，赋予不同的含义，我们就能表示世间万物了。每个程序都可以简单的视为一个字节块，程序本身就是一个字节序列。

**1.十六进制**

由于二进制信息太过冗长，于是在描述位模式的时候不是很方便，就发明了16进制。这里没什么好说的了，如下表：



![img](https://upload-images.jianshu.io/upload_images/3010486-a6525b870fdf83e0.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/816/format/webp)

16进制表示法

❤：学习过计算机的同学对这个内容都不陌生，关于各个进制之间的转换作者让我们记住：A C F对应的十进制，然后推出BDE的值：



![img](https://upload-images.jianshu.io/upload_images/3010486-14fb871105d749d6.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/241/format/webp)

记住这三个值

还有一个简单的计算诸如：



![img](https://upload-images.jianshu.io/upload_images/3010486-ed4bd7c9f84437a1.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/111/format/webp)

可以写成幂次方

可以使用公式：n = i + 4j 其中n = 11 ；i的取值范围是[0-3]对应的值为：0对应1,1对应2,2对应4,3对应8相当于2的i次幂，j就代表多少个0。回到上面的例子中，11 = 3 + 4 X 2 就可以写成0X800  (j=2两个0，i=3对应8)。算是奇技淫巧吧，了解一下就可以了。

对于16进制和10进制的相互转化就无非是反复乘以或者除以16，也没啥好说的了。

**2.字**



![img](https://upload-images.jianshu.io/upload_images/3010486-9d2a5fc512829bfb.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/363/format/webp)

虚拟地址空间是一个非常大的字节数组

我们前面说过虚拟地址空间可以使得我们很方便的范围到每个字节，但是虚拟地址是以一个字来进行编码的，所以字的长度就决定了我们能范围的最大范围。对于我们使用的32位的计算机而言，程序最多范围2的32次方个数据，也就是我们经常所说的4GB

**3.数据大小**



![img](https://upload-images.jianshu.io/upload_images/3010486-9b2dbb92a2b534ca.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/611/format/webp)

C语言中的数据类型 字节数

关注数据大小的原因是使得程序对于不同数据类型的大小不敏感，*如果我们用一个int类型（4字节）来存一个指针（64位下可能是8字节）就会带来不小的麻烦。*

**4.寻址和字节顺序**

对于跨越多个字节的数据、指令和控制信息，我们必须要知道他的地址是什么，以及是按照什么顺序在计算机中存储的。对于同样的一个数字：1234567；有两种存储方法：





![img](https://upload-images.jianshu.io/upload_images/3010486-6bc9df617718b329.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/559/format/webp)

大端法和小端法存储

就数据1234567来说，它跨越了4个字节，从0x100开始到0x103结束，我们除了必须要知道开始的地址0x100外，还有一个重要的就是必须要了解是何种顺序在计算机中存储的。就具体的应用来说，至少有下面三个方面：

①通过网络在不同机器以及系统中传递数据时，必须要遵守建立的字节顺序；

②强制类型转换：不会改变真实指针，只是告诉编译器以新的类型来解释数据；

③阅读表示整数的数据类型时（不是很理解）

**5.字符串：文本数据比二进制数据有更强的平台独立性**

字符串是以null（0）字符结尾的字符数组，在任何系统上面都能看到相识的结果。但二进制机器码就不一样了：



![img](https://upload-images.jianshu.io/upload_images/3010486-ead3d8738ee65ae2.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/263/format/webp)

c语言代码

编译成不同的机器码的结果如下：



![img](https://upload-images.jianshu.io/upload_images/3010486-78230c3bf13515bf.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/476/format/webp)

不同系统的生成的二进制码

因此：二进制代码是不兼容的，从机器的角度来看，程序仅仅只是字节序列。

**6.布尔运算**

关于布尔运算的基本的方法与、或、非、异或就不在叙述了。除了判断逻辑以外讲讲有什么用：

**掩码运算：**举一个例子，我们要用守蒙住脸蛋防止别人看到我们的脸，但是我们又很想看看对方长啥样子，这时候就会留一个缝隙，让眼睛可以往外边看。这基本上就是掩码的功能了。我们有选择的屏蔽了一些信号，如长相。又如：0xFF（1111 1111）任何一个数与上0xFF，就能将最低的8位保留下来。

**位运算与逻辑运算的区别：**逻辑运算认为非0就是true，而0表示false；逻辑运算如果第一个表达式能确定结果就不会对第二个求值。

移位运算：



![img](https://upload-images.jianshu.io/upload_images/3010486-c3a4c5ccf73f7d0a.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/853/format/webp)

两种移动方式

❤ 对于无符号的数，右移动必须是逻辑上的。对于有符号的数，可以是任何一种，但常用的是算术右移动

#### **二、整数的表示（存储）**

>    本节首先介绍了两种编码方式，一种只能表示非负数（无符号编码），另外一种可以表示负数、0和正数（补码编码），然后讨论了这两组编码的数学属性和机器实现，最后对于一个已知编码的扩展和收缩的方法进行了介绍

C语言支持的数据取值范围：



![img](https://upload-images.jianshu.io/upload_images/3010486-d5fe44d453d116b9.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/689/format/webp)

c语言的整型数据保证的取值范围

我们将介绍这些具体的取值范围是如何得来的，以及之间转换所遵循的规则，不知道大家有没有注意到一点：有符号数的范围并不对称，负数的范围比正数大1？我们接下来的内容会告诉大家原因

**1. 无符号数的编码**

我们来探究一个公式，完成二进制到无符号数的编码（Binary to Unsigned）我们编号为（2.1）:



![img](https://upload-images.jianshu.io/upload_images/3010486-6aec6716635481d3.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/463/format/webp)

Binary to Unsigned

用几个例子和一幅图帮助大家理解：



![img](https://upload-images.jianshu.io/upload_images/3010486-5d3f11b61f221aab.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/671/format/webp)

各位相加求和

这是对w=4位的几个数字的无符号数的编码，很好理解，就是各个位具体的值和每个位的权值相加，用如下的图来表示就更更清楚了：



![img](https://upload-images.jianshu.io/upload_images/3010486-d198077253aa1a3b.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/464/format/webp)

用长度为2的I次方表示向量x的长度

在无符号的表示中，统一都用的是向右向量来表示，各个位的权长度不一样，最高的是8最低的是1。我们来看看表示的范围是多少：从最小的无符号数[0000]到最大的无符号数[1111]范围就是0-15（最大值为2的w次方-1）。

**2.有符号数补码的编码（Binary to Two's-complement）：**



![img](https://upload-images.jianshu.io/upload_images/3010486-76bc64247ce8ad47.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/501/format/webp)

补码编码公式

用实际的例子表示为：



![img](https://upload-images.jianshu.io/upload_images/3010486-553c31dc3642cf1b.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/706/format/webp)

最高位为符号位

最高位为符号位，当为0的时候没什么影响，为1的时候加的就是负权了，如下图：



![img](https://upload-images.jianshu.io/upload_images/3010486-570b1badac2a8913.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/504/format/webp)

最高位用灰色表示为符号位，向量向左

**我们来看看不对称性的根源？**

这种对称性是由于一半的位模式（符号位设置为1）表示负数，而另外一半的位模式（符号位设置为0）表示非负数，因为0是非负数，也就意味着能表示的正数比负数要少一个。

同样来讨论一下取值范围，最小的负数TMin为[1000]结果为-8，最大的正数TMax[0111]结果为7，我们看得出来|TMin| = |TMax| + 1，最小的负数TMin没有与之对应的+8，这种不对称的特殊性，正是由于0也是非负数，所以-8就没有与之对应了正数值了。

另外，有符号数还有其他两种表示方法：反码和原码，由于运用的非常少，大多数机器都采用的是补码的方式，我们就不再研究了。

**3.有符号与无符号数的转换：**

> 类型转换的结果是保存位值不变，只是改变了解释这些位的方式

从存数学的角度考虑，我们能想到的规则是：首先对于两者之间的交集，我们保持不变；其次，对于超出范围的值，比如将最大的负数（前文中说的-8无对应的情况）转换成无符号可能会得到0，将无符号的数（太大的部分）转换为有符号的数可能会得到TMax，举个例子：

以w=4位为例：有符号数能表示的范围是：[-8--7] 包含两端的-8和7而无符号的表示范围是 ：[0--15] 这样，当我们在[0-7]之间的数的进行转换的时候将保持不变；而在进行诸如：无符号数[8-15]转有符号数的时候就只能用TMax表示；有符号数[1111]=-1转到无符号数就变成了[1111]=15。注意看下面这个图：



![img](https://upload-images.jianshu.io/upload_images/3010486-2af4a03d0e8301dc.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/811/format/webp)

12345和-12345的补码表示，以及53191的无符号数表示

-12345同53191有同样的位表示，到这里我们就明白了，在计算机内部的实现方式是：

**规则：数值可能会改变，但位的模式不变。**

从数学角度来讨论这个规则：

我们定义B2U（）的逆运算为U2B（）；定义B2T（）的逆运算为T2B（）；

那么完成U2T（）的转换就相当于：

*等式一：U2T（） = B2T（U2B（））*

解释一下就是，先完成无符号到二进制的转换U2B，然后在将二进制转换层有符号数B2T

同样的道理完成T2U（）的转换就相当于：

*等式二：T2U（） = B2U（T2B（））*

我们先来看看U2T（无符号转有符号）之间的转换公式的推导过程：

**假设w=4位**

①无符号数B2U计算公式：[1111] = 1 * 8 + 1 * 4 + 1* 2 +1 = 15

②有符号数B2T计算公式：[1111] = -1 * 8 + 1 * 4 + 1 * 2 + 1 = -1

用①-② 也就是B2U（）-B2T（） 后面的内容1 * 4 + 1 * 2 + 1可以抵消掉，其实就是头两个数之间的差值：

B2U（）- B2T（） =  1 * 8 + 1 * 8 = 1 * （8 + 8）= 1*16  

❤ 也就是1 乘以2的4次方，写成公式为：



![img](https://upload-images.jianshu.io/upload_images/3010486-6987d4a0bea0569e.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/270/format/webp)

**有符号数转无符号数：**

令x = T2B（x），带入上述公式转换的结果为：



![img](https://upload-images.jianshu.io/upload_images/3010486-46e7ba8228e2f00b.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/439/format/webp)

由于B2U(T2B) = T2U;B2T(T2B)=x。所以上面的等式可以写成如下形式：



![img](https://upload-images.jianshu.io/upload_images/3010486-f0c4e489ff837ec8.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/391/format/webp)

这个公式由于x的最高位w-1位的属性，又决定了以下两种形式，得到：



![img](https://upload-images.jianshu.io/upload_images/3010486-a9d4cf385a6e7494.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/295/format/webp)

w-1位为0的话，值就是x

进一步解释一下就是，以w=4位为例，[0001]-[0111]之间的有符号数转无符号数其值是不变的。如果无符号数[1001]-[1111]之间的数由于最高位有值，那么结果就会加上2的w次方。比如：将-5 = [1011]转换为无符号数就是：11 （-5+16），而-1就变成了15.如下图看到的



![img](https://upload-images.jianshu.io/upload_images/3010486-7497c4b24e7a7779.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/662/format/webp)

符号位为向左的灰色箭头表示

而T2U的一般行为就是，非负数保持不变，而负数就变成了大的正数



![img](https://upload-images.jianshu.io/upload_images/3010486-380a0d0bd9081353.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/429/format/webp)

负数就变成大的正数

至此我们探究了T2U的转换内幕，以及其行为，下面我们来看看U2T是如何工作的

无符号数转有符号数：

将x = U2B(x)带入标❤公式：我们得到



![img](https://upload-images.jianshu.io/upload_images/3010486-455d8c0273838f90.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/451/format/webp)

简单带入变形

我们将上面的等式整合一下，得到了U2T的公式为：



![img](https://upload-images.jianshu.io/upload_images/3010486-1a7bed75a20d9c13.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/196/format/webp)

综合公式

根据无符号位w-1时候大于或者等于2的w-1次方，我们将上个公式可以写成下面这种形式：



![img](https://upload-images.jianshu.io/upload_images/3010486-1135c6193b020222.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/261/format/webp)

无符号转有符号数公式

同样的我们以w=4位为例，完成对[0-7]转有符号数的时候，保持本身值不变。而如果是对于≥8的数转换为有符号数，[1001]-[1111]之间的数，由于最高位要解释成符号位，所以结果会减去2的w次方。也就是上述公式所显示的内容，将无符号数[1001]=9转换为有符号数为[1001] = -7 = 9 - 16.



![img](https://upload-images.jianshu.io/upload_images/3010486-e5cfbfb2d8326900.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/416/format/webp)

将大于8的数转化为负值

**4.C语言中的有符号数与无符号数**

C当然没有指定有符号数用什么编码方式，但是各个机器基本上都是使用补码的形式表示。所以，如果要创建一个无符号数常量，那么就必须要申明加入后缀‘U’或者'u'的形式。

特别是类型转换中的隐形转换，笔录表达式赋值给另外的一个变量，就容易被忽略，很难发现错误之处。其实一个为了避免出错，最好的一个做法就是**尽量不使用无符号数。**

（另外提一下，**无符号数有什么用处：**当我们想把字仅仅当做位的集合来看，没有任何数字意义的时候，无符号数还是非常有用的。例如：往字中放入描述各种布尔条件的标记时，就形成了地址，而地址当然是能访问的越多越好）

C语言中的转换规则，如果执行一个运算，它的一个运算符是有符号另外一个无符号，那么C就会隐式的件有符号的参数强制类型转换为无符号数，并假设这两个都是非负数来进行计算。这里特别需要**注意的就是像＞或者＜结果可能出错。**

如比较：-1  < 0U的值时，先将-1转无符号数：4294967295  < 0U 就有问题了。

我们来说说为什么-1转有符号的数会是一个这么大的数，

同样的以w=4位为例：-1 = [1111] 转换为无符号数，由于保持位值不变，只是改变解释那么无符号数[1111] = 15 也就是能表示的最大值，4294957595是采用补码的32位机器所表示的最大无符号数。

**5.对数字的位进行扩展与截断的技术**

**①扩展一个数字的位：**

这里在一个程序中应用的特别多，比如将一个short类型的数据转换为int，或者将unsigned short 转为unsigned int 这种数字长度的增加，到底是依据如何的规则进行的转换，大致说来有两种扩展方式：零扩展和符号扩展：

1>（零扩展）无符号转更大数据：在数据的开头位添加0即可

2>（符号扩展）有符号转更大数据：在数据的开头添加最高位的副本

零扩展不用说会保持数值不变，我们来研究一下符号扩展：假设字长从3为变成了4，有补码表示的数[101] = -3 将变成[1101] = -3 即使增加了1位结果任然是一样的，是什么原因保证了这种变化保存了数值的不变呢？我们来探究一下：



![img](https://upload-images.jianshu.io/upload_images/3010486-6da27df3babe8878.png?imageMogr2/auto-orient/strip|imageView2/2/w/449/format/webp)

从3位增加到4位

这里有一个关键属性就是：就是上图所示的，当我们做最开始的两位的加法的时候，其结果与上一等式的第一个数的值相同。



![img](https://upload-images.jianshu.io/upload_images/3010486-2fa799f114567ae0.png?imageMogr2/auto-orient/strip|imageView2/2/w/443/format/webp)

从3位扩展到4位



![img](https://upload-images.jianshu.io/upload_images/3010486-eafa506bce5d7e16.png?imageMogr2/auto-orient/strip|imageView2/2/w/294/format/webp)

前两位的折返与原数相同

用更普遍的观点来看，关键的属性就是：



![img](https://upload-images.jianshu.io/upload_images/3010486-dd879e0145f6bdef.png?imageMogr2/auto-orient/strip|imageView2/2/w/153/format/webp)

结果会保留原始的值

另外要提一下，将一个数据大小改变，和无符号有符号之间这两组转换的相对顺序，会影响一个程序的行为。如果将short转为unsigned时，**就会先改变大小，然后再完成有符号到无符号的转变。**如：short sx = -12345 转为 unsigend的uy时，先将0X CF C7扩展成0X FF FF CF C7然后再进行到无符号数的解释，结果就得到了4294954951这样的一个数字。

**②截断一个数字的位：**

对于无符号的数：[1111] = 15 截断1位，其实是将15 mod 8（2的3次方） = 7 [111]

对于有符号数：[1101] = -3 的截断，是先将[1101]转为无符号的13然后来mod 8 = 5无符号表示就是[101]，然后再把[101]解释成有符号数[101] = -3  

**6.注意事项：**

1> 尽量避免使用无符号数

2> 特别留意隐藏的强制类型转换行为

#### 三、整型的运算（相当于mod运算）

我们首先要来理解一下“字节膨胀”的概念：

比如我们以w＝4位为例，进行无符号数[1111]＝15和无1.符号数［1010］＝10的加法运算，结果为25=［11001］需要5位来表示结果，依次类推我们如果要完整的表示运算结果，就不能对字长做任何限制。大部分编程语言都选择了固定精度的加减乘除运算，会对结果进行一定的处理。也就与我们数学上的运算有所不同，这一节我们就来学习这些处理方法。

首先来看看加法运算：我们会接触到［无符号的加法］和［补码的加法］。这两组加法运算使用的是相同的机器指令

**1.无符号数的加法：**



![img](https://upload-images.jianshu.io/upload_images/3010486-81e810c8776a2f84.png?imageMogr2/auto-orient/strip|imageView2/2/w/576/format/webp)

相当于截断高位

溢出的真正含义就是：完整的结果不能放入到固定精度的字长中去，于是最高位就被丢弃掉了。减去2的w次方，相当于结果mod（2的w次方）。

⚠️ 如何判断是否溢出？

运行c程序的时候，溢出并不认为是一种错误。那么我们自己如何判断是否发生了溢出呢？我们可以设s＝x＋y，当结果s < x或者s < y的时候发生了溢出。（证明如下：前面我们2.11的第二种情况下有溢出，我们确定的是y<2的w次方，那么y－2dw就<0。两边加上x，结果就是x＋y－2dw < x发生了溢出）

**2.补码的加法：**



![img](https://upload-images.jianshu.io/upload_images/3010486-d03e1b9c01d12b4c.png?imageMogr2/auto-orient/strip|imageView2/2/w/665/format/webp)

正溢出产生负数，负溢出产生正数

为什么会有“**正溢出产生负数，负溢出产生正数**”？



![img](https://upload-images.jianshu.io/upload_images/3010486-99860a28e11837c1.png?imageMogr2/auto-orient/strip|imageView2/2/w/350/format/webp)

正溢出减去了2的w次方，负溢出加上了2的w次方

举例说明： 

​    正溢出［0101］ ＋［0101］ ＝ 5 ＋ 5 ＝ 10 ＝ ［01010］截断最高位0结果为[1010]=-6;

​    负溢出 ［1000］＋ ［1011］＝ －8 ＋ －5 ＝ －13 ＝ ［10011］截断高位1结果为[0011]=3.

主要的原因还是我们使用的是固定精度的运算，由于结果不能被完整的保存，我们就需要使用截断高位保存低位的方法。这样做由于正溢出是两个大正数相加，完整的结果仍然数正数，截断最高位相当于减少了2的w次方；而负溢出数两个大负数相加，完整的结果仍然数负数，截断高位1以后相当于加上了2的w次方。

**3.补码的非**



![img](https://upload-images.jianshu.io/upload_images/3010486-7f5361278c861d88.png?imageMogr2/auto-orient/strip|imageView2/2/w/514/format/webp)

设置不能表示的数的不骂为它本身

以w=4位为例，补码的表示范围在[-8，7]之间，也就是说[-7，7]内的数可以表示为-x，但是对于最小的TMin=-8的情况怎么办呢？C语音中求解补码的方法是：每位求反，结果加1.

就如[0101] = 5 每位求反为 [1010] 再加上1为：[1011]补码表示为-5。那么同样的方法计算[1000] = -8的求反[0111]再加上1的结果还是[1000] = -8我们就认为的定义了：-8的非就是-8，也就是上个算式中显示的内容了。

**4.无符号乘法和补码的乘法（使用相同的机器指令）**

无符号的乘法：我们知道如果是w位的两个数相乘，结果最大可能是2w位，C语音中仍然使用的是固定精度的运算，这就导致了结果只能截断到w位，只保留真实值的低w位。计算公式为：



![img](https://upload-images.jianshu.io/upload_images/3010486-741959b252e1be7e.png?imageMogr2/auto-orient/strip|imageView2/2/w/573/format/webp)

截断高w位相当于mod（2w次方）

补码的乘法：使用的是同无符号数相同的机器指令，并且在低位是相同的



![img](https://upload-images.jianshu.io/upload_images/3010486-7dffe8caba6c1907.png?imageMogr2/auto-orient/strip|imageView2/2/w/713/format/webp)

相同位表示的不同数，其乘法运算结果的低w位是一样的

公式表示为：



![img](https://upload-images.jianshu.io/upload_images/3010486-e1a14b32bfc595bc.png?imageMogr2/auto-orient/strip|imageView2/2/w/506/format/webp)

乘积截断高4位后转补码表示

关于低w位相同的证明其实很简单：



![img](https://upload-images.jianshu.io/upload_images/3010486-485c5782372b51d8.png?imageMogr2/auto-orient/strip|imageView2/2/w/683/format/webp)

其中x”代表的无符号的值

由于结果中带有2的w次方的同mod2的w次方会丢弃掉。因此我们看到了，mod2的w次方留下的就是低w位，结果同无符号数是一样的。

**5.乘以常数（左移）**

乘法运算太慢了，需要10个时钟周期，于是编译器就使用移位和加法指令来替代乘以常数。

如：x * 14 ：其中 14被分解为：2d3 + 2d2 + 2d1 （其中d代表次方）编译器的写为：(x<<3)+(x<<2)+(x<<1)一些聪明的编译器甚至改写成：(2<<4)  - (2 << 1)这时候只需要两个移位指令和一个减法指令了。

**6.除以2的幂（右移）**

除法指令比乘法更慢，相当于30多个时钟周期，所以当除以2的幂的时候经常用右移来代替。

无符号数：逻辑右移动（左边空出来的位补0）

补码：算数右移（左边补出来的数加最高位的值）

舍入的方法：整数的除法是舍入到0的，其中对于负数的除法结果是向下舍入，如-7/2不是-3而是-4，这样做其实是使用的一种偏置值的方法。[X/Y] = [(X+Y-1)/Y]也就是原本是-30/4]=7.5却变成了[-27/4]=6.75向下舍入到-7

**7.整数运算总结**

整数运算不论是加减乘除，其本身来说就是一种mod运算。由于结果的固定精度，大的就可能会溢出。补码和无符号数使用的是相同的机器运算指令，有相同的位级表示。特别是无符号数的一些意向不到的行为，程序员特别需要注意。

#### 四、浮点数

**1.IEEE浮点表示标准：**



![img](https://upload-images.jianshu.io/upload_images/3010486-7c7a28ec7652b62f.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/185/format/webp)

s符号，m尾数，e阶码

**说明：**

符号（S）：当s=1为负数，当s=0为正数；

尾数（M）：表示从（1~2）或者（0~1）之间的数；

阶码（E）：可以是负数

**单精度和双精度的表示：**



![img](https://upload-images.jianshu.io/upload_images/3010486-527506e9f396f24c.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/882/format/webp)

M为23或者52位，E为8或者11位

① 规格化值 E ≠ 0 或者 E ≠ 255 （E不全为0或者1）

​     阶码段被解释成有偏置值形式的有符号整数：E = e - Bias （其中Bias = 2的k-1次方 - 1 ；以8位为例就是127，11位为例为2047）。

​     M尾数定义为1+f 也就是隐含了已1开头，多表示了1位。

② 非规格化值：（E全为0时）

​     上一个方法中如何来表示0呢，非规格化就是在表示非常接近于0和0的数

​     M = f 

​     E = 1 - Bias

③ 特殊值（E全为1时）

a.当M=0时得到无穷大s=0是正无穷大，s=1时是负无穷大；

b.当M≠0时得到了Not a Number（NAN）

**应用举例：以w=6位为例** 



![img](https://upload-images.jianshu.io/upload_images/3010486-1729904523928dec.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/295/format/webp)

s1位，E有3位，M有2位

我们尝试来表示最大的规格化数字：（E不全为0或者1）

合成6位的表示就是[0] [110] [11]也就是：011011；

解释一下：

S = 0  结果为 +     偏置值为 3 

那么E不全为1，能表示的最大值就是[110]表示为：E = 6-3 = 3

M最大为[11]也就是3/4由于M = 1 + f 所以结果为 7 / 4

**那么最后的计算就是：+1 \* 8 \* （7/4）= 14**

如果以8位为例，我们看图就很好理解了】



![img](https://upload-images.jianshu.io/upload_images/3010486-fc0eb2c5e08607b5.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/904/format/webp)

8位浮点表示的非负数值

**主要解释一下过渡阶段：**



![img](https://upload-images.jianshu.io/upload_images/3010486-51e9fd54a2c0886a.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/866/format/webp)

平滑过渡

非规格化偏置被设置成1-Bias，而不是-Bias。我们其实是补偿非规格化的尾数没有隐含的1开头这一事实，这样7/512和8/512就实现了平滑的过渡。

我们来练习一下将整数12345二进制表示为[11000000111001]转化为单精度浮点表示，将二进制左移13位表示为1.1000000111001 X 2的13次方。为了适应IEEE规格化表示，我们表示尾数M时丢弃掉最高位1，并在末尾增加10个0.M = [1000000111001 0000000000]。为了构造阶码字段我们用13+127 = 140 二进制表示为[10001100]再加上一个符号位0我们的最后结果就是[01000110010000001110010000000000]我们观察12345（0X3039）同浮点数12345.0（0X4640e400）的位级表示：



![img](https://upload-images.jianshu.io/upload_images/3010486-511324a1f8a471d8.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/491/format/webp)

我们看到尾数M同0x3039正好是相差最高位1

这样的存储结果，加*的上下两段其实是一样的。看起来完全不同的位级表示，其实有其内在的相同点。

**2. 舍入**



![img](https://upload-images.jianshu.io/upload_images/3010486-f3c6bdc77ea27fa8.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/863/format/webp)

以美元为例的4种不同的舍入方法

计算机使用的是向偶数舍入的方法，为了避免统计上的误差，在一半的时间向下舍入，另一半的时间向上舍入。

**3.浮点数的数学属性**

由于舍入而产生的丢失精度，浮点数的运算中不具有结合性

C语言中的浮点数使用注意事项：



![img](https://upload-images.jianshu.io/upload_images/3010486-b10cf46f473ef34e.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/821/format/webp)



【词汇】

  程序对象：学习过汇编的同学应该不难理解，有点儿像程序的数据段、代码段，即是：程序数据、指令和控制信息；

# 深入理解计算机系统》| 程序的机器级表示

![img](https://upload.jianshu.io/users/upload_avatars/3010486/d9eee8450714.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[唐鱼的学习探索](https://www.jianshu.com/u/0129e34fa381)关注

0.4032016.10.30 23:23:14字数 3,502阅读 2,285



![img](https://upload-images.jianshu.io/upload_images/3010486-edc8e2594223c0a3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1054/format/webp)

目  录

**精通细节是理解更深和更基本概念的先决条件，**这一章节首先讲解了C代码、汇编代码与机器代码的关系，再次重申了汇编的承上启下的重要作用。接着从IA32的细节一步步讲起，如何存储数据、如何访问数据、如何完成运算、如何进行跳转，在了解了这些细节以后告诉你我们常用的分支语句、循环语句是怎么完成了。在如何调用函数的部分，花费的篇幅较大，详细的讲解了栈帧结构，也让我们更好的了解了递归的过程。（其他方面还对数组、结构、联合有所讲解，难度不大）通过对编译器产生的汇编代码表示，我们了解了编译器和它的优化能力，知道了编译器为我们完成了哪些工作。

#### **[本章内容]** 

※c语言、汇编代码以及机器代码之间的关系；

※介绍IA32的细节；

※讲解过程的实现，包括如何维护运行栈来支持过程间数据和控制传递；

※理解存储器访问越界问题，以及缓冲区溢出攻击问题；

※IA32扩展到64位（x86-64）

#### **[笔记]**

#### **一、c语言代码、汇编代码、机器代码之间的关系**

在第一章开始的部分我们就已经讲解过这三者的关系大概顺序是：1]C预处理器扩展源代码，展开所以的#include命名的指定文件；2]编译器产生汇编代码（.s）；3]汇编器将汇编代码转化成二进制目标文件（.o）.二进制目标文件是很难阅读懂的，我们使用imac下的otool工具翻译如下：



![img](https://upload-images.jianshu.io/upload_images/3010486-380ffb52a6931bf0.png?imageMogr2/auto-orient/strip|imageView2/2/w/1179/format/webp)

图1：从左到右分别是：c语言源码、汇编源码和机器目标代码



![img](https://upload-images.jianshu.io/upload_images/3010486-550a83093832b111.png?imageMogr2/auto-orient/strip|imageView2/2/w/389/format/webp)

图2：使用命令：tool -tV

我们从图1中可以看出，汇编代码起到了承上启下的作用，目前已经不再要求程序员手写汇编代码，但是理解汇编代码以及与它的源C代码之间的联系，是理解程序如何执行的关键一步，因为编译器隐藏了太多的细节如：程序计数器、寄存器（整数、条件码、浮点）等。

#### **二、IA32指令的细节**

**1）区分字节与字：**Intel使用术语“字”表示16位数据类型而“字节”代表的是8个位的数据。如果不习惯理解的话，可以做一个比喻“字节”相当于“字截”所以少了被截断了的嘛

**2）访问信息**



![img](https://upload-images.jianshu.io/upload_images/3010486-517f9a3e67b3ae80.png?imageMogr2/auto-orient/strip|imageView2/2/w/358/format/webp)

前4个寄存器可以独立访问低位字节

传送指令：move  源－－> 目的地（两个操作数不能同时指向存储器，需要寄存器周转）

指针：就是地址，间接引用指针就是将指针放入一个寄存器中，然后在存储器中使用这个寄存器

**栈数据的基本理解：**



![img](https://upload-images.jianshu.io/upload_images/3010486-0e57996a36e31503.png?imageMogr2/auto-orient/strip|imageView2/2/w/529/format/webp)

地址向上增大，push向下压栈

push指令相当于：sub $4, %esp 然后move %ebp, (%esp)

pop指令相当于：move （%esp）, %eax 然后 add $4, %esp

栈的数据结构是向低地址方向增长的，无论如何esp都是指向栈顶顶

**3）算数和逻辑操作**

其实讲的就是加减乘除、与或非这一系列的指令：



![img](https://upload-images.jianshu.io/upload_images/3010486-3d1afc700946ee2d.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/332/format/webp)

加载有效地址指令：leal S, D ==>  (&S-->D) 将有效地址写入到目的操作数中去

汇编代码与C语言源码中的顺序可能不同：



![img](https://upload-images.jianshu.io/upload_images/3010486-5f22ae972c9e1c6e.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/873/format/webp)

leal和sall组合实现了z*48

**4）改变执行顺序**

**a.机器机制**

我们这里用到的是条件码寄存器，常见的有：



![img](https://upload-images.jianshu.io/upload_images/3010486-a81b9647dda8047e.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/742/format/webp)

4个常用的条件码寄存器

可以通过cmp和test设置条件码寄存器：



![img](https://upload-images.jianshu.io/upload_images/3010486-5440d5296a93f21f.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/481/format/webp)

比较和测试 只修改条件码寄存器

通过set指令访问条件码，用处是设置值 or 跳转 or 传送数据：



![img](https://upload-images.jianshu.io/upload_images/3010486-b8bd4f8555b5745f.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/698/format/webp)

注：set指令后缀是表示不同的操作数

**跳转指令（对于理解链接非常重要）：**



![img](https://upload-images.jianshu.io/upload_images/3010486-528740ef233e65db.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/692/format/webp)

根据条件的不同进行条件，用于改变程序的执行顺序

​                          直接跳转用：‘.’                                                间接跳转用：'*'

**理解跳转指令的目标编码：**



![img](https://upload-images.jianshu.io/upload_images/3010486-bdecec04f02d250c.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/765/format/webp)

0xd并不是目标地址，而是0xd+0xa

jle跳转指令中的0d并不是目标地址，而真正的地址是通过计算0d+0a来确定的，这样做的优点是：通过使用与机器相关目标使得代码简洁，可以使目标代码移到存储器中而不是简单的地址，执行的是程序计数器与目标代码的加法。

**b 翻译条件分支**

通过将C代码翻译成不良好的goto语句可以方便我们理解汇编代码的执行方式。**汇编程序通过条件测试和跳转来实现循环，**我们常见的循环语句其实都是翻译成了do-while形式的：



![img](https://upload-images.jianshu.io/upload_images/3010486-34d60f3ed028f1f3.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/600/format/webp)

do-while循环

while循环会先转成do-while形式：



![img](https://upload-images.jianshu.io/upload_images/3010486-876c18af44f81e85.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/529/format/webp)

while循环

for循环也是一样的道理，先转成do-while形式：



![img](https://upload-images.jianshu.io/upload_images/3010486-145e5aa70d5bc52d.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/880/format/webp)

for循环

switch语句：使用一个数组作为跳转表



![img](https://upload-images.jianshu.io/upload_images/3010486-c8f4165890d87754.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/511/format/webp)

着重理解跳转的创建与使用

在switch语句的汇编代码中，我们使用的是一个数组jt来表示所以可能的7种情况，使用n-100将范围缩小到了0-6区间。其中102到103中间没有break，桤木的扩展C代码中也巧妙的实现了这样的效果。

c 条件传送指令



![img](https://upload-images.jianshu.io/upload_images/3010486-60ae57f19b756582.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/418/format/webp)

先计算出可能的多种不同结果

如条件语句：x < y ? y-x : x-y ; 就会先计算两种结果y-x和x-y的值，然后再判断x，y的大小

现代计算机CPU使用流水线方式实现性能的最优化：

> 举个例子，你去一家快餐店点餐，想要吃一个鸡蛋、一碗稀饭和一个包子，如果都是现场马上给你做的话，味道肯定最好，但花费的时间我估计你不会再去吃第二次了。然而真实的情况是，服务员将你的要求传达下去，宾果~~很快的时间就准备好了你需要的食物。这是因为快餐店已经从很早开始就将大家喜欢吃的都做好了，所以的结果（鸡蛋、稀饭、包子）都已经提前准备好了，这时候只需要根据你的需要（x，y的大小）马上就能给你上菜了。

在这个过程中，我们提前处理了一部分指令，如制作包子过程中的和面、包肉、上蒸笼我们成功的预测了90%的人早餐喜欢吃包子。就大大的节约了时间。记住所以的结果都提前准备好了的。

#### 三、如何调用函数

我们如果要调用一个函数，实现将数据和控制代码从一个部分到另一个部分的跳转。我们如何来分配执行函数的变量空间，并在返回的时候释放空间，将返回值返回。用什么样的数据结构实现这一系列的操作：



![img](https://upload-images.jianshu.io/upload_images/3010486-d29d4662e0a4a32b.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/387/format/webp)

单个过程分配一个栈帧结构

**帧指针与栈指针的不公之处：**ebp放与参数与返回地址的最下方，方便计算参数的偏移位置；而esp一直在栈顶，可以通过push将数据压入，通过pop取出，增加指针来释放空间。

**1） 转移控制**



![img](https://upload-images.jianshu.io/upload_images/3010486-c35f7a708dbbf5f4.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/331/format/webp)

常用转移控制指令

其中call先将返回地址入栈，然后跳转到函数开始的地方执行。（返回地址是开始调用者执行call的后面那条指令的地址）当遇到ret指令的时候，弹出返回地址，并跳转到该处继续执行调用者剩余部分。

**2） 寄存器使用惯例**

1] eax edx ecx 调用者保存，可以被调用者使用。

   举个例子：这里的调用者就像很有票子的王健林一样，儿子王思聪可以无偿的使用王健林的票子

2] ebx esi edi 被调用者保存，在使用前被调用者要把这里面的值保存好，用完之后还回去

  举个例子：这里就像有我有一辆豪车，可以把车子借给朋友使用，但是一定要把钥匙保存好，用完了之后还回来

**3）递归的过程**

我们可以理解，递归的调用其实与其他函数的调用是一样的，因为计算机使用的是栈帧结构，为每个单独的调用创建了一个栈帧，每次调用都有私有的状态信息。



![img](https://upload-images.jianshu.io/upload_images/3010486-0512f59d98af84c6.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/665/format/webp)

每个调用都有独立的栈帧结构

#### 五、数组的分配与访问

**1）基本原则**

数组的声明就不用多说了，来看看声明过后数组的具体位置



![img](https://upload-images.jianshu.io/upload_images/3010486-15e76f03a4047e50.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/579/format/webp)

Xa代表的是起始地址

汇编代码使用move指令来简化访问：

movl （%edx ， %ecx， 4）， %eax

假设E是一个int类型的数组，我们要计算E[i]的值，在此，E的地址放于edx中，而i放于ecx中，我们通过上面的指令就完成了Xe + 4i来读取其中的值，放在了eax中去。

**2）指针运算：对指针的运算其实际是按照相应的数据大小进行了伸缩**

point + i = Xp + （数据大小）L * i

如何计算二维数组的大小呢？

我们定义一个int D[5][3]的数组，形如：



![img](https://upload-images.jianshu.io/upload_images/3010486-6d0a194aa2e1436c.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/243/format/webp)

数组D

如果我们要计算D[4，2]的地址，就可以使用

> ​         D[i][j] = Xd + L(C * i + j) = D[0,0] + 4 * (3 * 4 + 2)

由于每组有3个数据，所以跳过一组就要乘以3，跳过4组就12个，再加上偏移的2，就是最后一个数据的地址了。

**3）理解指针：数组与指针关系密切**

①指针用&符号创造、用*符号间接引用

②指针从一个类型 转为另外一个类型，只是伸缩因子变化，不改变它的值

③指针可以指向函数：int （*f）（int *）从f开始由内往外阅读，首先f代表的是一个指向函数的指针，这个函数的参数是int * 返回值是int

#### 六、结构与联合

**1）结构：**所有的组成部分在存储器中连续存放，指向结构的指针指向结构的第一个字节；结构的各个字段的选取是在编译时处理，机器代码不包含字段的声明或字段名字的信息。

**2）联合：**一个联合的总大小等于它最大字段的大小，而指向一个联合的指针，引用的是数据结构的起始位置。应用在：

a.如果两个数据互斥，减少空间；

b.访问不同数据的位模式；



![img](https://upload-images.jianshu.io/upload_images/3010486-dc69a12db4bbba70.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/260/format/webp)

使用不同的位模式访问数据

用有符号数据存储，而返回的确实无符号的数据。特别注意的是，如果用联合将不同大小的数据组合到一起的时候要注意字节的顺序。

**3）数据对齐：**要求某个类型对象的数据地址必须是（2.4.8）的倍数



![img](https://upload-images.jianshu.io/upload_images/3010486-83bd7ed44bf89e8d.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/468/format/webp)

其中的.align 4要求数组开始的位置为4的倍数，由于每单个数据的长度也是4的倍数，也就保证了后续的数据是4的倍数，数据对齐了。这种设计简化了，处理器与存储器之间接口的硬件设计。这种设计，**编译器甚至会在字段中间、后面插入间隙，以保证每个结构满足上述要求**。如下图所示：



![img](https://upload-images.jianshu.io/upload_images/3010486-1e4136cf4a594a24.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/884/format/webp)

结构的中间插入间隙，保证数据对齐

#### 七、存储器越界引用和缓冲区溢出

由于C对于数组不进行边界检查，在栈帧结构中局部变量和状态信息，特别是返回地址也是在栈中存放的，对越界数据的访问和修改将破坏掉这些数据，当ret试图返回的时候，错误的地址（甚至是被修改的恶意目的地地址）会带来严重的安全隐患。



![img](https://upload-images.jianshu.io/upload_images/3010486-6dff16e51e698b01.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/529/format/webp)

越界访问

上图两段代码展示了一个get函数在只有8个字节的空间中，存入了太多的数据，使得栈数据不断被破坏的过程。



![img](https://upload-images.jianshu.io/upload_images/3010486-b234f9285df089e6.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/251/format/webp)

在计算机中存储的 顺序



![img](https://upload-images.jianshu.io/upload_images/3010486-6b5668d433a3599f.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/324/format/webp)

被破坏的过程

常见的攻击方式是覆盖返回地址，使得程序跳转到所插入的恶意代码部分。

**对抗方式：**

**① 栈随机化：**在程序开始时，随机分配一段0-n的空间，使得栈的位置每次运行都不同。栈地址随机化，即使在一台机器上运行同样的程序，地址都是不同的。

**② 栈破坏检测：**插入栈保护者，俗称金丝雀的一段随机大小



![img](https://upload-images.jianshu.io/upload_images/3010486-eaabb3d4a3c64b8c.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/252/format/webp)

在数组buf和保存状态之间放入一个特殊的金丝雀，代码检查该值，确定栈状态是否被改变

**③ 限制可执行代码区域**

#### 八、x86-64：将IA32扩展到64位

**1）数据类型的比较：**



![img](https://upload-images.jianshu.io/upload_images/3010486-34e80453a2b288f4.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/631/format/webp)

指针和长整数是64位

**2）访问信息：**



![img](https://upload-images.jianshu.io/upload_images/3010486-87b059636ddf489a.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/551/format/webp)

callee被调用者保存，caller调用者保存

注：pc相对寻址-立即数+下条指令地址

**3）算术指令：**当大小不同的操作数混在一起的时候，必须进行正确的扩展

**4）控制指令：**增加了cmpq 、testq指令



![img](https://upload-images.jianshu.io/upload_images/3010486-42319a2b535d36ba.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/343/format/webp)

增加cmpq与testq指令

**a 过程**

由于寄存器翻了一倍，64位中不需要栈帧来存储参数，而是直接使用寄存器：





![img](https://upload-images.jianshu.io/upload_images/3010486-5a7d04dd16b873c4.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/758/format/webp)

主要不同的地方



**b 栈帧**

以下原因会使用栈帧结构：



![img](https://upload-images.jianshu.io/upload_images/3010486-ee1c96b683e56126.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/527/format/webp)

**c 寄存器保存惯例：**

被调用者保存：rbx   rbp  12  13  14  15号寄存器

调用者保存： 10 11 号寄存器

**d 数据结构：**严格对齐要求

# 《深入理解计算机系统》｜处理器体系结构

![img](https://upload.jianshu.io/users/upload_avatars/3010486/d9eee8450714.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[唐鱼的学习探索](https://www.jianshu.com/u/0129e34fa381)关注

0.1442016.11.24 22:09:46字数 4,709阅读 2,589



![img](https://upload-images.jianshu.io/upload_images/3010486-6068185fd0815161.png?imageMogr2/auto-orient/strip|imageView2/2/w/773/format/webp)

目录

**学习事物是怎样工作的有其内在价值：**处理器是如何工作的对于我们普通人来说一直是个秘密，我们将从零开始构建一个流水线处理器，为了实现这一处理器的软硬件，我们有大量的前提知识要学习，包括：指令系统、硬件设计背景知识（hcl）、以及流水线的通用原理。学习完这些内容以后我们才开始YY一个我们自己的86处理器。

#### 本章内容

------

※ YY一个指令集Y86：各种状态、指令集、编码、编程规范、异常处理；

※数字硬件设计背景：处理器的基本构件，如何连接操作，介绍hcl语言；

※流水线原理，如何实现高效的五个步骤；如何处理冒险与冲突；

※开始实现我们自己的Y86；

#### **笔记**

------

#### **一、基础知识部分**

#### **1、介绍一个精简的Y86指令集**

------

**①状态码**



![img](https://upload-images.jianshu.io/upload_images/3010486-4f5be5207b071494.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)

状态码指明程序是否正常，程序可以访问和修改：程序寄存器、条件码、PC和存储器

**②所支持的指令**



![img](https://upload-images.jianshu.io/upload_images/3010486-4e0ea239c30ef768.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/435/format/webp)

长度：1-6字节，一条普通的指令包含：指令指示符+寄存器指示符+四字节常数

**说明：**

​        1] 字段 fn 指明是某个整数操作：OPL、数据移动条件：cmovXX、分支条件：jXX；

​        2] 图中最后的pushl、popl指明不需要访问任何寄存器0xF表示；

​        3] xxmovl中：i代表立即数，r代表寄存器，m代表存储器；

​        4] OPL代表的是：add sub and xor；jXX代表：jmp、jle、jl、je、jne、jge、jg。

【疑惑：不允许：存储器——存储器 ；立即数——存储器 为什么？】

**③一条普通指令的编码：**



![img](https://upload-images.jianshu.io/upload_images/3010486-ea1b74b6acd371be.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/269/format/webp)

OPL指令有相同的code编码6，不同功能编码function区别不同操作

**其他具体的编码如下：**



![img](https://upload-images.jianshu.io/upload_images/3010486-c230984a427bc0c7.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/576/format/webp)

整数、分支和数据传送操作

根据功能进行最优化的存储方式，比如rrmovl与条件传送有相同的code编码，这是因为其行为相当于无条件传送。

！我们还需要访问寄存器，为了访问的便利我们给寄存器编号，统一存放在CPU的一个寄存器文件中。就如学生时代的学号一样，唯一、明确，也像收监的犯罪嫌疑人，你从入狱的那一天起将没有名字，没有身份，只是一个简化的号码。



![img](https://upload-images.jianshu.io/upload_images/3010486-9e3f744e90fb64ab.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/244/format/webp)

寄存器编号：esp4号，ebp5号，F代表无寄存器

举例说明：rmmovl %esp ，   0x12345（%edx）

​                rmmovl ——>4  0

​                esp|edx—③—>4 2

​                0x12345——>00，01，23，45（小端法存储）

合成到最后的指令就是：[40] [42] [45] [23] [01] [00]

任何一个指令序列都是一个唯一的编码

**④异常**



![img](https://upload-images.jianshu.io/upload_images/3010486-b892f7a32fc3db08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/129/format/webp)

描述整体状态

**状态码如下：**



![img](https://upload-images.jianshu.io/upload_images/3010486-198c1bca7519ac11.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/486/format/webp)

我们简单的在异常条件下停止执行

**⑤我们写一段代码试一试**



![img](https://upload-images.jianshu.io/upload_images/3010486-e583693c245ecbe4.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/260/format/webp)

c代码

翻译成x86和y86汇编形式，基本上没什么不同



![img](https://upload-images.jianshu.io/upload_images/3010486-9e3d73c0f1d72c76.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/713/format/webp)

（特别注意：pushl 将栈指针esp减去4，并将内容写入存储器中。当我们执行push esp时，我们约定：首先雅鹿esp的原始值，然后压入减去4的esp的值）

#### **2、逻辑设计和硬件控制语言**

------

我们将会学到：计算对位进行组合的逻辑；存储位的存储原理和更新时钟信号三部分内容。

**① 对单个为进行操作：逻辑门**



![img](https://upload-images.jianshu.io/upload_images/3010486-1648a64fd2bbae46.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/337/format/webp)

与门，或门，非门

**② 组合逻辑用HCL表示：一个逻辑门肯定实现不了很多功能，我们来组合一下**

**用于检测两个Bit是否相等：**



![img](https://upload-images.jianshu.io/upload_images/3010486-f87c418d1dacacd0.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/471/format/webp)

eq = （a && b） || （！a && ！b）

当 a = b = 0时：上与逻辑为0，下与逻辑为1 或逻辑输出eq为1；

当a = b = 1时：上与逻辑为1，下与逻辑为0 或逻辑输出eq为1；

**多路复用器：根据s的值选择是输出a或者b**



![img](https://upload-images.jianshu.io/upload_images/3010486-b6af890134a90eea.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/468/format/webp)

out = (s && a) || (!s && b);

当 s = 0时，上与为b， 下与为0，或逻辑输出out = b；

当 s = 1时， 上与为0， 下与为a，或逻辑输入out = a；

**四路复用器：**



![img](https://upload-images.jianshu.io/upload_images/3010486-9fae16d4f9384d52.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/181/format/webp)

根据s1和s0组合，选择abcd其中一个



![img](https://upload-images.jianshu.io/upload_images/3010486-d33c8135eebc0cbe.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/245/format/webp)

hcl表示图

**字级组合电路：单个的bit位并没太大用途**



![img](https://upload-images.jianshu.io/upload_images/3010486-7914ec2c0c7403ae.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/502/format/webp)

字级组合电路：用32个Equal电路组合而成

**多路复用组合电路：使用32个MUX组合而成，只是非门是统一的一个**



![img](https://upload-images.jianshu.io/upload_images/3010486-bbc4d67cca061726.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/503/format/webp)

多路复用组合电路

**算术逻辑单元：ALU**



![img](https://upload-images.jianshu.io/upload_images/3010486-e90cbf974ae16be4.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/582/format/webp)

根据输入设置会执行不同的逻辑运算中的一种



**③ 集合关系**

在处理器设计中，很多时候需要将一个信号与许多可能匹配的信号做比较，以此来检验正在处理的信号是否属于某一类指令代码；



![img](https://upload-images.jianshu.io/upload_images/3010486-43da02b1e76e94c2.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/265/format/webp)

判断是否在集合中



![img](https://upload-images.jianshu.io/upload_images/3010486-053343d67b302e0e.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/250/format/webp)

结果在2,3中s1 = 1，结果在1,3中s0 = 1

**④ 存储器和时钟：存储原理（组合电路本身不能存储信息，只是一个时间序列电路）**



![img](https://upload-images.jianshu.io/upload_images/3010486-4f779c6187b4df41.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/297/format/webp)

更新周期将值放入存储器中

**分类：**

1] 时钟存储器（寄存器）：存储单个位或字；

2] 随机访问存储器（存储器）：存储多个字；（虚拟存储系统，寄存器文件，）

**硬件寄存器和程序寄存器的区别：**

​      硬件寄存器：在硬件中寄存器直接将输入和输出连接到电路的其他部分；

​      程序寄存器：CPU中位数不多的可寻址的寄存器，地址就是寄存器ID。

**a.硬件寄存器：当时钟信号处于高频上升阶段时，才将输入的信号加载**



![img](https://upload-images.jianshu.io/upload_images/3010486-4c01c2e023b36cfe.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/593/format/webp)

硬件寄存器：保存cc、pc、stat值

**b.寄存器文件**



![img](https://upload-images.jianshu.io/upload_images/3010486-f3d5ec01ca47ff3a.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/387/format/webp)

寄存器文件

有两个读：A、B端口，和一个写：W端口。允许同时进行多个读写操作，可以同时读两个寄存器和写一个寄存器的值。srcX、desW代表地址，valX、valW代表要数据。如我们要访问3号寄存器ebx的值，就将srcA=3，然后valA就是要访问的数据。

**c.随机访问存储器**



![img](https://upload-images.jianshu.io/upload_images/3010486-142b7619dfc36415.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/247/format/webp)

随机访问存储器

假如我们要访问一个地址address上的数据，就将该地址传入address中，同时设置write=0，那么在data out上的数据就是我们要访问的值了。

#### **3 流水线通用原理**

------

以自动化洗车设备为例，车子需要按照一定的速度通过流水线，增加了一部分处理量。也就是不用等前面的车子洗完，就可以开入另一辆车子了；但这个系统有时候也会增加延迟，比如你只需要给车子打蜡，但也必须要经过喷水、抹干阶段。

**①未加入流水线的系统：**



![img](https://upload-images.jianshu.io/upload_images/3010486-9840bba9615a56bd.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/499/format/webp)

组合逻辑花了：300ps，处理却只有20ps

**②加入流水线的：**



![img](https://upload-images.jianshu.io/upload_images/3010486-41e9916a4fd9473e.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/607/format/webp)

分成三个阶段，当指令I1进入B的时候，I2就可以进入A以此类推

通过将指令分成了3个阶段，我经过一个120ps周期，每条指令就行进下一个阶段

**③流水线操作详细说明：**



![img](https://upload-images.jianshu.io/upload_images/3010486-f9d4e4830c00e167.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/266/format/webp)

三个阶段流水线时序

> **说明：详细说明240-360的时钟周期的故事**
>
> 1] 点①时钟开始上升之前（239）：阶段A中计算的指令I2已经到达第一个流水线寄存器的输入，图中蓝色区域表示。但是该流水线寄存器Reg的值仍然是I1中的深灰色区域；指令I1在阶段B中计算的值已经到达第二个流水线流水线寄存器的输入Comb logic B，深灰色表示；
>
> 2] 点②时钟开始进入上升阶段（241）：两个组合逻辑输入：A和B，将结果放入到流水线寄存器中，形成图2的形式。蓝色Reg和深灰色Reg，并将组合逻辑A设置成发起指令I3计算；
>
> 3] 点 ③阶段信号开始传播，信号通过不同的速率通过各个不同的部分；
>
> 4] 点④360来到之前，指令I3完成组合逻辑A处的加载，形成浅灰色区域。



![img](https://upload-images.jianshu.io/upload_images/3010486-0870c585426a652e.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/490/format/webp)

流水线操作的一个时钟周期

**④流水线的局限性：**

1] 不一致的划分：由于阶段的延迟并不一样，这样空闲的空间就增加了延迟；

2] 流水线过深，收益下降；

**⑤带反馈的流水线系统：**许多指令前后相关，如何建立带反馈的指令

#### 二、从零开始构建我们的Y86处理器 

------

#### **1、一个Y86的顺序实现（简易方式）**

为了要实现一个通用的框架，我们通常要找到这个框架的层次结构，使得许多不同的指令可以共享相同的硬件，这是降低复杂度的一个有效的方法。



![img](https://upload-images.jianshu.io/upload_images/3010486-2e7d893bcf65524d.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/691/format/webp)

通用框架结构

**①跟踪一块指令序列的执行：**



![img](https://upload-images.jianshu.io/upload_images/3010486-c8cc4cd2aec3d41c.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/594/format/webp)

Y86指令序列

**②以 subl %edx， %ebx为例：**



![img](https://upload-images.jianshu.io/upload_images/3010486-6b034a70f8c146c2.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/293/format/webp)

**③SEQ硬件结构图：**



![img](https://upload-images.jianshu.io/upload_images/3010486-d9f2dadaae27ee48.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/436/format/webp)

seq抽象视图

（注：为什么是逆序从下往上写的？我们以后讲流水线的时候再讲解。）

**④SEQ的时间和执行顺序：**

一条重要的原则是：**处理器从来不需要为了完成一条指令的执行而去读该指令更新了的状态。**

比如我们之前讲到的push %esp指令，如果是分步执行，先将esp-4，然后将更新后的值作为写地址效率就太低了。我们的做法是在执行阶段计算出valE的值，然后在访存和写会阶段同时完成更新寄存器和存储器的操作。



![img](https://upload-images.jianshu.io/upload_images/3010486-ab3549f895cc698b.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/263/format/webp)

push指令的三个阶段

**我们再来看一段代码：**



![img](https://upload-images.jianshu.io/upload_images/3010486-8f2a8a4e848a74f0.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/519/format/webp)

讲解SEQ时序

**我们重点来看一下，第3和第4条指令的执行：**



![img](https://upload-images.jianshu.io/upload_images/3010486-b224ca0206a85813.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/504/format/webp)

执行序列

**我们来简单的讲解一下执行的过程：**

1] 在时钟周期3开始的时候点①状态元素保存的是周期2执行irmovl时的更新后的状态，用浅灰色表示。点②：随着时钟周期开始上升时，地址0x00c载入pc中，这样就取出了addl指令，值沿着Combinational Logic流动，充满了浅蓝色区域。在这个时候ebx就是加了以后的0x300新值，以及pc的新值0x00e。但是指令的状态仍然保留的是irmovl指令设置的值。

2] 时钟周期4：点③开始的时候，会更新程序计数器、寄存器文件、和条件码寄存器。也就是addl更新的状态。同样的会取出je指令，用深灰表示，ZF=0不会选择分支。在④的时候，pc产生新值0x013，Combinational Logic已经被更新过，但是状态还是保持的是addl指令的设置的值。



![img](https://upload-images.jianshu.io/upload_images/3010486-ecfd82473bbf1680.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/561/format/webp)

**我们再重申一下原则：**通过时钟周期来控制元素的更新，通过组合逻辑来传播，每次时钟周期由低到高时，处理器开始执行一条新指令。**处理器从来不需要为了完成一条指令的执行而去读该指令更新了的状态。**

**⑤Seq阶段的实现：**

**1] 取指阶段**



![img](https://upload-images.jianshu.io/upload_images/3010486-639a485a535d20bf.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/366/format/webp)

以PC为起始地址，从指令存储器中读出6个字节

**说明：**第一个字节为Split，字节0标号为：icode和ifun；1-5字节为Align：寄存器指示符和常数字的组合。

**2] 译码和写回阶段：这两个阶段都需要访问寄存器文件**



![img](https://upload-images.jianshu.io/upload_images/3010486-d85b9a9a5b84505d.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/309/format/webp)

seq的译码和写回阶段

同时支持两个读，A、B；和两个写：E、M；

**3] 执行阶段**



![img](https://upload-images.jianshu.io/upload_images/3010486-6d205b1427abe5df.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/330/format/webp)

执行阶段：根据ALU的值设置条件码寄存器，检测条件码的值判断是否选择分支

根据ALU fun信号设置是否进行，加减乘除操作。ALU的输出就是valE

**4] 访存阶段**



![img](https://upload-images.jianshu.io/upload_images/3010486-8bb36c39a7d7f339.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/322/format/webp)

访存阶段：读或写存储器

**5] 更新PC阶段**



![img](https://upload-images.jianshu.io/upload_images/3010486-ea0df7257a875f25.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/239/format/webp)

根据指令代码和分支标志，从valC valM和valP中选出下一个pc的值

### 2.Y86的流水线实现

------

我们说过，我们的目的是建立一个流水线化的处理器Y86，学了这么久的基础知识，也建立了一个简化的Seq模型，我们终于可以开始我们的内容了，首先我们来优化一下简易设计中的seq，我们称之为seq＋：

**①SEQ+：重新安排计算pc阶段**

SEQ+中没有单独的硬件寄存器来存放pc，而是通过pIconde、pCnd等寄存器计算pc的值。

> 设计原则：只要处理器能够正确的执行机器语言，我们不需要程序猿可见状态进行编码，只要能产生正确的值就可以了。



![img](https://upload-images.jianshu.io/upload_images/3010486-13a1317ee53c661d.png?imageMogr2/auto-orient/strip|imageView2/2/w/469/format/webp)

将pc移动到最开始的阶段

**详细的seq+图如下：**



![img](https://upload-images.jianshu.io/upload_images/3010486-2233cbe3ba6fd977.png?imageMogr2/auto-orient/strip|imageView2/2/w/489/format/webp)

将pc从时钟周期结束移动到了开始，这样更适合于流水线

**②插入流水线寄存器的pipe-处理器结构：**



![img](https://upload-images.jianshu.io/upload_images/3010486-c095beb3fab3255f.png?imageMogr2/auto-orient/strip|imageView2/2/w/516/format/webp)

pipe-硬件结构，我们创建了5阶段流水线

说明：图中以深蓝色区域表示的就是我们加入的5个流水线寄存器，白色方块代表不同的字段；

> F ： 保存pc预测值；
>
> D ：位于取指和译码之间，保存最新的指令信息，即将由译码阶段处理；
>
> E ：位于译码和执行之间，保存最新译码指令和从寄存器读出的值，即将由执行阶段处理；
>
> M ：位于执行和访存之间，保存最新执行指令的结果，条件分支和分支目标，即将由访存处理；
>
> W ：位于访存和反馈之间，提供给寄存器文件写，完成ret指令，向pc提供返回地址。

**③ 对信号进行重新排列和标号**

在pipe－中有4个标号为stat的白色区域，就是不同指令的状态码：D_stat、E_stat、M_stat、W_stat来区分。而小写的：f、d、e、m、w指的是流水阶段。

**④ 预测一下一个pc：**除了分支和ret指令外，我们基本上能够用valC和valP的值来预测下一条指令的地址，这样就可以通过之前学到的流水线技术使得每个周期执行一条指令。

**⑤ 流水线的冒险和处理方法**

什么是流水线的冒险？一条指令更新后面指令会用到的值。



![img](https://upload-images.jianshu.io/upload_images/3010486-58049b56758699ef.png?imageMogr2/auto-orient/strip|imageView2/2/w/522/format/webp)

数据冒险

当irmovl $3, %eax在第六个时钟周期的时候，写回阶段eax还未得到正确的值3，而流水线的系统中，addl %edx, %eax已经需要使用eax的值，这时侯得到的就是错误的值。

**冒险的分类：**1）数据冒险；2）控制冒险；3）加载\使用数据冒险

我们之前讲到流水线的反馈中，提到过如果两条相邻数据存在关联该如何处理成为了一个问题。特别是在使用流水线技术的情况下，如果一条指令要修改一个寄存器的内容，而下一条指令又刚刚需要引用该处的内容。如何使得两条指令执行正确。

**方法一：暂停**    

将指令阻滞在译码阶段，相当于加入一条nop指令，直到获得正确的值，才让其他指令继续执行。优点是实现容易，缺点是性能不佳

**方法二：转发**



![img](https://upload-images.jianshu.io/upload_images/3010486-baa70964fe4763a6.png?imageMogr2/auto-orient/strip|imageView2/2/w/509/format/webp)

通过使用状态码保存的值，实现旁路的转发

图中可以看出，我们不是在被动的等待irmovl执行完毕，而是在addl指令需要用到eax值的时候，我们将irmovl的W阶段的中间值，W_valE＝3转发到addl指令中去，赋值给eax。

5个用作源的有：e_valE、m_valM、M_valE、W_valM、W_valE；两个目的：valA、valB

**有一类比较特殊的数据冒险：加载\使用数据冒险，我们特别讲一下？**



![img](https://upload-images.jianshu.io/upload_images/3010486-43a2d29086fbd167.png?imageMogr2/auto-orient/strip|imageView2/2/w/276/format/webp)

Load 、 Use 数据冒险

上面的两条指令，我们具体来看一下流水线的执行过程：



![img](https://upload-images.jianshu.io/upload_images/3010486-7ed3f93c43bc330e.png?imageMogr2/auto-orient/strip|imageView2/2/w/563/format/webp)

加载使用数据冒险

我们执行0x018指令，要在第八个时钟周期的时候才能获得eax的值，而0x01e指令在第七个时钟周期就需要这个eax，我们不可能将这个值从第八个周期传回第七个周期。**就像不能穿越时间线回到过去一样。**遇到这种情况我们的处理方式是：使用暂停和转发相结合的方法，确切的讲就是暂停addl执行的一个时钟周期，使得在周期8的时候实现转发。

**⑥ 异常处理**

**异常分为：**halt指令、有非法指令和功能码组合的指令、访问非法地址

**处理方法：**有多条指令引起异常，由流水线最深的指令优先级最高

​                 多条分支中有异常，取消预测指令

​                 出现异常，根据状态码的stat值，禁止其他指令更新程序状态

**⑦ PIPE各个阶段的实现：**

**1] PC选择和取指阶段**



![img](https://upload-images.jianshu.io/upload_images/3010486-674531491a921570.png?imageMogr2/auto-orient/strip|imageView2/2/w/506/format/webp)

选择和取指逻辑

PC选择器必须要选择出正确的pc值，一般来说有三种方式可选：当预测错误分支进入访存，选择M_valA中的valP；当ret指令进入写回阶段时，选择W _valM；其他情况下选择F_predPC。

**2] 译码和写回阶段：**



![img](https://upload-images.jianshu.io/upload_images/3010486-be7991dbeced13c5.png?imageMogr2/auto-orient/strip|imageView2/2/w/623/format/webp)

译码写回

疑问：对于转发逻辑和不同的转发源还不明白；对Sel＋Fwn的具体功能不明确

**3] 执行阶段：**



![img](https://upload-images.jianshu.io/upload_images/3010486-c145d313b01dd5a0.png?imageMogr2/auto-orient/strip|imageView2/2/w/516/format/webp)

同SEQ中相似

**4] 访存阶段**



![img](https://upload-images.jianshu.io/upload_images/3010486-203d412003010ef3.png?imageMogr2/auto-orient/strip|imageView2/2/w/539/format/webp)

**⑧ 流水线控制逻辑**

**1］特殊情况的处理**

ret指令实际的处理过程是在取指阶段反复的取出ret指令后面的指令，在译码阶段插入气泡；

当分支结果还未计算出来的时候，保持预测指令执行在FD阶段，这样可以防止，如果预测错误，预测指令不会修改程序状态。如果决定不执行分支，取消指令的执行不会带来错误的影响；实现的方法是根据stat的值：禁止执行阶段中的指令设置条件码；向存储阶段插入气魄，以禁止写入；当写回阶段有异常的时候，暂停写回。

**2］流水线的控制机制：加入气泡和暂停**



![img](https://upload-images.jianshu.io/upload_images/3010486-ad18561dcfab7e65.png?imageMogr2/auto-orient/strip|imageView2/2/w/461/format/webp)

加入stall、bubble

> 当暂停stall＝1的时候，状态保持先前的值不变；
>
> 当bubble＝1的时候，用nop覆盖当前的状态

**3］控制条件的组合**



![img](https://upload-images.jianshu.io/upload_images/3010486-4ef16d0d8a6f192f.png?imageMogr2/auto-orient/strip|imageView2/2/w/408/format/webp)

两种特殊情况的组合

我们需要处理的情况为组合B：加载指令设置寄存器esp的值，而ret指令将esp用作源操作数，因为它必须从栈中弹出返回地址，流水线控制应将ret指令阻滞在译码阶段。

（注：系统分析的重要性，仅仅运行正确其实并不可靠）

**4］最终控制模型：**



![img](https://upload-images.jianshu.io/upload_images/3010486-c81f4e889f3b9a6a.png?imageMogr2/auto-orient/strip|imageView2/2/w/582/format/webp)

控制逻辑全

**⑨ 未完成的工作：**与存储器的接口和多周期指令。

# 《深入理解计算机系统》| 优化程序的性能

![img](https://upload.jianshu.io/users/upload_avatars/3010486/d9eee8450714.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[唐鱼的学习探索](https://www.jianshu.com/u/0129e34fa381)关注

0.2992017.02.08 23:09:26字数 5,436阅读 1,257



![img](https://upload-images.jianshu.io/upload_images/3010486-046c21d796bf508a.png?imageMogr2/auto-orient/strip|imageView2/2/w/920/format/webp)

**编写运行的快的程序有三个因素：**①选择合适的算法和数据结构；②理解编译器的能力，使用有效的方式让编译器能进行优化；③对于运算量特别大的程序，可能还需要进行任务分解。在这一过程中可能还需要对程序的可读性和运行速度进行权衡。

在阅读这一章节的过程中花费了大量的时间对我自己的自动办公软件进行了优化，算是学以致用。选择合适的算法和数据结构不在本章的讲解内容中，我们从编译器的能力和局限性讲起着重介绍几种提高程序运行速度的方法

#### **1.1 编译器的局限性**

------

**编译器遵循的一个优化程序的原则是：安全优化，**也就是说为了保证程序的正常运行（优化后的版本与未优化的版本有一致的行为，这不是废话吗）编译器一般都是很保守的。来看一个例子：



![img](https://upload-images.jianshu.io/upload_images/3010486-71b4557ad65cc975.png?imageMogr2/auto-orient/strip|imageView2/2/w/359/format/webp)

安全优化：存储器别名

从上面的例子不能看出，一般情况下twiddle2要求三次存储器引用（读*xp，读*yp，写*xp）而中twiddle1要求六次存储器引用（2次读*xp，2次读*yp，2次写*xp）。所以twiddle2的效率要高于twiddle1，但是如果考虑到xp等于yp，指向存储器中的同一个位置的时候，我们用twiddle2来优化twiddle1的版本就会造成程序的运行结果的不同。比如当xp = yp = 2的时候，f（twiddle1） = 8 ；而f（twiddle2） =  6 这就是我们说的编译器的局限性。

#### **1.2 表示程序的性能CPE**

------

在继续介绍优化大法的时候，我们对提高程序的性能做一个量化的参考，在以后的章节中好对比我们的优化后版本的执行效率。

**CPE**：每元素周期（Cycles Per Element），使用时钟周期，度量每隔周期执行了多少条指令。通常当一个标有“4GHz”的处理器，这表示的是处理器时钟运行频率4X10的9次方Hz每秒，那么一个时钟周期就是时钟频率的倒数，为0.25纳秒。

我们来看一个计算集合值的两个函数，我们假设有集合a = {1,2,4,5,7,9,10,12,16}集合p为集合a的前置和也就是p={1, 1+2, 1+2+4, 1+2+4+5,1+2+4+5+7，……1+2+4+5+7+9+10+12+16}

我们有两种计算前置和p的方式，psum1和psum2：



![img](https://upload-images.jianshu.io/upload_images/3010486-77076aa6e9071a6d.png?imageMogr2/auto-orient/strip|imageView2/2/w/521/format/webp)

循环展开技术

psum1是我们通常用到的版本，看起来也比较顺眼，psum2是我们以后要详细讲解的循环展开技术，核心的思想就是每次循环计算两个元素p[i]和p[i+1]从而减少了循环的次数。这个内容我们以后讲解。

来看一下两个函数的性能对比，数据说话：



![img](https://upload-images.jianshu.io/upload_images/3010486-ae384184b9d7f992.png?imageMogr2/auto-orient/strip|imageView2/2/w/668/format/webp)

x轴表示处理的元素，y轴表示周期

我们可以很明显的看出来，当处理的数据量小的时候，两个版本的区别不大，但当周期在1000以上的时候，能处理元素的个数就明显不同了而且这种趋势越拉越大。

#### 1.3优化大法好：一个程序的进化过程

------



![img](https://upload-images.jianshu.io/upload_images/3010486-e5e21175e05eb09f.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/500/format/webp)

智人的进化过程

从大约7万年前的认知革命开始，智人的进化经历了漫长的过程，终于实现了从动物到“上帝”的转变，我们将从一个简单的程序示例讲起带领大家一步步实现这个过程，当然不会花费上万年的时间。

**① 原始版本：程序示例**



![img](https://upload-images.jianshu.io/upload_images/3010486-dd6c860aec58d532.png?imageMogr2/auto-orient/strip|imageView2/2/w/630/format/webp)

计算一个向量的集合

有必要解释一个combine1函数的作用：计算一个向量的集合

我们的向量有如下数据结构：



![img](https://upload-images.jianshu.io/upload_images/3010486-b00aa7a460b76201.png?imageMogr2/auto-orient/strip|imageView2/2/w/880/format/webp)

向量由头信息加上指定长度的数组表示

我们定义typedef int data_t，方便我们用data_t表示不同的int、float、doubule数据。

我们使用： #define IDENT 0 和 #define OP   +来对不同的运算进行求值，其中OP代表运算符号，而IDENT代表不同的初始值。

好了，作为一个起点，我们来看看我们的黑猩猩版本：combine1的效率：



![img](https://upload-images.jianshu.io/upload_images/3010486-02437857c90f0caa.png?imageMogr2/auto-orient/strip|imageView2/2/w/717/format/webp)

未优化版本的效率

的确有点儿惨不忍睹，我们能为他做些什么呢？开始来进行 一些改进吧
**② 代码移动：消除循环的低效率**



![img](https://upload-images.jianshu.io/upload_images/3010486-7ce1b84c6adc316c.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/434/format/webp)

改进循环的效率：将vec_length移除循环外

一个看上去无足轻重的代码片段可能隐藏有渐近低效率，上面combine2只是将求得向量长度的vec_length移除了循环外，因为向量的长度不会随着循环的进行而改变。我们来看看性能的改变：



![img](https://upload-images.jianshu.io/upload_images/3010486-ff192a0452775fd8.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/818/format/webp)

**③ 减少函数的调用**

分析：combine2的代码可以看出，在循环的过程中每次都会调用get_vec_element来访问向量的元素，对于数组的引用，检查边界是合理的，但分析我们向量的数据结构不难看出，不进行边界检查我们也能够进行合法的访问：



![img](https://upload-images.jianshu.io/upload_images/3010486-bfd609db6460d227.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/641/format/webp)

消除循环中的函数调用

就像《葵花宝典》开篇就讲到的内容，欲练此功挥刀自宫，当我们在进行循环体内的调用函数优化的时候，必然会损害一些程序的模块性，慎用！

**④ 消除不必要的存储器引用**

分析：combine3中每次合并计算会将值累计在指针dest指定的位置上，我们来看看汇编代码：



![img](https://upload-images.jianshu.io/upload_images/3010486-3a545991a0daf3e8.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/549/format/webp)

rbp保存dest的值

从以上汇编代码中我们看出，dest的值存放在rbp中，每次循环，要先读rbp到xmm0，计算后的结果又会重新写入到rbp中去，这样写很浪费。我们能够消除这样不合理的引用：



![img](https://upload-images.jianshu.io/upload_images/3010486-4dc6d51c19560a36.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/444/format/webp)

临时局部变量acc存放中间结果

我们使用局部变量acc保存累计计算的结果，这样就消除了每次循环都要对存储器进行取值和写回，使得程序性能有显著的提高。

#### 1.4 理解现代处理器分析combine4的效率瓶颈

------

到目前为止的优化都不依赖于机器的特性，我们将学习现代处理器的一些知识，比如：关键路径、延迟界限以达到处理器级别的优化。



![img](https://upload-images.jianshu.io/upload_images/3010486-810de7372900dfda.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/549/format/webp)

上图是一个简易的处理器框架图，在实际的处理中，处理器同时对多条指令求值（指令级并行），同时又呈现出一种简单的顺序执行的现象。 整个框架分为两个大部分：指令控制单元（ICU）和指令执行单元（EU），前者负责从存储器中读出指令序列，生成对数据的基本操作。后者负责执行。我们分别进行讲解：

**指令控制单元（ICU）：**ICU从指令高速缓存（包含最近访问的指令）中读取指令，通常在ICU当前执行指令很早之前就开始取指，译码并发送到EU单元执行。当遇到了分支指令的时候：处理器采用分支预测，**投机执行，**在未确定该执行哪些操作的时候就对不同的分支目标地址进行取值和译码甚至执行。如果预测错误就回到最初的位置。使用投机执行技术求得的值不会存放在寄存器和数据存储器中，寄存器中的退役单元控制着寄存器的更新，只有当所有的分支都确定是正确的时候，指令才会退役，所有对寄存器的更新才会实际执行，否则清空该指令。

**指令译码：**将实际的指令转化为一组基本的操作 addl %eax，4（%edx）转为：①从存储器中加载一个值到处理器中；②将加载的值加上eax；③重新写回到存储器中

**指令执行单元（EU）：**接受指令译码传来的一组操作，然后分配到功能单元中，这些功能单元包括：分支、乘除、加法、加载和写存储器。其中对存储器的访问，通过加载和存储功能单元对数据高速缓存的访问来实现。

**！寄存器重命名机制的实现方式：**

先来看看什么是寄存器重命名：



![img](https://upload-images.jianshu.io/upload_images/3010486-5f8f4883808267d7.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/312/format/webp)

图1

指令4,5,6在功能上并不依赖于1,2,3的执行，但是必须要等待1,2,3完成之后才能执行4.

通过改变一下寄存器的名字可以解除限制：



![img](https://upload-images.jianshu.io/upload_images/3010486-422f7733dcdaa697.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/258/format/webp)

图2：将R1重命名为R2

实现方式：当一条更新R1为R2指令译码时，将[r（R1），t（R2）] 的对应关系加入到一张表中，随后当图1指令4需要再次访问到R1的时候，发送到执行单元的值会将R2作为操作数源的值，而当M[2048]完成赋值任务以后，会形成（v，t）的结果，指明标记的结果M[2048]。所有等待R2的值都会使用v作为源值转发。这样做的好处就是值可以从一个操作直接转发到另一个操作，而不是写到寄存器文件再读出来。

我们学习了一些基础的知识，我们重新来分析一下combine4的一些特性：



![img](https://upload-images.jianshu.io/upload_images/3010486-1e91e4a42b80720d.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/272/format/webp)

combine4：瓶颈在循环部分



![img](https://upload-images.jianshu.io/upload_images/3010486-3f9e00efb0d89561.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/608/format/webp)

已float的乘法为例

我们所熟悉的指令译码器，会将以上这4条指令扩展为5个步骤：



![img](https://upload-images.jianshu.io/upload_images/3010486-8b216086e61e8133.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/607/format/webp)

combine4的循环代码图形化表示

我们简单的来理解一下mulss指令的两个操作：load指令加载rax、rdx的值并将计算的结果直接传入到mul指令中，与xmm0进行乘法运算并将结果写入到xmm0中。

我们重新画一下上图的内容，使得结果看起来更清晰一些：



![img](https://upload-images.jianshu.io/upload_images/3010486-9802ae185d37283a.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/516/format/webp)

图b中我们删除了白色区域（无相关项）和没有修改寄存器的部分，只留下了循环执行过程中对xmm0和rdx迭代进行的一系列操作。



![img](https://upload-images.jianshu.io/upload_images/3010486-100544655fc33e3c.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/260/format/webp)

关键路径

终结一下：我们可以看出，两大关键链条分别是：mul对acc的操作，和add对i的操作，而左边的mul链条会成为关键路径。通过对处理器结构的分析，我们接下来不难看出，要再一步进行优化，就只有对关键路径进行优化了。（继续讲解循环展开技术）

#### 1.5 循环展开：一场真正意义上的进化（combine5）

------



![img](https://upload-images.jianshu.io/upload_images/3010486-2a5f2abe2974ad6e.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/490/format/webp)

循环展开能减少循环开销的影响

**还是以我们之前讲到的向量为例：**

我们假设有集合a = {1,2,4,5,7,9,10,12,16}使用combine函数进行求和运算：我们模拟计算机的执行顺序，一步步在草图上分析combine5代码实现的功能。



![img](https://upload-images.jianshu.io/upload_images/3010486-8da4d84925eb63d9.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/669/format/webp)

k=2循环展开两次，字太丑见谅

**总结：**我们之所以将limit定义为length-1，是向量的长度不一定是2的倍数，如上图中的9，为了不至于在第一次循环中越界访问，我们将limit设置为length-1.虽然我们用到了两次循环，但循环展开大大缩短的关键路径，提高了效率。我们将这个思想归纳为循环展开k次，k < length + 1 ，我们上面讲的内容就是k=2次，一次计算2个元素的和。我们看看效率的提升：



![img](https://upload-images.jianshu.io/upload_images/3010486-cdd8fcd4d47fc896.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/715/format/webp)

浮点运算无变化

**注：**为什么浮点运算的没有性能的提升？虽然展开了两次循环，但是必须要顺序的执行，所以没有性能的提升。



![img](https://upload-images.jianshu.io/upload_images/3010486-d7cbd04d2b008289.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/254/format/webp)

两次运算展开后是顺序执行的

#### 1.6 进一步优化：提高并行性（combine6、combine7）

------

**分析：**我们将累积变量放在一个单独的acc中，在前面的计算完成前，不能计算新的acc值



![img](https://upload-images.jianshu.io/upload_images/3010486-61358aa791d6dec8.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/430/format/webp)

两次循环展开，使用两路并行

**性能对比图：**



![img](https://upload-images.jianshu.io/upload_images/3010486-6e72f067f4f33efc.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/806/format/webp)

**怎样理解combine6带来的性能提升：**

我们看到唯一不同的地方在与循环①（标号12）处代码中，加入两个累积变量：acc0和acc1，这样做有什么好处呢？

> acc = (acc OP data[i]) OP data[i+1];   **转变为：**
>
> acc0 = acc0 OP data[i];   和  acc1 = acc1 OP data[i+1];



![img](https://upload-images.jianshu.io/upload_images/3010486-091cbc777e0da1ff.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/537/format/webp)

带入分析图（combine6）

**我们再来看看图形化的数据分析：**



![img](https://upload-images.jianshu.io/upload_images/3010486-af54500d01699161.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/339/format/webp)

引入新变量acc0和acc1分配到不同寄存器寄存器xmm0和xmm1

**这样一来关键路径就成了两路并行，效率大大提升了：**



![img](https://upload-images.jianshu.io/upload_images/3010486-c8d24b2f16a0e68b.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/314/format/webp)

cimbine6的关键路径

还有没有其他方法能打破顺序相关而提高效率？来看看combine7变种：



![img](https://upload-images.jianshu.io/upload_images/3010486-3c904841275972b8.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/507/format/webp)

combine7重新结合变换

标号12的语句中与combine5相比，只是结合方式发生了变化，将：

acc = (acc OP data[i]) OP data[i+1]  **变成了** acc = acc OP （data[i] OP data[i+1]）

我们来对比一下combine5和combine7两个版本的数据流图：



![img](https://upload-images.jianshu.io/upload_images/3010486-c313f9e30d5d297d.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/473/format/webp)

数据流图对比

在combine7的版本中，第一个mul通过两个load指令将i和i+1的乘机计算出来，然后交给第二个mul将乘积累积到xmm1（acc）中。就不像combine5中的load mul顺序执行，必须等到第一个load mul执行完成以后才能进行第二次load和mul操作。我们将combine7的模型复制几次就能看的关键路径变成了n/2个操作，这就带来了性能的提升：



![img](https://upload-images.jianshu.io/upload_images/3010486-1ad82f62656b92e4.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/287/format/webp)

combine7：我们看到只有一条关键路径，而且包含n/2个操作

**总结：**到目前为止，我们已经完成了从combine1到combine7的进化，带来了至少10倍以上的效率提高，我们发现**循环展开、并行累积值**在多个变量中，是可靠的提高程序性能的方法。那还有那些限制因素呢制约着程序的性能呢？

**一些限制因素：**

**① 寄存器溢出：**当我们的并行度超过了可用的寄存器数量，编译器就会将结果溢出到栈中，性能就会急剧下降，笔记访问存储器的时间要长很多。

**② 避免分支预测和预测错误处罚：**1> 不要过分关心可预测的分支，因为带来的性能差异很小；2> 书写适合用条件传送实现的代码。

#### 1.7理解存储器性能

------

**分析：为什么要理解存储器的性能？**

当我们要处理的数据小于1000个元素的向量，数据量不会超过8000个字节，这些内容都会存放在多个高速缓存存储器中，已方便我们快速访问。接下来我们会研究在高速缓存中的加载和存储操作对性能的影响，充分利用高速缓存来编写高效率的代码

**加载的性能：**

我们在对链表的访问中，可以看出加载函数对性能的影响，举个例子：



![img](https://upload-images.jianshu.io/upload_images/3010486-4eec95c4fcf5b1d5.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/315/format/webp)

加载操作的延迟

我们来看看ls = ls->next这句的汇编代码：



![img](https://upload-images.jianshu.io/upload_images/3010486-de36482445e7a764.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/414/format/webp)

movq是这个循环的关键瓶颈

在标号3中，使用movq指令，加载值到rdi寄存器中，而加载操作又依赖于rdi来计算加载的位置，也就是说，必须要等到前一次加载完成才能进行下一次循环。这个函数的CPE等于4也就是说加载的延迟为4.

**存储的性能：**

**分析：**从理论上来讲，存储操作并不影响任何寄存器的值，不会产生任何数据相关。而只有加载操作是受存储的影响的，因为只有加载操作读取的是有存储器写操作的值。

**写读的相关性：**



![img](https://upload-images.jianshu.io/upload_images/3010486-3911bdcf5c3325ab.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/495/format/webp)

写读相关

为了讨论写和读的相关性，我们来看看上述代码的两种不同的情况：假设a[0]=-10,a[1]=17:



![img](https://upload-images.jianshu.io/upload_images/3010486-b473142377454af1.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/527/format/webp)

互不相干的情况CPE=2

举例A中可以看出，初始化的条件下a{-10，17}，val = 0， cnt = 3；当程序开始执行循环的时候，写操作：*dest = val 而读操作：val = （*src）+1访问的分别是不同位置，a[0]和a[1]。就是我们前面说过的数据不相关。



![img](https://upload-images.jianshu.io/upload_images/3010486-984c7467f02e17bf.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/535/format/webp)

读写相关CPE=6

而举例B的情况就完全不一样了，dest和src操作的是同一块位置a[0]，一个存储器读的结果依赖于一个最近的存储器的写。为什么读写相关以后程序的性能就降低了？我们来看看加载和存储单元的内部构造：



![img](https://upload-images.jianshu.io/upload_images/3010486-ebc50982866ca32f.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/431/format/webp)

加载和存储单元的细节

在上图的内部构造中，我们发现存储单元多了一个存储缓冲区，这样做有一个好处就是，当一些列存储操作开始执行的时候，不需要等待高速缓存更新完成就能够开始执行了。而当一条加载操作发生的时候，加载单元必须先检查存储缓冲区，看看有没有相匹配的条目，如果匹配成功就从存储缓冲区中取出数据作为加载的结果。



![img](https://upload-images.jianshu.io/upload_images/3010486-f1716c9d39722893.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/535/format/webp)

内循环数据流图

上图的内容有点儿乱，我们来说明一下：

①指令movl被译码成两个操作：s_addr和s_data其中前者负责计算存储器的地址，并在存储缓冲区中创建一个条目，设置地址字段；后者负责设置该条目的数据字段；

②s_addr同s_data右边的箭头表示，设置数据字段必须要等到计算地址阶段完成才能进行。此外，第二条movl指令被译码成了load指令，这条加载指令必须要检查所有的地址，包括正在读写的地址，所以s_addr与这条load指令也有相关性；还有一条虚线相关性，连接s_data和load，这表示如果两个地址相同，那么load必须要等到s_data将数据段设置到存储缓冲区。我们将上图修改一下，大家容易理解：



![img](https://upload-images.jianshu.io/upload_images/3010486-d1352aa375622866.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/376/format/webp)

读存数据相关流图

> 标号①表示：存储地址必须在数据被存储之前计算出来；
>
> 标号②表示：load操作将它的地址与所有未完成操作的地址进行比较；
>
> 标号③表示：数据相关，当访问相同位置时出现

我们剔除不影响数据操作的关联后形成如下图：



![img](https://upload-images.jianshu.io/upload_images/3010486-7a7e960a502ff54e.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/245/format/webp)

读写相关

我们清楚的看到了两条的关键路径，其中左边表示的是：存储加载相关；右边表示的是增加数据值相关。将以上图复制几次，并同不相关的数据进行比较，我们能看到读写相关对CPE的影响了：



![img](https://upload-images.jianshu.io/upload_images/3010486-af6662c328249b2f.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/463/format/webp)

左边地址不同，右边相同

总结：对存储器的操作，只有当加载和存储地址都被计算出来了以后才能确定其对性能的影响。

#### 1.8 优化程序大法总结

------

到目前为止，我们基本上上讲完了所有的优化程序性能的方法，套路如下：

① 高级设计：选择适当的算法和数据结构，要提高警惕，避免渐近低效率；

② 基本编码原则：

*消除连续的函数调用，有可能的时候将计算移动到循环体外；

*消除不必要的存储器引用，引入临时变量保存中间值。

③ 低级优化：

*展开循环，降低开销；

*提高并行，使用多个累积变量或者重新结合，用良好的风格重新条件操作。

在实际的优化程序的过程中，我们不可能像之前讲到的简单程序那样，快速的分析出一个程序片段的性能瓶颈，毕竟在真实的项目中源码的量相当大，这时候我们有必要运用一些软件来分析程序的性能瓶颈，Unix系统中有一个GPROF可以实现相关分析，在此不做讲解了。

> 备注：（Amdahl定律）Gene Amdahl曾经发现过一个很有意思的现象，最后以Amdahl命名了这个定律，大意就是：当我们选择提高某个系统的效率的时候，被改进的这一部分效率，对整体的影响，在于被改进部分到底有多重要（听起来像废话）。我们来举个例子，加入一个软件的耗时分为Told＝（1+6+3）＝10我们将6这个部分的效率提高了3倍，变成了Tnew＝（1+2+3）＝6。整个系统的加速还是不大。这就是Amdahl定律要告诉我们的主要观点，要想获得整体性能的提升，我们必须要提高很大一部分系统的速度。单靠一个方面是不行的。

# 《深入理解计算机系统》| 存储器层次结构

![img](https://upload.jianshu.io/users/upload_avatars/3010486/d9eee8450714.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[唐鱼的学习探索](https://www.jianshu.com/u/0129e34fa381)关注

0.2352017.03.17 23:12:19字数 5,231阅读 1,342



![img](https://upload-images.jianshu.io/upload_images/3010486-bc202a6e502df129.png?imageMogr2/auto-orient/strip|imageView2/2/w/736/format/webp)

目 录

在本章中，我们会先了解存储技术（SRAM\DRAM\ROM\旋转固态硬盘），描述这些存储器是如何被组织成层次结构的。接下来会谈到什么是拥有良好局部性的程序以及编写这样的程序需要注意的问题。然后我们开始探究本质，为什么说拥有良好局部性的程序会执行的更快。就要求我们要学习高速缓存，并教会大家理解程序的局部性的真正意义，使得你自己不仅仅遵守规则，而是了解其内部原理获取更大的自由。

#### 1.1 存储技术

------

**① 随机访问存储器**

**静态RAM：**（SRAM）用作高速缓存，通常只有几兆，在CPU芯片上、下；硬件设计中，将每个位存在一个双稳定的存储单元中，如下图所示，只有在两边的时候保持稳定性：



![img](https://upload-images.jianshu.io/upload_images/3010486-032064de8dddb859.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/552/format/webp)

只要有电，会永远保持它的值，不惧干扰

**动态RAM：**（DRAM）用作主存（我们通常说的机器的内存），通常几百、几千兆。每个单位使用一个电容和一个访问晶体管构成，容易被干扰，有的加入有纠错码。系统需要周期性读出，然后刷新重写存储器的每一位。

**DRAM详细构造图：**



![img](https://upload-images.jianshu.io/upload_images/3010486-caf3469191c45456.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/545/format/webp)

一个128位的16X8的DRAM构造视图

DRAM芯片被分割成16个超单元，每个超单元又由w个DRAM单元组成，一个16*w的DRAM共存储16w位信息。超单元被组织成一个4*4的阵列，图中的超单元地址用（2，1）表示。信息通过引脚流入和流出芯片，每个引脚携带1位信号，图中有两组引脚，其中data引脚为8个，能传出或接受来自芯片的一个字节数据，还有两个addr引脚，携带2位的行列超单元地址。

**访问示例（我们来看看是如何访问超单元（2，1）处的内容）**

**分析：**我们首先来思考一个问题，为什么要组成一个二维的数组，而不是一位数组，这样访问的速度就快很多啊。以上图为例，我们如果要建造一个128位的DRAM，我们用一维数组实现的话，我们需要提供大量的地址引脚来提供访问（硬件设计上太费了）。



![img](https://upload-images.jianshu.io/upload_images/3010486-86fa0cb7db9f409c.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/765/format/webp)

读取一个超单元

为了加快二维数组的访问，存储控制器在读取（2，1）处的内容的时候，使用addr先发送行地址2到DRAM芯片中，拷贝整个第二行的内容到内部缓冲区中，然后发送列地址1，从内部行缓冲区中读取1的地址内容通过data发送到存储控制器中去。

**② 存储器模块**



![img](https://upload-images.jianshu.io/upload_images/3010486-5b377945d8f88c86.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/665/format/webp)

读一个存储器模块的内容

如图所示是一个64M的主存，芯片编号0-7，每个芯片存储8M的数据，存储器模块将其组合起来，聚合内存。将每单个芯片的超单元映射成主存地址A的各个字段。这样控制器收到一个主存地址A的时候，存储控制器将其选择包含的具体芯片，将A转换成（i，j）的形式，然后将（i，j）发送到芯片模块中开始取数据。

> **备注：**存储在ROM设备中的程序通常称为固件，当一个计算机系统通电以后，它会运行存储在ROM中的固件。

**③ 访问主存（读事务、写事务）**

数据流通过总线，在CPU和DRAM中传递数据，总线能携带：地址、数据和控制信号。



![img](https://upload-images.jianshu.io/upload_images/3010486-d510f971c5c8b685.png?imageMogr2/auto-orient/strip|imageView2/2/w/506/format/webp)

CPU和主存的总线构照图

**读事务：**考虑当我们执行，movl A，%eax的情况，地址A的内容会被加载到eax中去，总线发起读事务（分三步）：①CPU将A的地址总线放到系统总线上，桥作为中转点，将地址信号传送到存储器总线上去；②主存感觉到了存储器总线上的地址信号，从存储器总线上读地址，并从主存中取出相应的数据，写入到存储器总线上去，桥将数据专递到系统中线中去；③CPU感觉到了系统总线上的数据，将数据拷贝到eax中。

I/O桥作为中转，将地址信号从系统总线转到存储器总线，然后又将数据从存储器总线转到系统总线。在这个过程中，CPU始终是从系统总线上发送地址，读取数据，主存始终是从存储器总线上接受地址并发送数据。（写事务是一个逆向过程不做讲解）

**④ 磁盘存储 （硬盘）**

**构造：**



![img](https://upload-images.jianshu.io/upload_images/3010486-6c3a5b047a89aba9.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/484/format/webp)

磁盘由盘片构成，表面覆盖的有磁性材料，中间是一个主轴，通过旋转读取和记录数据。每组同心圆磁道分割的区域就是一个扇区。扇区之间是有间隙的，如图：



![img](https://upload-images.jianshu.io/upload_images/3010486-9e27ca329a0f6a6c.png?imageMogr2/auto-orient/strip|imageView2/2/w/845/format/webp)

磁盘构造

**磁盘读写操作：**



![img](https://upload-images.jianshu.io/upload_images/3010486-34a28ff60573fce2.png?imageMogr2/auto-orient/strip|imageView2/2/w/837/format/webp)

磁盘动态特性

磁盘以扇区为单位来读写数据，对扇区的访问时间由三个部分组成：**寻道之间、旋转时间、传送时间。**以图a为例，当我们要访问同心圆磁道5的内容时，寻道时间是指传动手臂将读写头移动到同心圆第五磁道的时间，旋转时间指的是同心圆5开始读取内容的位置，如果手臂移动到第五磁道的时候读写位置刚过，就要等磁盘旋转一圈之后再读取；传送时间，扇区第一个位处于读写头的时候，读写该扇区的时间。（寻道时间和旋转延迟大致相当）

> **磁盘为什么都是密封的？**在传动臂末端的读/写头在磁盘表面高度大约0.!微米处的一层薄薄的气垫上飞翔(就是字画上这个意思)，速度大约为80km/h。这可以比喻成将Sears Tower(译者注，一座位于芝加哥的108层和442米高的摩天大楼)放倒，然后让它在距离地面2.5 cm(1英寸)的高度上飞行环绕地球，境地球一天只需要8秒钟!在这样小的间隙里，盘面上--粒微小的灰尘都像一块巨石。如果读/写头碰到了这样的一块巨石，读/零头会停下来，撞到盘面——所谓的读/写头冲撞(head crash)。

**逻辑磁盘块：**

以我们正在使用的计算机为例，当我们安装的有ghost软件开始备份的时候，就会要求选择备份文件的位置，我们看到的是1.1-1.6左右的可以选择的硬盘，实际上磁盘虽然进行了分区，但本质上仍然只有一块磁盘。在磁盘中有一个小固件，磁盘控制器，维护着磁盘扇区之间的映射关系。假设我们要打开E：上的一个文件，控制器就会执行一个快速表查找，将该处的内容翻译成（盘面、磁道、扇区），等到传动臂移动到正确的位置时，将内容读到一个缓冲区，然后拷贝的主存中去。

**逻辑块的作用：**当我们对磁盘进行分区以前都要求我们进行格式化，这样做是让磁盘控制器，读取磁盘的基础内容，同时建立备用扇区，当一个扇区不能访问的时候，磁盘控制器启用备用扇区，这样使得磁盘更健壮，不会因为一点点损坏就不能使用了。备用扇区可能相当的大。

**连接I/O设备**



![img](https://upload-images.jianshu.io/upload_images/3010486-3378738d91933b82.png?imageMogr2/auto-orient/strip|imageView2/2/w/542/format/webp)

总线结构图：CPU、主存、I/O设备

I/O总线也是通过桥和CPU相连，这样的设计有更大的兼容性，比如USB（通行串行总线）可以连接多个不同设备（打印机、鼠标、键盘），传送600M/s的数据（usb3.0）。图形卡（GPU）代替CPU在显示器上像素显示。特别的来讲，磁盘是通过主机总线适配器同io总线相连的。

**访问磁盘：（磁盘-主存-CPU）**

对磁盘的数据访问，并不是直接从磁盘到CPU，而是通过主存作为桥梁，达到快速访问。我们现实生活中的桥，貌似也是这个作用。

**当我们要读取磁盘0xa0的内容，cup发出三道指令：**1] 发送一个命令，要求读磁盘内容，要求读完以后报告给CPU（中断）；2] 指明要读取的具体逻辑块号码；3] 指明拷贝到主存的地址。



![img](https://upload-images.jianshu.io/upload_images/3010486-6c1de364ff1c2967.png?imageMogr2/auto-orient/strip|imageView2/2/w/605/format/webp)



![img](https://upload-images.jianshu.io/upload_images/3010486-277bf8ac56b4a2f9.png?imageMogr2/auto-orient/strip|imageView2/2/w/391/format/webp)

> **为什么要使用中断：**一个1GHz的CPU时钟周期是1ns，读磁盘的16ms的时间内，可以执行1600万条指令，这个时间如果只是等待的话就太浪费了。CPU发起读指令以后，就不用管了，等到磁盘控制器将内容全部COPY到主存中，磁盘控制器发起一个中断，告诉CPU，不要做自己的其他事情了，你之前让我读磁盘的内容已经全部读到主存中去了。

总结：现代计算机频繁的使用SRAM的高速缓存，试图弥补越拉越大的存储器与CPU之间的差距，我们接下来就来看看局部性这一属性是如何能弥补速度差的。

#### 1.2 局部性：以前用过的我还接着用

------

​    我们讲存储器体系结构就会很好的理解局部性，简单的来说，我们的主存就是我们为了提高我们磁盘文件的一个高速缓存，因为我们知道这一时刻访问到磁盘的数据可以下一时刻也会被访问，这一位置被访问的数据，邻居位置也可能会被访问。这也就是我们通常说的：时间局部性和空间局部性。

**对程序数据访问的局部性**



![img](https://upload-images.jianshu.io/upload_images/3010486-c96c7c3002328dcd.png?imageMogr2/auto-orient/strip|imageView2/2/w/547/format/webp)

假设我们有这样的一个二维数组：



![img](https://upload-images.jianshu.io/upload_images/3010486-9cb364cb524e76db.png?imageMogr2/auto-orient/strip|imageView2/2/w/848/format/webp)

我们遍历每个数组求和，这样的sum变量有很好是时间局部性，因为我们访问过一次，又接下来继续在访问。由于二维数组是按照行的顺序存储的，按照步长为1的求和，也使得程序有很好的空间局部性。

如果我们作一些改变，使得程序按照列的顺序访问：



![img](https://upload-images.jianshu.io/upload_images/3010486-2f84f4d18b0f6351.png?imageMogr2/auto-orient/strip|imageView2/2/w/804/format/webp)

�交换j和i的循环位置，使得程序按照列的方式求和，那么程序的局部性就相当的差了。

> 总结：
>
> 1.重复引用同一个变量的程序有良好的时间局部性；
>
> 2.具有步调长度为k的引用模式程序，步调越小，空间局部性越好。

我们一直在说具有良好的局部性的程序将获得更快的运行速度，究竟是什么原因导致了这种运行速度的提升，我们将学习高速缓存中的命中率和不命中率来量化局部性的概念，这就是我们接下来要讲到的内容了。

#### 1.3 存储器层次结构：理解命中率和不命中率 

------



![img](https://upload-images.jianshu.io/upload_images/3010486-1c9d53f1808498f1.png?imageMogr2/auto-orient/strip|imageView2/2/w/768/format/webp)

存储器层次结构

越往上，代表的是访问速度越快，当然存储容量小，价格也非常的高。越往下，意味着访问速度越慢，存储容量大，价格相对便宜。通常我们CPU的寄存器是L1的高速缓存，L1是L2的高速缓存，以此类推。

**基本缓存原理：**我们来看一个片段，下图为L3作为主存的高速缓存：



![img](https://upload-images.jianshu.io/upload_images/3010486-f4588a405db7b887.png?imageMogr2/auto-orient/strip|imageView2/2/w/711/format/webp)

基本缓存原理

上图我们把k+1理解为主存，被划分为16个块来存储数据，块的大小是固定的。我们把K层理解成L3高速缓存，任何时刻L3就是主存的一个子集。上图我们能看出，L3只能保存4个块的数据，块的大小保持和主存的大小一样的。上图中我们看到，L3中保存的是主存中的4，9，14，3的数据。那么什么又是命中率和不命中率呢？

**缓存命中：**当程序需要第k+1层数据块14的时候，程序会在当前存储的k层，寻找块14的数据，刚好14在k层的话，就是一个缓存命中，这比从k+1层读取的速度要快很多。

**缓存不命中：**当程序需要访问到块12的时候，在k层没有该数据块，就是一个缓存不命中，这时候就会从k+1层中读取块12将其替换到k层的一个数据块（覆盖或驱逐一个已有的数据块）。程序还是从k层访问块12。

**放置策略：**如果我们从k+1层中获得的数据随机的放置在k层，这样的随机放置就会导致访问的效率降低，我们的放置策略是块i必须放置在（imod4）中，也就是0，4，8，12会映射到同一个k层的块0中。这就会导致一个冲突不命中，也就是说如果程序交替请求k+1层的0，4块，由于会一直映射到k层的0块中，这时候虽然k层有空余的缓存，但还是每次不命中。

> 总结：利用时间的局部性，同一数据对象可能会被多次使用，一旦一个数据对象在第一次不命中的时候被拷贝到缓存中，我们就会期望在接下来的访问中有一系列的命中率。利用空间的局部性，由于一个数据块并不仅仅只有一个数据，而是一系列数据块的集合，我们访问到块子集a的时候，可能会继续访问块的子集b。

#### 1.4 高速缓存存储器（集成在CPU内部的一个部件L1、L2、L3三级缓存）

------





![img](https://upload-images.jianshu.io/upload_images/3010486-45332fd0905a6e9c.png?imageMogr2/auto-orient/strip|imageView2/2/w/499/format/webp)

高速缓存结构

**① 通用高速缓存存储器内部结构**



![img](https://upload-images.jianshu.io/upload_images/3010486-e66d17783ae873a5.png?imageMogr2/auto-orient/strip|imageView2/2/w/469/format/webp)

高速缓存通用组织

高速缓存是一个数组，每个组包含一个或多个行，每个行有一个有效位、一个标记位，以及数据块。我们进行访问的地址结构就是：t的标记位+s个组索引+b个块偏移；



![img](https://upload-images.jianshu.io/upload_images/3010486-7f874fc98f0a1c82.png?imageMogr2/auto-orient/strip|imageView2/2/w/528/format/webp)

基本参数术语一览表

**② 直接映射高速缓存（每个组只有一行的简单访问模式）**



![img](https://upload-images.jianshu.io/upload_images/3010486-40f0739a3c4a130a.png?imageMogr2/auto-orient/strip|imageView2/2/w/418/format/webp)

直接映射高速缓存（E=1）。每个组只有一行

高速缓存确定一个请求是否命中，然后抽出请求字的过程分三步：

> (举例：直接映射高速缓存的抽取请求字的过程就像我们投递快件一样，组索引其实就像我们的邮政编码，比如我们这里的510824，然后找到编码的组，也就是我的大位置（xx县），然后看标记上写的具体xx小区x栋楼，并且核实该地址是否有效（有效位1），两项都满足条件以后将该快件给快递员投递，快递员到达具体xx小区x楼的时候就根据门牌号（偏移位）敲开你家的门。binggo，快递到达）

**1> 组选择：**很好理解，就是地址位中的组索引匹配高速缓存中的组



![img](https://upload-images.jianshu.io/upload_images/3010486-1d6493a2b815ddce.png?imageMogr2/auto-orient/strip|imageView2/2/w/595/format/webp)

组选择

**2> 行匹配和字抽取**



![img](https://upload-images.jianshu.io/upload_images/3010486-ba1fdced851a4ae6.png?imageMogr2/auto-orient/strip|imageView2/2/w/565/format/webp)

行匹配和字选择

行匹配主要是对有效位进行匹配，和标记位与高速缓存中的标记位一致，这就是一个命中。最后的字抽取就简单了，只是看地址后面的偏移值。

**② 组相连高速缓存（每组多于1行的高速缓存）大致方法仍然一样**



![img](https://upload-images.jianshu.io/upload_images/3010486-715848a226903c35.png?imageMogr2/auto-orient/strip|imageView2/2/w/570/format/webp)

组相连中的行匹配和字选择

**③ 全相连高速缓存（只有一个组）：只适合小规模的高速缓存（翻译备用缓冲器）**



![img](https://upload-images.jianshu.io/upload_images/3010486-80dd1eaebad05ca5.png?imageMogr2/auto-orient/strip|imageView2/2/w/599/format/webp)

全相连高速缓存中的行匹配和字选择

**④ 结构剖析（真正意义上的高速缓存）**



![img](https://upload-images.jianshu.io/upload_images/3010486-28f019ba39014782.png?imageMogr2/auto-orient/strip|imageView2/2/w/428/format/webp)

Intel Core I7高速缓存层次结构

在实际的商用CPU中，将高速缓存分为d-cache数据高速缓存，i-cache指令高速缓存和同一的高速缓存，i7的架构中我们可以看出，L1分为数据和指令高速缓存，共享L2高速缓存，同时每个核共享L3高速缓存

#### 1.5 编写高速缓存友好的代码指导意见

------

> 1.对局部变量的反复引用是好的，因为编译器能将它们缓存在寄存器文件中；
>
> 2.步长为1的引用模式是最好的；
>
> 3.多维数组的访问，注意使用行优先模式。

#### 1.6 高速缓存对程序性能的影响

------

**① 存储器山**



![img](https://upload-images.jianshu.io/upload_images/3010486-226c4bf46c08eff6.png?imageMogr2/auto-orient/strip|imageView2/2/w/560/format/webp)

存储器山

存储器的性能不能简单的用一个数字来描述，如果实在要形容的话，是一座时间局部性和空间局部性构成的山。山峰和低谷的差别不是一个数量级。明智的程序员会试图构造运行在山峰的程序而不是低谷。我们来看看这座存储器山是如何画出来的？

测试核心代码：



![img](https://upload-images.jianshu.io/upload_images/3010486-211ee17dbff322e3.png?imageMogr2/auto-orient/strip|imageView2/2/w/389/format/webp)

读取数组的内容到寄存器中

这段代码所做的事情，就是将data数组的内容依次读取到CPU的寄存器中。其中elems代表的是data的工作集大小也就是size时间局部性，代表Y轴；而stride（步长）代表的是横轴X；Z轴表示吞吐量，Mb/s。越往上吞吐量越大（红色部分）。我们反复以不同的size和stride值调用我们的核心测试代码，就会得到如上图的存储器山。

最高处的红色山峰为L1，由于工作集（size）很小，能全部保存在L1高速缓存中，所以这时候即使stride很长，对于性能也没太大的影响。

L2和L3、主存随着stride的增加有明显的坡度，空间局部性下降。特别明显的是，主存的蓝色山峰，**即使工作集很大（时间局部性极地）其stride（空间局部性）的影响也相当的明显，**最高与最低处相差7倍。也就是告诫我们，即使时间局部性无法改变了，空间局部性也可以使得程序的性能极大的提高。

② 从新排列循环以提高空间局部性

考虑一对2*2数组的相乘的问题：



![img](https://upload-images.jianshu.io/upload_images/3010486-58de10cc26ef35e2.png?imageMogr2/auto-orient/strip|imageView2/2/w/409/format/webp)

数组A乘以数组B等于数组C

矩阵的乘法是由三层嵌套的循环构成的，我们假设i是数组A的循环计数，j是数组B的循环计数，k是数组C的循环计数：



![img](https://upload-images.jianshu.io/upload_images/3010486-365ded82bb7caefd.png?imageMogr2/auto-orient/strip|imageView2/2/w/298/format/webp)

三个不同的循环版本

我们看一下不同版本代码分析：

# 《深入理解计算机系统 》 | 链接

![img](https://upload.jianshu.io/users/upload_avatars/3010486/d9eee8450714.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[唐鱼的学习探索](https://www.jianshu.com/u/0129e34fa381)关注

0.1552017.04.01 11:56:21字数 5,521阅读 2,062



![img](https://upload-images.jianshu.io/upload_images/3010486-a5b27d9a29670566.JPG?imageMogr2/auto-orient/strip|imageView2/2/w/601/format/webp)

目  录

链接是将各种不同文件的代码和数据部分收集（符号解析和重定位）起来并组合成一个单一文件的过程。本章节我们将要学习链接器工作的详细原理。通过对这一方面知识的学习，将有助于理解一些危险的编程错误、分离编译的过程、作用域的实现以及如何利用共享库等等。我们将静态链接和动态链接（加载时共享、运行时共享）两个大的方向讲起。废话不多说，开始飙车了。

#### 1.1 编译驱动程序如何工作？

------

在我的raspberrypi上我创建了两个c程序源文件：main.c和swap.c



![img](https://upload-images.jianshu.io/upload_images/3010486-25f5ed40d70d4a6a.png?imageMogr2/auto-orient/strip|imageView2/2/w/390/format/webp)

文件目录

文件内容



![img](https://upload-images.jianshu.io/upload_images/3010486-96235578fc41a1dd.png?imageMogr2/auto-orient/strip|imageView2/2/w/790/format/webp)

main.c和swap.c

我们通过gcc驱动程序：



![img](https://upload-images.jianshu.io/upload_images/3010486-245eb0f8f6ba9e84.png?imageMogr2/auto-orient/strip|imageView2/2/w/431/format/webp)

gcc驱动程序

在第一章我们解释过编译驱动程序所完成的工作，如下图：



![img](https://upload-images.jianshu.io/upload_images/3010486-57e6f7e02c4082ad.png?imageMogr2/auto-orient/strip|imageView2/2/w/673/format/webp)

gcc完成的工作

先是由预处理器（cpp）将main.c翻译成中间文件：main.i，接下来是编译器（cc1）将main.i翻译成汇编文件main.s。然后是汇编器（as）将main.s翻译成一个可重定位的目标文件main.o。最后由链接器（ld）将main.o和swap.o以及一些系统目标文件组合起来，创建可执行目标文件p



![img](https://upload-images.jianshu.io/upload_images/3010486-dc69ba053b205af7.png?imageMogr2/auto-orient/strip|imageView2/2/w/357/format/webp)

静态链接

**在以上的这个过程中ld链接器的主要工作：**

**① 符号解析。**目标文件定义和引用符号，符号解析的目的是将每个符号引用和一个符号定义联系起来；

**②重定位：**把每个符号定义与一个存储器位置联系起来，然后修改对这些符号的引用，是的他们指向这个存储器位置，从而实现重定位。

为了理解这一过程，我们需要补充一些基础知识。

#### 1.2 链接器操作的目标文件究竟是什么？

------

目标文件一般是由汇编器生成的.o后缀的文件，大概有三种不同的形式：可重定位目标文件；可执行目标文件和共享目标文件。我们接下来讨论的目标文件是基于Unix系统的ELF格式（Exxcutable and Linkable Format），这同Windows系统上的PE（Portable Executable）文件格式在基本概念上其实是相似的：

**①一个典型的ELF可重定位目标文件的格式：**



![img](https://upload-images.jianshu.io/upload_images/3010486-f5ea954f51122c88.png?imageMogr2/auto-orient/strip|imageView2/2/w/276/format/webp)

一个典型的ELF格式可重定位目标文件

> 解释：
>
> .text：已编译程序的机器码；.rodata：只读数据（read-only-data）；
>
> .data：已初始化的全局C变量；.bss：未初始化的全局C变量（better save space）;
>
> .symtab：一个符号表（定义和引用的函数和全局变量信息）；
>
> .rel.text：代码重定位条目， 一个.text节中位置的列表，需要修改的位置;
>
> .rel.data: 被模块引用或定义的任何全局变量的重定位信息；
>
> .debug：一个调试符号表； .line：原始C源程序中的行号和.text机器指令的映射；
>
> .strtab: 一个字符串表

**② 符号和符号表（链接器的第一个任务符号解析）**

保存于.symtab中的是一个符号表，其是定义和引用函数和全局变量的信息。有三种不同类型的符号：全局符号（不带static），外部引用（external）和本地符号。如果是带有static符号的就会在.data和.bss中为每个定义分配空间，并在.symtab中创建一个唯一名字的本地符号。比如：



![img](https://upload-images.jianshu.io/upload_images/3010486-5b4ec813d1980ce2.png?imageMogr2/auto-orient/strip|imageView2/2/w/244/format/webp)

中有两个static定义的x变量，其会在.data中分配空间，并在.symtab中创建两个，x.1表示f函数的定义和x.2表示函数g的定义。（注：使用static可以保护你自己的变量和函数）

**.symtab符号表的数据结构：**



![img](https://upload-images.jianshu.io/upload_images/3010486-e3554450caf038dd.png?imageMogr2/auto-orient/strip|imageView2/2/w/703/format/webp)

我们给出main.o符号表中的最后三个条目：（开始的都是使用的本地符号）



![img](https://upload-images.jianshu.io/upload_images/3010486-de2217a5f3033596.png?imageMogr2/auto-orient/strip|imageView2/2/w/434/format/webp)

我们看到num8处，的全局变量buf定义条目，位于.data(Ndx=3)开始字节偏移为0（value为0）处的8个字节目标（size）。随后是全局符号main的定义，其位于.text(Nex=1)处，偏移字节为0处（value）的17个字节函数。最后一个是swap的引用，所以是Und。

#### 1.3 链接器开始工作了

------

**① 符号解析（开始链接器的第一个任务）**

符号解析任务简单的说，就是链接器使得所有模块中的每个符号只有一个定义。链接器在这一个阶段的主要任务就是把代码中的每个符号引用和确定的一个符号定义联系起来。对于本地符号，这个任务相对来说是简单的。复杂的就是全局符号，编译器（cc1）遇到不是在当前模块中定义的符号时，会假设该符号的定义在其他模块中，生成一个链接器符号交给链接器处理。如果链接器ld在所有的模块中都找不到定义的话就会抛出异常。

这里最容易产生的错误就是当多个模块定义同一个符号的时候，我们的链接器到底怎么做。以C++中的函数重载为例，我们会按照实际的需要重载许多相同名字的函数，链接器（ld）使用一种叫做毁坏的方法（mangling）将相同函数名不同参数的函数，比如Foo将会编码成3Foo__的形式，实际上还是使得在链接器层面上来看符号是唯一的。

**链接器如何解析多重定义的全局符号：**

**使用如下规则**

> 规则1：不允许多个强符号；
>
> 规则2：如果有一个强符号和多个弱符号，那么选择强符号；
>
> 规则3：如果有多个弱符号，那么这些弱符号中任意选择一个；

**举个例子：链接器试图编译和链接下面两个模块就会参数错误：**



![img](https://upload-images.jianshu.io/upload_images/3010486-4121cef624a2270b.png?imageMogr2/auto-orient/strip|imageView2/2/w/462/format/webp)

规则1：不允许多个强符号（两处定义了main）

**第二个例子：如果模块中有x未被初始化，链接器会选择定义在另外一个模块中的强符号（这会导致许多不易察觉的错误）**



![img](https://upload-images.jianshu.io/upload_images/3010486-129ee9f1aaa80043.png?imageMogr2/auto-orient/strip|imageView2/2/w/480/format/webp)

会输出x=15212，规则2，函数f将很低调的将x改成15212，对main带来不易察觉的意外！特别是当重复定义的符号有不同的类型时，需要特别的谨慎。编译系统不会发出任何警告，而且会在程序执行很久以后才表现出来。使用GCC-fno-common可以告诉链接器，遇到这类情况，输入一条警告。

**如何链接和解析静态库**

**链接静态库：**

像printf等一些常用的函数，都是在libc.a静态库中，静态库以一种存档的特殊文件（.a）格式，将可以定位的目标文件集合成一个.a文件。举一个实际的例子：

我的raspberry上创建有这样的文件：



![img](https://upload-images.jianshu.io/upload_images/3010486-700cad7c67bfdaf1.png?imageMogr2/auto-orient/strip|imageView2/2/w/361/format/webp)

文件目录

其中：



![img](https://upload-images.jianshu.io/upload_images/3010486-da01815706346f51.png?imageMogr2/auto-orient/strip|imageView2/2/w/790/format/webp)

两个库：addvec.o和multvec.o

我们使用vector.h声明这两个函数：



![img](https://upload-images.jianshu.io/upload_images/3010486-3ea0014460010c31.png?imageMogr2/auto-orient/strip|imageView2/2/w/414/format/webp)

vector.h

同时使用：main2.c进行函数的调用：



![img](https://upload-images.jianshu.io/upload_images/3010486-9bf70a28833c98c4.png?imageMogr2/auto-orient/strip|imageView2/2/w/644/format/webp)

main2.c

我们现在使用AR工具创建一个静态库：libvector.a文件：



![img](https://upload-images.jianshu.io/upload_images/3010486-d270f9a8dd53b4cd.png?imageMogr2/auto-orient/strip|imageView2/2/w/596/format/webp)

创建libvector.a文件

现在我们使用main2.c函数调用libvector.a库



![img](https://upload-images.jianshu.io/upload_images/3010486-425431addd3add36.png?imageMogr2/auto-orient/strip|imageView2/2/w/528/format/webp)

链接静态库libvector.a

这样一个过程可以用下图说明：



![img](https://upload-images.jianshu.io/upload_images/3010486-a56677ede8a55219.png?imageMogr2/auto-orient/strip|imageView2/2/w/603/format/webp)

与静态库链接

解析静态库：解析静态库的过程是按照命令行标识的文件顺序从左到右解析，如果输入文件是一个目标文件(.o)，那么将文件添加到集合E（合并成执行文件）；如果f是一个存档文件（.a），那么就尝试解析集合U（未解析的符号），能够解析的话就将其加载到集合E中去；重复这样的过程直到都解析完毕。

**② 重定位**

完成了符号解析以后，链接器的第二个任务就是合并输入模块，并为每个符号分配运行时的地址。**重定位节和符号定义：**在这一步中，链接器将所有模块中的.data节合并成一个文件的.data节，运行时存储器的地址也会赋给新的聚合节。然后就是，**重定位节中的符号引用：**链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行时地址。这一步要用到重定位条目这一数据结构，我们来描述这个过程：

**重定位条目：**我们在1.2讲述ELF文件格式的时候说过，.rel.text代表代码重定位条目；.rel.data是已经初始化数据的重定位条目。数据结构如下图：



![img](https://upload-images.jianshu.io/upload_images/3010486-7cd5047c4892996b.png?imageMogr2/auto-orient/strip|imageView2/2/w/908/format/webp)

（注：当汇编器生成一个.o文件模块的时候，它不知道数据和代码最终会放到存储器的什么位置，它只是生成一个重定位条目，放到.rel.text中告诉大家这个内容会在以后修改）

说明：

> offset：是需要修改的引用节的偏移；
>
> symbol：标识被修改引用应该指向的符号；
>
> type：告诉连接器如何修改新的引用；

ELF有11种不同的重定位类型：我们只关心常用的两种

R_386_PC32（相对地址引用）和R_386_32（绝对地址引用）

有了重定位的条目，我们也知道了有两种不同的重定位类型，我们下面来看看如何进行符号引用的重新定位：

**重定位符号引用：**

我们先来看看一段重定位算法的伪代码：



![img](https://upload-images.jianshu.io/upload_images/3010486-33f22824c94ff95f.png?imageMogr2/auto-orient/strip|imageView2/2/w/790/format/webp)

假设每个节s是一个字节数组，每个重定位条目r是一个Elf32_Rel结构，第三行计算的是需要被重新定位的引用数组s中的地址。然后就根据r的type类型进行不同的类型的重定位。上图展示的就是相对地址引用和绝对地址引用两种模式。

**例子1：相对地址引用模式（R_386_PC32）**

我们回到最开始讲述的main.c和swap.c程序，来看看main.c中的反汇编列表的一个片段：



![img](https://upload-images.jianshu.io/upload_images/3010486-8718bc395685a6c7.png?imageMogr2/auto-orient/strip|imageView2/2/w/672/format/webp)

这里我们看到call指令开始于字节偏移0x6处的位置，swap函数在main处偏移0x7处的位置。重定位类型使用的是R_386_PC32模式（相对地址引用）。重定位条目的数据结构如下：



![img](https://upload-images.jianshu.io/upload_images/3010486-a523d91f3cdf7953.png?imageMogr2/auto-orient/strip|imageView2/2/w/241/format/webp)

Elf32_Rel结构

这个结构告诉我们，修改偏移量为0x7的相对引用，使得它能指向swap程序的位置。假设：两处的地址为：

> ADDR（s）       = ADDR（.text）= 0x80483b4;
>
> ADDR(r.symbol) = ADDR(swap)   = 0x80483c8;

使用refaddr算法计算出引用运行时候的地址为：refaddr = addr（s）+0x7 = 0x80483bb。然后计算出*refptr：



![img](https://upload-images.jianshu.io/upload_images/3010486-a9f655b98a9a2a04.png?imageMogr2/auto-orient/strip|imageView2/2/w/517/format/webp)



![img](https://upload-images.jianshu.io/upload_images/3010486-1036a97f18e82f1e.png?imageMogr2/auto-orient/strip|imageView2/2/w/617/format/webp)

我们使用的是原值是（-4）经过计算后将修改*refptr为0x9；下面我们来看看置顶到call指令时候的地址情况：

我们看到当前地址外80483ba，CPU执行call指令的时候PC的值是下一条指令的地址80483bf，由于是相对地址引用模式，我们使用计算出来的0x9（*refptr）来重定位执行swap函数的位置：



![img](https://upload-images.jianshu.io/upload_images/3010486-881508565eb404a5.png?imageMogr2/auto-orient/strip|imageView2/2/w/465/format/webp)

这就是我们之前假设的swap地址的地址。（注：*refptr为什么初始为-4，因为pc总是指向当前指令的下一条指令，不同的机器可能有不同的偏移量）

**例子2：绝对地址引用模式（R_386_32）**

我们再来示例程序swap.o中int *bufp0 = &buf[0]的情况。反汇编列表如下：



![img](https://upload-images.jianshu.io/upload_images/3010486-1d258eaab31668a5.png?imageMogr2/auto-orient/strip|imageView2/2/w/717/format/webp)



![img](https://upload-images.jianshu.io/upload_images/3010486-ac917f3aca9f8961.png?imageMogr2/auto-orient/strip|imageView2/2/w/655/format/webp)

由于bufp0是一个已经被初始化的数据目标，在ELF文件结构中位于.data字段位置，反汇编列出的情况表明其位于偏移0x0处且使用R_386_32绝对地址引用模式。现在我们假设地址已经确定是：**addr(r.symbol) = addr(buf) = 0x8049454**链接器使用我们前面讲过的算法修改引用：



![img](https://upload-images.jianshu.io/upload_images/3010486-14943b866a10f877.png?imageMogr2/auto-orient/strip|imageView2/2/w/568/format/webp)

这样就使得refptr直接指向了buf的地址（08049454）也就是如下图所示：

总而言之，链接器绝对在运行时变量bufp0将存放于存储器0x804945c处，并且初始化为0x8049454即buf地址的内容。

#### 1.4 链接器完成工作后生成的目标文件是个什么？

------

通过前面知识的学习，我们了解到链接器主要完成了两个工作，符号解析和重新定义。将数据和代码合并成为一个可执行的文件，接下来我们看看这个可执行文件的格式是什么，以及如何加载到存储器中开始运行的过程。



![img](https://upload-images.jianshu.io/upload_images/3010486-f3a09952bf9326be.png?imageMogr2/auto-orient/strip|imageView2/2/w/450/format/webp)

**① 可执行目标文件格式（一个典型的ELF可执行文件）**

> 说明：
>
> ELF头部：描述文件总体格式，标注出程序入口点；.init：定义了初始化函数;
>
> 段头部表：可执行文件是一个连续的片，段头部表中描述了这种映射关系；



![img](https://upload-images.jianshu.io/upload_images/3010486-245eb0f8f6ba9e84.png?imageMogr2/auto-orient/strip|imageView2/2/w/431/format/webp)

我们在开始的时候使用main.c和swap.c生成了可执行文件p



![img](https://upload-images.jianshu.io/upload_images/3010486-778dfc986d9a2fef.png?imageMogr2/auto-orient/strip|imageView2/2/w/886/format/webp)

我们来看看这个执行文件的反汇编代码：

> 说明：在段头部表中，我们会看到程序初始化为两个存储器字段，行1和行2是代码段，有读和执行的权限（flags：r-x），开始于存储器地址0x08048000处（vaddr/paddr），该字段大小为0x448（memsz），并且初始化为可执行目标文件的头0x448个字节（filesz）；行3和行4是数据段，有读写的权限（flags），开始于存储器地址：0x08049448处，总大小0x104个字节（memsz），从文件偏移0x448（off）处开始的0xe8（filesz）个字节初始化。

**② 如何加载可执行目标文件**



![img](https://upload-images.jianshu.io/upload_images/3010486-865dbae0f07c3f10.png?imageMogr2/auto-orient/strip|imageView2/2/w/491/format/webp)

运行时的存储器映像

加载后运行的每个Unix程序都有一个镜像，如上图所示。代码段总是从0x08048000开始，数据段是接下来的4kb对齐地址处，运行时堆在读写段之后，使用malloc向上增长；还有一个段为共享库保留。用户栈是在最大合法地址处开始并向下增长。再往上就是不对用户开放的内核虚拟存储器了。

**什么是加载？**说白了就是将程序拷贝到存储器并运行的过程。这里是由execev函数来调用加载器（驻留在存储器中）完成的，我们要执行p文件的时候，就是使用./p来，加载器就把p的数据和代码拷贝从磁盘拷贝到了存储器中，并通过跳转到ELF头部中的程序入口点开始程序p的执行。

**怎样加载？**当加载器运行时，就先创建一个存储器映像（上图所示），在ELF可执行文件头部表的指示下，加载器将可执行文件的代码和数据段拷贝到0x0804800处向上的两个段中，然后跳转到程序入口点_start（在ctrl.o中定义）开始执行

#### 1.5 动态链接共享库

------

**① 编译时加载**



![img](https://upload-images.jianshu.io/upload_images/3010486-5b2b951f27e58469.png?imageMogr2/auto-orient/strip|imageView2/2/w/442/format/webp)

静态库需要定期的维护和更新，调用的代码还会拷贝到每个运行的进程中去，这是对存储器系统资源的极大浪费。为了弥补这样的缺陷，我们发明了共享库。共享库的一个主要目的就是允许多个正在运行的进程共享存储器中相同的库代码，节约资源。以(.so)结尾的文件，在运行时被加载到任意存储器地址，并和存储器中的程序链接起来，以后的进程要用到这个库就从这个固定的位置开始访问。这一过程的管理交由动态链接器程序来执行。



![img](https://upload-images.jianshu.io/upload_images/3010486-43e61402a172a2c5.png?imageMogr2/auto-orient/strip|imageView2/2/w/634/format/webp)

我们实际来创建一个.so文件：使用如下方式

说明：-shared指示链接器创建一个共享目标文件；-fPIC生成与位置无关代码



![img](https://upload-images.jianshu.io/upload_images/3010486-ca6cc84a00c3907c.png?imageMogr2/auto-orient/strip|imageView2/2/w/518/format/webp)

然后创建可执行文件p2：

这个思路很重要：当p2生成的时候没有任何libvector.so的代码和数据被真正拷贝到p2中去，它是在运行的时候与libvector.so链接，p2中只是拷贝了一些重定位和符号表。当加载器加载p2程序开始运行的时候，动态链接器注意到p2中有.interp节，加载器就会加载和运行动态链接器，动态链接器重定位.so的文本和数据到一个存储器段中，然后将p2中的符号引用重新定位到存储器段中已经加载的.so文本和数据的位置。动态链接器完成这些工作以后就会把控制权交给p2，由于共享库(.so)位置固定好了，程序就会开始执行。

**② 运行时加载共享库**



![img](https://upload-images.jianshu.io/upload_images/3010486-f6a663f53136fdb9.png?imageMogr2/auto-orient/strip|imageView2/2/w/455/format/webp)

微软的windows程序开发人员提供共享库来更新软件，通常要求下载最新的dll库，然后在程序下一次执行的时候会自动链接和加载更新后的共享库。我们创建dll.c文件，运行时加载libvector.so

> **说明：**
>
> 1>使用dlopen打开本地libvector.so共享库，并解析库中的符号;
>
> 2>使用dlsym访问其中的addvec函数，如果存在就返回该函数的地址;
>
> 3>使用dlclose卸载共享库；



![img](https://upload-images.jianshu.io/upload_images/3010486-f5f4a70552b3e5d1.png?imageMogr2/auto-orient/strip|imageView2/2/w/569/format/webp)

开始编译运行时共享库：

#### 1.6 与位置无关的代码

------

我们前面讲过，使用-fPIC（Position-Independent Code）生成与位置无关代码，使得多个进程可以共享相同的库代码。那么多个进程究竟是如何共享程序的一个拷贝库呢？

我们使用的编译库代码，使得这一部分的库代码直接可以加载到存储器中执行，这一过程不需要链接器修改库代码的内容。这样的代码就叫做与位置无关的代码。对于模块内部的调用不需要特殊处理，但是外部定义的函数调用和全局变量的引用就需要链接时重定位。

**① PIC数据引用**



![img](https://upload-images.jianshu.io/upload_images/3010486-a60c39c40a674341.png?imageMogr2/auto-orient/strip|imageView2/2/w/619/format/webp)

当存储器加载一个共享目标模块的时候，数据段总是被分配到紧跟着代码段后，因此任何指令和任何变量之间的距离在运行时都是一个常量。这个很好的特性就被运用起来，编译器在数据段开始地方创建了GOT表（Global Offset Table）（全局偏移量表）如main2.o中的GOT表：

> .dynamic：段的地址，包含动态链接器用来绑定函数地址的信息（符号表、重定位）；
>
>  GOT[1] ：定义模块的信息；GOT[2]：延迟绑定代码入口；



![img](https://upload-images.jianshu.io/upload_images/3010486-26bfa61d42557401.png?imageMogr2/auto-orient/strip|imageView2/2/w/521/format/webp)

每个被main2.o引用的全局数据对象都有一个条目，编译器还会为每个条目生成一个重定位地址。在加载时动态链接器会重定位到每个正确的地址。我们来看看数据的引用过程：

pop将当前的pc弹出到ebx中，随后的add指令加上一个常量，使得指向正确的变量位置，此处包含了该变量的绝对地址。后面的两条mov指令：第一条eax存放了变量的绝对地址，第二条获取该绝对位置处的值，放入到eax中；

**② PIC函数调用**



![img](https://upload-images.jianshu.io/upload_images/3010486-33b0ed2f31e881f6.png?imageMogr2/auto-orient/strip|imageView2/2/w/612/format/webp)

使用延迟绑定技术，通过GOT与过程链接表PLT（Procedure Linkage Table），将过程的地址绑定延迟到第一次调用该过程时（第一次调用的开销较大）。p2中的PLT表如图：

第一个PLT[0]是一个特殊条目，它跳转到动态链接器中，从PLT[1]开始是每个函数的过程链接表；当addvec被第一次调用的时候（不会立即绑定，延迟一下）将控制传递到PLT[2]中的第一条指令中，jmp *0x8049684（跳转到GOT[4]内容为：804846a）又回到了pushl指令处将addvec压入栈中。然后通过jmp 8048444跳转到PLT[0]动态链接器中。动态链接器通过两个栈条目来确定addvec的位置，用这个地址覆盖GOT[4]，并把控制权转到addvec。

下次访问的方式还是通过传递控制权到PLT[2]中，但这次得到的GOT[4]的地址已经被延迟绑定好了。这样唯一的开销就是间接跳转。

![img](https://upload-images.jianshu.io/upload_images/3010486-3972a94c844651c1.JPG?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

上传分析图我们简单的说一下，核心的思想就是最后一个版本：kij执行的效率高很多。最主要的一点就是，在最后一个版本中，每次循环是按照行优先的顺序一步步最后求得数组C的值。

我们认为下列要求是不言而喻的，来结束这一章节的讲解：

> 1.将你的注意力集中在内循环上，大部分计算的存储器访问都集中在这里；
>
> 2.通过�按照数据实际在存储器中存放的顺序，以步长为1来访问，空间局部性最优；
>
> 3.一旦从一个存储器中读了一个数据出来，就尽可能多的利用他（kij版本）。

# 《深入理解计算机系统》| 虚拟存储器

![img](https://upload.jianshu.io/users/upload_avatars/3010486/d9eee8450714.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[唐鱼的学习探索](https://www.jianshu.com/u/0129e34fa381)关注

0.552017.04.19 07:07:35字数 10,679阅读 2,165



![img](https://upload-images.jianshu.io/upload_images/3010486-7e6afefb0dad1db7.png?imageMogr2/auto-orient/strip|imageView2/2/w/958/format/webp)

虚拟存储器又叫做虚拟内存，我们现在的操作系统普遍都支持了虚拟内存，这样做是因为我们同时运行着太多的程序了，就目前我电脑的状态来看，我既要打开浏览器，又要听歌，可能同时还登陆的有QQ，如果不使用虚拟内存4G的内存空间很快就会被耗尽，而一旦没有了内存空间，其他程序就无法加载了。虚拟内存的出现就是为了解决这个问题，当一个程序开始运行的时候，其实是为每个程序单独创建了一个页表（这个以后讲），只将一部分放入内存中，以后根据实际的需要随时从硬盘中调入内容。当然虚拟内存不仅仅只有这个功能，我们的操作系统也是在内存中运行着的，虚拟内存同时还提供了一种保护，这样做其他进程就不会损坏掉系统的内存空间。那么虚拟内存是如何实现的呢？

#### 1.1 物理寻址和虚拟寻址

------

虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：物理地址和虚拟地址。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。我们来看看什么是物理寻址：



![img](https://upload-images.jianshu.io/upload_images/3010486-92cb095c68ff3959.png?imageMogr2/auto-orient/strip|imageView2/2/w/356/format/webp)

主存的每个地址都是唯一的，第一个字节地址为0，接下来为2，以此类推。CPU使用这种访问方式就是**物理寻址**。上图所示就是CPU通过**地址总线**传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。

当然地址总线也不是无限大的，我们通常所说的32位系统，其寻址能力是2^32 = 4 294 967 296B（4GB）也就是说内存条插的再多也没有用，地址总线只能最多访问到4GB的地址内容。我们前面说过4GB的物理内存空间其实并不大（如果是独占的话）。这时候科学家们想到了一个很好的方法，建立虚拟寻址方式，使用一个成为MMU的地址翻译工具将虚拟地址翻译成物理地址在提供访问，如下图：



![img](https://upload-images.jianshu.io/upload_images/3010486-936b0ad750173e18.png?imageMogr2/auto-orient/strip|imageView2/2/w/583/format/webp)

使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。

我们说过虚拟地址要比物理地址大的多，为啥还要麻烦的将物理地址转成虚拟地址呢？虚拟地址的发明究竟是为了什么，我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就创建了一个虚拟存储器，管理着磁盘，以每页的方式进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。

#### 1.2 地址空间

------

地址空间是一个非负整数的集合{0，1，2，……}，一个32位的系统中有：2^32 = 4 294 967 296B（4GB）个有效地址。地址空间的概念很重要，我们必须要清楚数据对象（字节）和它的属性（地址）的区别， 举个例子：我和我老婆住在苍溪县xx小区7栋1单元，这个就是我的属性：地址。另外，住在家的我和我老婆就是数据对象（字节）。虚拟存储器的基本思想是：主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。

#### 1.3 虚拟存储器的工作原理

------

我们先来看看虚拟内存，就windows系统而言是保存�在磁盘上的一个文件，存放于C盘的pagefile.sys点击属性可以看到其大小为3.96G，这相当于一个仓库，保存着临时需要又还没用到的数据。



![img](https://upload-images.jianshu.io/upload_images/3010486-060f274f32369c43.png?imageMogr2/auto-orient/strip|imageView2/2/w/655/format/webp)

这个仓库的的数据被分割成块，称为虚拟页。虚拟存储器的主要思想就是：在主存中缓存硬盘上的虚拟页（pagefile.sys），虚拟页有三个状态：未分配、缓存的、未缓存的。



![img](https://upload-images.jianshu.io/upload_images/3010486-07487b299e61a6e4.png?imageMogr2/auto-orient/strip|imageView2/2/w/488/format/webp)

上图所示的是一个有8个虚拟页的小虚拟存储器（建立在硬盘上），虚拟页0和3还未分配，因此在磁盘上还不存在。虚拟页1、4和6被缓存在右边的主存中。

(内存访问速度要比硬盘快10000倍，因此不命中的话代价要昂贵的多。我们前面说过是以虚拟页来缓存的，也就是分成块，每个块（虚拟页）的大小4kb-2mb不等。)

我们现在来看看地址翻译MMU是如何完成虚拟地址到物理地址的转换的，学习这个知识是帮助我们理解虚拟存储器是如何将虚拟也缓存到主存（内存）中去的。

**① 页表**

页表是一个存放在内存中的数据结构，MMU就是通过页表来完成虚拟地址到物理地址的转换。这个数据结构每一个条目称为PTE（Page Table Entry），由两部分组成：有效位和n位地址段。有效位如果是1，那么n位地址就指向已经在内存中缓存好了的地址；如果为0，地址为null的话表示为分配，地址指向磁盘上的虚拟内存（pagefile.sys）的话就是未缓存。我们来看一个典型的页表图：



![img](https://upload-images.jianshu.io/upload_images/3010486-b2245469f22f16a7.png?imageMogr2/auto-orient/strip|imageView2/2/w/467/format/webp)

虚拟页vp1,2,7,4当前被缓存在内存中，页表上有效位设置成1，分别用PTE1，2，4，7表示。VP0和VP5（PTE0、5）未被分配，VP3和VP6被分配并指向虚拟内存，但未被缓存。

**② 页命中**



![img](https://upload-images.jianshu.io/upload_images/3010486-beb70c414991d8d7.png?imageMogr2/auto-orient/strip|imageView2/2/w/537/format/webp)

当我们使用2100虚拟地址来访问虚拟页2的内容的时候，就是一个页命中。地址翻译将指向PTE2上，由于有效位1，地址翻译器MMU就知道VP2已经缓存在内存中了。就使用页表中保存的物理地址进行访问。

**③ 缺页**



![img](https://upload-images.jianshu.io/upload_images/3010486-037dc8760ded9781.png?imageMogr2/auto-orient/strip|imageView2/2/w/579/format/webp)

我们再来看看不命中，也就是缺页的情况，当CPU需要VP3的一个字时，初始化是这样的：



![img](https://upload-images.jianshu.io/upload_images/3010486-76a3641d0b21b1b9.png?imageMogr2/auto-orient/strip|imageView2/2/w/583/format/webp)

PTE3有效位是0，同时地址位指向了虚拟内存（pagefile.sys），就会触发缺页异常。异常处理程序会选择牺牲一个内存（DRAM）中的页，本例中选择的是内存中的PP3页的VP4，接下来内核就从虚拟内存中拷贝VP3到内存中的PP3，并使得PTE3指向内存中的PP3，形成如下：

（注：虚拟存储器出现早于高速缓存，按照习惯的说法块被叫做页。从虚拟内存到物理内存传送页的活动就叫做页面交换。）

#### 1.4 虚拟存储器的作用

------



![img](https://upload-images.jianshu.io/upload_images/3010486-884dfb9591371853.png?imageMogr2/auto-orient/strip|imageView2/2/w/472/format/webp)

虚拟存储器有诸多的好处，操作系统其实为每个进程提供了一个独立的页表，使用不同的页表也就创建了独立的虚拟地址空间，下图展示了基本思想：

进程i将VP1映射到了内存的PP2处，VP2映射到了内存的PP7处。进程j将VP1映射到了内存的PP7，将VP2映射到了PP10处。

**简化链接：**每个进程一个页表后，这个进程就会觉得全世界都是它的（页表模拟出一个虚拟存储器），那什么符号链接的时候（也就是符号映射到地址的时候），不再会受到内存中还有其他应用程序的干扰，因为我们面向的是虚拟存储器，我们的进程的地址空间是独立的，我这个符号放到离0偏移100的地方，那个放到离0偏移200的地方很容易就搞定了。

**简化加载：**在硬盘中双击一个图标，启动一个应用程序时，实际上你都不需要将这个程序从硬盘给加载到内存，只需要建个页表，然后页表里的编号指向的是硬盘，然后CPU访问到具体代码的时候，再按照上一节的寻址的方式，按需的将硬盘上的东东加载到内存。加载过程及其简单了。

**简化共享：**我们有很多的进程在系统中运行，但是有些代码，比如调用操作系统的API，这些API可能许多进程都要使用比如printf，这就要共享一部分内存，我们不需要将这部分内存在每个进程空间都拷贝一份，实际上每个进程都有一个页表，而不是全局只有一个，页表把共享内存映射到同一个地方。

**简化存储器分配：**当一个进程使用malloc要求额外的空间时，操作系统只需要保证形成了一个连续的虚拟页面，但可以映射到物理内存中任意的位置，可以随机分散在内存的不同位置。

**简化保护：**我们可以通过为PTE添加额外的标识位提供对存储器的保护。



![img](https://upload-images.jianshu.io/upload_images/3010486-bae90265a7c2420d.png?imageMogr2/auto-orient/strip|imageView2/2/w/623/format/webp)

通过新添加的三个标识位：SUP：内核or用户；READ:读；WRITE：写。运行在用户模式下的进程只允许访问SUP为否的页面，如果一个指令违法了访问的设置条件，就会转到保护故障，引起一个段错误。

#### 1.5 虚拟存储器工作原理详解：地址翻译



![img](https://upload-images.jianshu.io/upload_images/3010486-f89893fc7722dd6e.png?imageMogr2/auto-orient/strip|imageView2/2/w/727/format/webp)

**地址翻译**从形式上来说就是建立一个虚拟地址空间到物理地址空间的映射关系，我们前面说过MMU使用的是页表来实现这种映射。CPU中有一个专门的页表基址寄存器（PTBR）指向当前页表，使用页表进行翻译的时候方法如下：

每个虚拟地址由两部分组成：虚拟页号（VPN）+虚拟页偏移量（VPO），当CPU生成一个虚拟地址并传递给MMU开始翻译的时候，MMU利用虚拟地址的VPN来选择相应的PTE，同时将页表中的物理页号（PPN）+虚拟地址的VPO就生成了相应的物理地址。（**物理地址是由页表中的物理页号+虚拟地址中的偏移量构成**）



![img](https://upload-images.jianshu.io/upload_images/3010486-cadb6b4efe0bf87b.png?imageMogr2/auto-orient/strip|imageView2/2/w/668/format/webp)

页面命中是一个简单的过程，我们就不做详解，这里来跟踪看一下**缺页的情况：**

> 说明：①CPU生成虚拟地址；②MMU生成PTE地址从内存的页表中请求内容；③ 内存中的页表返回相应的PTE值；④ PTE的有效位是0，转到异常处理程序；⑤ 异常处理程序确定内存中的牺牲页，并将其写会到磁盘上（pagefile.sys）；⑥从pagefile.sys中调入新的文件并更新PTE。⑦ 由于PTE已经被更新好了，从新发送虚拟地址到MMU（后面就和命中的过程一样了）

我们讲了大致的地址翻译原理，有什么办法能够提高翻译的速度吗？

**① 加入高速缓存**



![img](https://upload-images.jianshu.io/upload_images/3010486-c8af0e9e2c3d350b.png?imageMogr2/auto-orient/strip|imageView2/2/w/622/format/webp)

高速缓存被发明出来的一个重要原因就是提高对内存的访问速度，我们来看看加入高速缓存后的访问示意图：

高速缓存被放在存储器和MMU之间，可以缓存页表条路。当MMU发送一个PTEA请求的时候，优先从高速缓存中寻找相应的PTE值，如果命中直接返回给MMU，如果不命中从内存中获得并发送到高速缓存，再由高速缓存返回到MMU。（高速缓存使用的是物理寻址，不涉及地址保护问题，因为MMU已经加入了保护标识位）

**② 加入翻译后备缓冲器TLB**



![img](https://upload-images.jianshu.io/upload_images/3010486-c559687fd82e6804.png?imageMogr2/auto-orient/strip|imageView2/2/w/409/format/webp)

TLB是一个小的、虚拟寻址的缓存，其中每一行都保存一个PTE块，高度相连。主要是提供虚拟地址到物理地址的翻译速度。大致范围示意图如下：

> 说明：①CPU生成一个虚拟地址并发送到MMU；② ③MMU从TLB中获取相应的PTE④翻译成相应的物理地址后从内存中请求内容；⑤ 数据从内存返回给CPU

**③ 加入多级页表**

我们来分析一下单级页表的弱势之处，然后指出改进的方法。我们双击图标运行一个程序的时候，在单级页表模式下，其实是在内存中为这个程序创建了一个页表，使得程序有了独立的地址空间。我们以32位系统4GB地址空间为例，我们将物理内存分割为虚拟的页面，每个页面保存4KB大小的内容，这样我们总共需要1048576个页面，才能瓜分所有的4GB空间。那么我们的页表要能够完成所有物理内存的映射，就必须要1048576个页表项，由于每个页表项占用4B的空间，那么我们这个页表就需要占用4194304B（4M）的内存空间，每个进程都有这样的一个4M的页表占用着内存空间，才能完成映射。



![img](https://upload-images.jianshu.io/upload_images/3010486-cbbaa9169481d5eb.png?imageMogr2/auto-orient/strip|imageView2/2/w/507/format/webp)

单级页表

我们来看看有什么方法优化一下，下面我们加入分级页表（二级）：



![img](https://upload-images.jianshu.io/upload_images/3010486-1a0da91860bb6230.png?imageMogr2/auto-orient/strip|imageView2/2/w/695/format/webp)

二级页表

我们加入分级的思想以后，每一级的页表就都只有4KB的大小，数量也有原来的1048576变成了1024个，两级相乘其实表示的数量还是原来那么多。上图所示，一级页表每条PTE负责映射二级页表1024个PTE项，二级页表的每个PTE在映射虚拟存储器中4KB大小的位置。也就是说一级页表每条PTE负责映射一块4M大小的空间，而一级页表总共有1024个页表项，也就能用来映射完成所有物理内存空间。这样做的好处是，如果一级页表中有未被分配的项目，那么这条PTE直接设置成null，不指向任何二级列表，也就不再占用空间。还有一个好处是不是所有的二级列表都需要常驻内存，每个进程只需要在内存中建立一级页表（4kb）大小，二级列表按需要的时候创建调入，这样就更省了。

**④ 综合：一个从虚拟地址到物理地址并获取数据的模拟**

为了方便讨论，我们以一个小的存储系统作如下假设：



![img](https://upload-images.jianshu.io/upload_images/3010486-ac7569bc76ce6a06.png?imageMogr2/auto-orient/strip|imageView2/2/w/564/format/webp)

**1> 虚拟地址大小14位：结构如下**



![img](https://upload-images.jianshu.io/upload_images/3010486-5fe4a742f21aebbf.png?imageMogr2/auto-orient/strip|imageView2/2/w/553/format/webp)

**2> 物理地址大小12位：结构如下**



![img](https://upload-images.jianshu.io/upload_images/3010486-248cfdef51f8aeca.png?imageMogr2/auto-orient/strip|imageView2/2/w/306/format/webp)

**3> 内存大小为4KB，物理页号为64个，每个页面大小为64B，页表如下：**



![img](https://upload-images.jianshu.io/upload_images/3010486-c2a6df3aa581f357.png?imageMogr2/auto-orient/strip|imageView2/2/w/551/format/webp)

**4> TLB 翻译后备缓存器分成4组，每组4条，一共16个条目：**



![img](https://upload-images.jianshu.io/upload_images/3010486-1b7b10114226de4f.png?imageMogr2/auto-orient/strip|imageView2/2/w/448/format/webp)

**5> 高速缓存64B大小，使用物理寻址、直接映射的方式，每行4B，共计16个组：**



![img](https://upload-images.jianshu.io/upload_images/3010486-132aa4dbe204b2a4.png?imageMogr2/auto-orient/strip|imageView2/2/w/496/format/webp)

好了，有了这些假设以后我们来看一下，当CPU读取0x03d4处内容会发生些什么：

此处是虚拟地址，0x03d4二进制表示就为：（0000 1111 0101 00）14位，由于虚拟地址的低6位用来表示偏移量（每个页面64B大小：2^6=64），剩下的高8位用来表示虚拟页号，一共有128个虚拟页号（2^8）。

**我们从虚拟地址中：**

1> 抽取出虚拟页号为：0x0f；



![img](https://upload-images.jianshu.io/upload_images/3010486-4be53e07b3fe3ca7.png?imageMogr2/auto-orient/strip|imageView2/2/w/219/format/webp)

2> 将虚拟页号与TLB进行对比，为了方便，我们形成TLBT标记位，TLBI组索引；

组索引在0x03号位置，标记也为0x03，这时候回到我们的假设“4>”处进行检查，发现0x03组，标记位0x03处的有效位是1，所以命中。取出物理页号（PPN）0D用于构造物理地址用。物理地址就为：PPN-VPO = 0x354：



![img](https://upload-images.jianshu.io/upload_images/3010486-671f071a0c6ebc4b.png?imageMogr2/auto-orient/strip|imageView2/2/w/426/format/webp)

3 > 根据物理地址：0x354，我们在高速缓存中去碰碰运气，前面假设的时候我们说过大小为64B，我们将其分成16个条目，由：标记位+有效位+块0-3组成。其实际存放数据的块每个条目只有4个（0-3）所以总大小为64B，我们的物理地址要到高速缓存中去寻找数据，就得有某种对应方式。其中物理地址的低2位用作偏移量（CO）因为每个条目只有4个数据块，紧接着的4位表示组索引，因为一共是16个组，最后的高7位作为标记位。我们形成如下的：CO=0x0，偏移量为0也就是块0的内容；CI = 0x05也就是第0x05组和CT：0x0d标志位。有了这些内容以后我们返回到假设5中去寻找，发现高速缓存中的5号索引，标记位为0x0d，并且有效，读取块0处的内容为36。这就是我们要返回给CPU的内容。至此完成了一个端到端地址翻译并返回数据的手工模拟，当然我们还可能遇到很多不同的情况。如在高速缓存中不命中，TLB不命中等等，但大致原理几乎类似，请自行脑补。

#### 1.6 案例研究：Intel CoreI7/ Linux存储系统

------

① Core i7 地址翻译：



![img](https://upload-images.jianshu.io/upload_images/3010486-fe648bd74eb970f4.png?imageMogr2/auto-orient/strip|imageView2/2/w/730/format/webp)

Core i7采用4级页表层次结构，CPU产生的虚拟地址，如果命中由TLB生成物理地址，如果不命中后通过4级页表生成物理地址。物理地址如果命中优先从L1高速缓存中获取数据，如果不命中再从主存中获取结果，最后传递给CPU



![img](https://upload-images.jianshu.io/upload_images/3010486-d481281f4f51717a.png?imageMogr2/auto-orient/strip|imageView2/2/w/782/format/webp)

四级页表详解

四级页表将虚拟地址翻译成物理地址的过程也相当简单，36位的虚拟地址被分割成4个9位的片。VPN1有一个到L1 PTE的偏移量，找到这个PTE以后又会包含到L2页表的基础地址；VPN2包含一个到L2PTE的偏移量，找到这个PTE以后又会包含到L3页表的基础地址；VPN3包含一个到L3PTE的偏移量，找到这个PTE以后又会包含到L4页表的基础地址；VPN4包含一个到L4PTE的偏移量，找到这个PTE以后就是相应的PPN（物理页号）。



![img](https://upload-images.jianshu.io/upload_images/3010486-28fa331f2459b86f.png?imageMogr2/auto-orient/strip|imageView2/2/w/654/format/webp)

页表条目格式说明：

② Linux虚拟存储系统



![img](https://upload-images.jianshu.io/upload_images/3010486-3c6c7b1155d9185a.png?imageMogr2/auto-orient/strip|imageView2/2/w/455/format/webp)

一个单独的Linux系统进程虚拟存储主要分为：内核虚拟存储器和进程虚拟存储器。

我们主要来讲一下内核虚拟存储器：由下往上是内核的代码和数据结构，是每个进程共享的数据结构和代码；再往上是一组连续的虚拟页面映射到相应的物理页面的物理存储器，大小同主存一样大，提供很方便访问物理页面的任何位置。最后是每个进程不同的是页表、task（mm）、内核栈等。

**虚拟存储器区域：**



![img](https://upload-images.jianshu.io/upload_images/3010486-e21b1e9b94524bce.png?imageMogr2/auto-orient/strip|imageView2/2/w/616/format/webp)

区域就是我们通常说的段，text、data、bss都是不同的区域，这些区域是被分为连续的片。每个虚拟页面都在不同的段中，不属于某个段的虚拟页面是不存在的，且不能被使用。我们来看看内核中的一个task数据结构（mm）：

task_struct是位于内核虚拟存储器中对于每个进程的都不同的内核数据结构，包含运行该进程所需要的基本信息（PID、可执行文件名称、程序计数器等）。这个结构中有一个mm字段，指向的是mm_struct中的pgd和mmap，其中pgd是一级页表的基地址，mmap指向的是一个vm_area_structs的链表，每个该链表中的一个元素描述的是当前虚拟地址空间的一个段（text、data、bss等），当内核运行该进程的时候CR3寄存器就被放入了pgd。

**Linux缺页异常处理：**

我们将了一些存储器区域划分的基础知识，并且介绍说mmap指向的是一个链表，这个链表中的每个元素都指向该进程的相应的段，其中vm_strat是段开始的地方，vm_end是段结束的地方。

1> 访问地址是否合法：缺页处理程序只需要将这个地址A与vm_area_struct链表中的每个元素的start和end数据比较，如果都没有的话，表示该地址不在相应的段中。就是一个段错误。

2> 保护异常：vm_area_struct中的vm_prot结构是包含了所有页面的读写权限，所以当对只有读权限的文本内容写入数据的时候，就会引发保护异常。



![img](https://upload-images.jianshu.io/upload_images/3010486-4662a4c5773ccb46.png?imageMogr2/auto-orient/strip|imageView2/2/w/507/format/webp)

3> 最后，正常缺页。也就是相应的页面不在物理内存的时候，缺页程序就会锁定一个牺牲页面，将它的内容与实际需要的内容交换过来，当缺页程序返回的时候就可以正常的访问了。

#### 1.7 存储器映射

------

存储器映射是通过将磁盘上的一个文件与虚拟存储器中的一个区域关联起来的过程。

**① 理解共享对象**

一个对象被映射到虚拟存储器的一个区域，这个区域要么是共享对象，要么是私有对象。如果一个进程A将一个共享对象映射X到了它的虚拟存储器中，那么对于也把这个共享对象X映射了的其他进程而言，进程A对共享对象X的任何读写操作都是可见的。下图是进程1和进程2映射了共享区域的图例：



![img](https://upload-images.jianshu.io/upload_images/3010486-21b9a36189093dba.png?imageMogr2/auto-orient/strip|imageView2/2/w/302/format/webp)

私有区域：即使是私有区域在物理存储器上也是同一个区域，如下图进程1和进程2所映射的私有对象在物理存储器上只是一份拷贝。



![img](https://upload-images.jianshu.io/upload_images/3010486-fbaed81e2957190b.png?imageMogr2/auto-orient/strip|imageView2/2/w/388/format/webp)

每个对象都有唯一的一个文件名，在进程1的虚拟存储器中已经完成了私有对象到存储器的映射，进程2如果要映射这个区域只需要将页表条目指向已经映射好的物理存储器位置就行了。如上图所示，进程1和2将一个私有对象映射到了物理存储器的一个区域并共享这个私有对象。这个对象会被标记为只读，当其中一个进程2确实需要写这个区域的时候，就会引发一个保护故障，内核会在物理存储器中创建这个私有对象的一个拷贝，称为写时拷贝，更新页面条目使得进程1指向这个新的条目。然后把老对象修改为可写权限。这样当保护故障程序返回的时候，CPU从新执行写的操作就不会出错了。

**② 理解fork函数如何创建独立的虚拟地址空间**

当当前进程调用fork函数的时候，内核为新进程创建各种数据结构，并分配PID。为了给新进程创建一个虚拟存储器，它创建的当前进程的mm_struct、区域结构和页表的一个拷贝，内核为两个进程的每个页表标记为只读，并将诶个区域标记为私有的写时拷贝。这样当fork函数返回的时候，新进程的虚拟存储器和当前进程的虚拟存储器刚好相同。任何一个进程进行写操作的时候，才会创建新的页面。



![img](https://upload-images.jianshu.io/upload_images/3010486-879dfc12cfde4634.png?imageMogr2/auto-orient/strip|imageView2/2/w/568/format/webp)

**③ 理解execve函数实际上如何加载和执行程序**

1> 删除已存在的用户区域；

2> 映射私有区域

所有的.text、.data、.bss区域都是新创建的，这些区域是私有的、写时拷贝。.bss是匿名文件区域，初始化为二进制0，栈、堆也都是初始化为0.

3> 映射共享区域；

这些共享区域是动态链接到程序然后映射到虚拟地址空间的共享区域。

4> 设置程序计数器。

最后一步就是设置当前进程的上下文计数器，并指向.text入口

**④ 使用mmap函数创建新的存储器映射**



![img](https://upload-images.jianshu.io/upload_images/3010486-2a3f04ca77d183a0.png?imageMogr2/auto-orient/strip|imageView2/2/w/728/format/webp)

函数原型如下：

> 说明：
>
> start：从地址start开始处创建，通常为NULL；length：连续对象的大小；
>
> port：访问权限（PROT_EXEC\PROT_READ\PROT_WRITE\PROT_NONE）;
>
> flags：被映射对象的位（MAP_ANOE\MAP_PRIVATE\MAP_SHARED）;
>
> fd: 指定的磁盘文件；offset：距离磁盘文件偏移的位置处开始；
>
> 返回值：调用成功，返回新区域的地址。

（注：可以使用munmap删除相应的虚拟存储器区域）

#### 1.8 动态存储分配

------

动态存储器分配指的是在程序运行的时候分配额外的存储空间，分配器维护着虚拟存储器中的堆实现这种分配。



![img](https://upload-images.jianshu.io/upload_images/3010486-97947051392bab43.png?imageMogr2/auto-orient/strip|imageView2/2/w/313/format/webp)

堆是紧跟着.bss段，并向上增长，内核维护着一个brk指针，指向堆的顶部。任何一个堆中的块要么是已分配的要么是空闲的。分配的方式分为两种：显式和隐式，我们接下来主要讲一下显示分配和实现一个分配器的基础知识，隐式分配指的其实是分配器回收空间，这个在分配器基础知识中有所讲解，就不再另外提出了：

**① 显式分配：程序调用malloc和free函数**

经常直到我们的程序运行的时候，我们才知道某些数据结构的大小。这时候就必须显式的分配相应的存储空间。如下图所示：



![img](https://upload-images.jianshu.io/upload_images/3010486-b7328b0c6f3ab42f.png?imageMogr2/auto-orient/strip|imageView2/2/w/409/format/webp)



![img](https://upload-images.jianshu.io/upload_images/3010486-9bbae3174b9944c4.png?imageMogr2/auto-orient/strip|imageView2/2/w/274/format/webp)

使用malloc函数以具体的输入内容分配相应大小的存储空间，函数原型如下：

如果想要初始化存储器为0，可以使用calloc函数。想要改变已分配的大小可以使用realloc函数

释放是通过调用free函数来实现的：



![img](https://upload-images.jianshu.io/upload_images/3010486-79d9e5065219f5c6.png?imageMogr2/auto-orient/strip|imageView2/2/w/235/format/webp)

ptr是指向一个已分配空间的起始位置

**我们来看一个分配实例：**



![img](https://upload-images.jianshu.io/upload_images/3010486-955afa724ebd7995.png?imageMogr2/auto-orient/strip|imageView2/2/w/481/format/webp)

> （a）请求一个4字大小的块，malloc将分配好的空间的首地址返回给p1；
>
> （b）请求一个5字大小的块，由于使用的双字对其，所以填充了一个空闲块；
>
> （c）请求一个6字大小的块，返回给p3；
>
> （d）释放p2，调用后p2仍然指向原来的位置；
>
> （e）请求一个2字大小的块，在已经释放的p2处优先分配，然后返回指针p4

**② 分配器基础知识**

分配器的目标主要是找到吞吐量和利用率的契合点，那么为什么需要隐式的分配，因为碎片的产生会降低存储空间的利用率

**碎片：内部和外部**

1>内部碎片：我们上面讲到的（b）的情况，分配了一个额外的空闲块，实现双字对其；

2>外部碎片：(e)中如果请求7字大小的块，即使存储空间有这么大，还是不行

当然，还有许多问题要思考，诸如：空闲块如何组织、如何分配新的块、怎么分割和合并块，这些技术都要求我们提供一种新的数据结构



![img](https://upload-images.jianshu.io/upload_images/3010486-422003b92cf3b833.png?imageMogr2/auto-orient/strip|imageView2/2/w/606/format/webp)

**隐式空闲链表：**

这样的一种结构，主要是由三部分组成：头部、有效载荷、填充（可选）；

**头部：**是由块大小+标志位（a已分配/f空闲）；**有效载荷：**实际的数据



![img](https://upload-images.jianshu.io/upload_images/3010486-217f718e348d3d51.png?imageMogr2/auto-orient/strip|imageView2/2/w/870/format/webp)

应用举例：

这个链表（大小/是否分配）是通过头部中的大小字段 隐含连接着的（头部+大小=下一块位置），分配器可以遍历所有的块，在遇到结束位（0/1）处停止。即使是要求分配一个数据块，也要有（8/0）一个头部，两个字来完成。

**简单的放置策略：**

1> 首次适配：从头搜索，遇到第一个合适的块就停止；

2> 下次适配：从头搜索，遇到下一个合适的块停止；

3> 最佳适配：全部搜索，选择合适的块停止。

**分割空闲块：**



![img](https://upload-images.jianshu.io/upload_images/3010486-9835083315a081a0.png?imageMogr2/auto-orient/strip|imageView2/2/w/877/format/webp)

适配到合适的空闲块，分配器将空闲块分割成两个部分，一个是分配块，一个是新的空闲块：

**增加堆的空间：**通过调用sbrk函数，申请额外的存储器空间，插入到空闲链表中

**合并：**



![img](https://upload-images.jianshu.io/upload_images/3010486-e204e23162ca6417.png?imageMogr2/auto-orient/strip|imageView2/2/w/877/format/webp)

1> 为什么要合并：处理假碎片现象

如上所示，虽然释放了两个3字节大小的数据空间，而且空闲的空间相邻，但是就是无法再分配4字节的空间了，这时候就需要进行一般合并：合并的策略是立即合并和推迟合并，我们可能不立即推迟合并，如果有空间直接合并不好吗？有时候的确还真不好，如果我们马上合并上图的空间后又申请3字节的块，那么就会开始分割，释放以后立即合并的话，又将是一个合并分割的过程，这样的话推迟合并就有好处了。需要的时候再合并，就不会产生抖动了。

**2> 怎样合并：带边界标记**



![img](https://upload-images.jianshu.io/upload_images/3010486-a74ec760b0fa23de.png?imageMogr2/auto-orient/strip|imageView2/2/w/491/format/webp)

我们需要从新审视一下我们的隐式链表数据结构，加入新的边界标记形成如下结构：

在链表的底部加入头部同样的格式，用a表示已分配、f表示空闲

**我们列举一下可能的所有情况：**



![img](https://upload-images.jianshu.io/upload_images/3010486-abbc513f5874b7de.png?imageMogr2/auto-orient/strip|imageView2/2/w/412/format/webp)

**说明：**



![img](https://upload-images.jianshu.io/upload_images/3010486-f822a96447b8c3ce.png?imageMogr2/auto-orient/strip|imageView2/2/w/365/format/webp)

（a）：在合并的时候，由于前后都是已分配不执行合并，只是把当前块标记位空闲：



![img](https://upload-images.jianshu.io/upload_images/3010486-4b20b03d54fc554a.png?imageMogr2/auto-orient/strip|imageView2/2/w/405/format/webp)

（b）：后面的块是空闲的，当前块与后面的块合并，用新的块的大小（当前块大小+后面块大小），更新当前块的头部和后面块的脚部



![img](https://upload-images.jianshu.io/upload_images/3010486-ae5a7dd12acb251e.png?imageMogr2/auto-orient/strip|imageView2/2/w/415/format/webp)

（c）：前面块是空闲，前面块与当前块合并，用新的块的大小（当前块的大小+前面块的大小），更新前面块的头部和当前块的脚部



![img](https://upload-images.jianshu.io/upload_images/3010486-ef108ac42273cae0.png?imageMogr2/auto-orient/strip|imageView2/2/w/398/format/webp)

（d）：三个块都是空闲，3个块的大小来更新前面块的头部和后面块的脚部



![img](https://upload-images.jianshu.io/upload_images/3010486-ff82cac94ea01f34.png?imageMogr2/auto-orient/strip|imageView2/2/w/355/format/webp)

当前已分配的头部

注意：当（c）和（d）两种情况，前面的块是空闲的，才需要用到当前块的脚部。（a）不需要更新，（b）更新的是后面块的脚部+块大小。如果我们把前面的块的位存放在当前块头部未使用多出来的低位中，那么已分配的块就不需要脚部了。（当然空闲块仍然需要脚部）

**③ 综合：实现一个简单的分配器**

我们将实现的是一个基于隐式空闲链表，立即边界标记合并方式的简单分配器。数据的结构如下：



![img](https://upload-images.jianshu.io/upload_images/3010486-99f0155fce355900.png?imageMogr2/auto-orient/strip|imageView2/2/w/228/format/webp)

最小的块大小为16字节，必须包含：头部（8字节）+脚部（8字节）；

隐式的空闲链表具有如下恒定的形式：



![img](https://upload-images.jianshu.io/upload_images/3010486-e1f6ecc399f0f975.png?imageMogr2/auto-orient/strip|imageView2/2/w/866/format/webp)

其中首字（对齐）是不使用的填充块，紧跟着的是一个特殊的序言块，由一个头部和脚部组成，序言块在初始化的时候创建，永不释放。中间就是由malloc创建的普通块，最后是一个特殊的结尾块，序言和结尾块都是为了消除合并边界条件的技巧。（heap_listp总是指向序言块）

接下来的内容，我们直接上与malloc和free有关的函数源码，用到什么知识的时候再做补充：为了和系统的malloc和free函数区分，我们起名为（mm_malloc和mm_free）：



![img](https://upload-images.jianshu.io/upload_images/3010486-b45e151f79f45c92.png?imageMogr2/auto-orient/strip|imageView2/2/w/1103/format/webp)



![img](https://upload-images.jianshu.io/upload_images/3010486-9c4a1b2b23220ccd.png?imageMogr2/auto-orient/strip|imageView2/2/w/764/format/webp)

这里我们要对extend_heap函数进行说明，在扩展堆的时候必须要调用mm_init函数进行初始化，创建一个空的链表。初始化mm_init函数如下：



![img](https://upload-images.jianshu.io/upload_images/3010486-6867b2e145db2b65.png?imageMogr2/auto-orient/strip|imageView2/2/w/756/format/webp)

具体的扩展函数如下，当堆初始化或者mm_malloc函数不能匹配的时候就会进行扩展：



![img](https://upload-images.jianshu.io/upload_images/3010486-a7ca2ef0bf4d2dcb.png?imageMogr2/auto-orient/strip|imageView2/2/w/476/format/webp)

分配我们讲完了，下面来看看mm_free函数和合并空闲块函数coalesce函数，合并的4种情况：



![img](https://upload-images.jianshu.io/upload_images/3010486-1a0704767a549397.png?imageMogr2/auto-orient/strip|imageView2/2/w/927/format/webp)

④ 分离的空闲链表



![img](https://upload-images.jianshu.io/upload_images/3010486-0f4fdb019dfac679.png?imageMogr2/auto-orient/strip|imageView2/2/w/553/format/webp)

我们使用单向的空闲链表分配时间并没有改善，我们现在来看看比较流行的分离存储方法，在一个分离存储的系统中，分配器维护着一个空闲链表数组，每个空闲链表是一些大小不同的类。我们可以按照2的幂来划分，比如1，2，4，8，16，32.......等等。

像上图那样，每个大小类都是2的幂，按照升序排列就是伙伴系统。我们要分配一个9字节的空间，就需要从前往后依次寻找，找到了第5个空闲链表中的空间足够就分割它，将不需要的插入到空闲链表中去。如果找不到合适的，比如需要17个字的空间，就向操作系统申请额外的堆存储器。



![img](https://upload-images.jianshu.io/upload_images/3010486-3d20198621e9a487.png?imageMogr2/auto-orient/strip|imageView2/2/w/366/format/webp)

**申请：**如果我们要在16字节的空间中分配一个4字节大小的空间，就会首先将这个16字节的总空间分割成两个8字节大小的空间，其中空闲的那部分（左边）叫做伙伴，被放置到空闲链表中。我们发现8字节的空间依然大于我们要分配的空间，就再一次将8字节的空间分割成两部分，每个4字节，刚好完成分割，这时候8字节中的左边部分也就是伙伴，被放置到空闲链表中。

**释放：**需要释放4字节空间的时候，会与其伙伴进行空闲合并，形成一个8字节大小的空闲空间，继续发现另外的8字节伙伴也是空闲的，继续合并。直到遇到的伙伴已经被分配了才停止。

**⑤ 垃圾收集**

垃圾收集是一种很有用的方法，当使用了malloc分配了空间却忘记了释放，就会造成内存的极大浪费。垃圾收集就是使用特殊的方法，定期回收这部分不使用或者无效的空间。

当然收集的方法分为很多种，我们只讲一下【标记清除算法】：



![img](https://upload-images.jianshu.io/upload_images/3010486-96dc1daabee46843.png?imageMogr2/auto-orient/strip|imageView2/2/w/405/format/webp)

垃圾收集器将存储器视为一张有向的图，根节点保存在寄存器、栈变量或者虚拟存储器的全局变量中，子节点在堆中，每个子节点对于一个已分配的块。白色为可到达，蓝色为不可到达应该被回收的区域。

垃圾回收期就是维护着这种可达图，释放其中不可达的节点，返回给空闲链表。



![img](https://upload-images.jianshu.io/upload_images/3010486-cca9c91e21294c43.png?imageMogr2/auto-orient/strip|imageView2/2/w/433/format/webp)

像c和c++这类语音不能维持可达图的精确表示，有些不可达的节点可能会被错误的标识为可达，它的垃圾收集器就是一个保守的垃圾收集器。加入到malloc包中就形成这样的形式：

当我们需要空间的时候，调用了malloc函数，如果找不到合适的空间就会启用垃圾收集器，希望回收一部分可利用的空间，垃圾收集器将代替程序执行free函数，释放的空间返回以后重新调用malloc，如果还是失败才从操作系统申请额外的存储空间。

如何标记：



![img](https://upload-images.jianshu.io/upload_images/3010486-56799cbd53ca612b.png?imageMogr2/auto-orient/strip|imageView2/2/w/500/format/webp)

标记前的状态是这样的：

淡蓝色的块是已分配的头部，6个块都是未标记的。其中根节点指向块4，4的又分别指向了3和6.其中3又指向了1，这就形成了一个有向的链表，其中只有2和5不能到达。



![img](https://upload-images.jianshu.io/upload_images/3010486-17ce5ad999d45650.png?imageMogr2/auto-orient/strip|imageView2/2/w/347/format/webp)

这时候我们使用标记函数，循环遍历进行标记：



![img](https://upload-images.jianshu.io/upload_images/3010486-2df0215532d30391.png?imageMogr2/auto-orient/strip|imageView2/2/w/645/format/webp)

标记完成以后，形成如下所示：

由于块1、3、4、6是可达的，所以都被标记了。2和5无法标记是垃圾

sweep函数释放所有的未标记的块：



![img](https://upload-images.jianshu.io/upload_images/3010486-556dafc72d919b3c.png?imageMogr2/auto-orient/strip|imageView2/2/w/399/format/webp)



![img](https://upload-images.jianshu.io/upload_images/3010486-b6fc3a3c4d9970af.png?imageMogr2/auto-orient/strip|imageView2/2/w/489/format/webp)

清除块2和块5以后是这样的：

我们之所以说c和c++是保守的垃圾收集器，是因为在标记阶段的isPtr函数识别并不准确，c不知道输入的参数是否是一个指针，也不知道指向的是否是一个有效载荷的位置。（**这里需要多读读，还有点儿不懂）**

#### 1.9 c程序中常见的10大存储器相关错误

------

存储器的错误总是令人沮丧的，特别是在运行了一段时间之后才显示出来，就特别特别的烦人了，我们列举一些常见的错误，仅供参考：

① 间接引用坏指针：将本来的地址引用写成了内容scanf("%d", &val)写成scanf("%d", val)

② 读未初始化的存储器：

在堆中申请了一块空间：int *y = (int *)Malloc(n * sizeof(int));由于堆中的空间是未被初始化的，下面的使用就会出错：y[i] += A[i][j] * x[j];推荐使用calloc函数



![img](https://upload-images.jianshu.io/upload_images/3010486-77a6bb53d3aea36e.png?imageMogr2/auto-orient/strip|imageView2/2/w/682/format/webp)

③ 允许栈缓冲溢出：

推荐使用fgets函数

④ 假设指针和它指向的对象是相同大小的

使用int **A = (int **)Malloc(n * sizeof(int));本来是想创建的一个int *的数组，但是sizeof上面用到的确实int

⑤ 错位



![img](https://upload-images.jianshu.io/upload_images/3010486-e9ac65346e13a46c.png?imageMogr2/auto-orient/strip|imageView2/2/w/556/format/webp)

申请了n个空间，却要访问n+1处位置

⑥ 引用指针而不是它指向的对象

*size--; /* This should be (*size)-- */

其中，--和*有相同的优先级，由于这是右结合。所以先--再*，就出错了。

⑦ 误解指针运算

p += sizeof(int); /* Should be p++ */

指针p++就会指向下一个位置，+= int的大小的话，就跳了几个数据了

⑧ 引用不存在的变量



![img](https://upload-images.jianshu.io/upload_images/3010486-ca73fcb51d060b75.png?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp)

本地变量在栈中创建，函数结束以后就已经不存在了。



![img](https://upload-images.jianshu.io/upload_images/3010486-971c63964dc5f619.png?imageMogr2/auto-orient/strip|imageView2/2/w/783/format/webp)

⑨ 引用已经释放了的块中的数据

在行10的时候已经将块释放了，在行14的时候又在使用



![img](https://upload-images.jianshu.io/upload_images/3010486-32888d9384b5ff09.png?imageMogr2/auto-orient/strip|imageView2/2/w/548/format/webp)

🔟  不释放引起内存泄漏

如果经常调用leak，又不释放的话，内存就会充满垃圾。

# 《深入理解计算机系统》| 系统级IO

![img](https://upload.jianshu.io/users/upload_avatars/3010486/d9eee8450714.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[唐鱼的学习探索](https://www.jianshu.com/u/0129e34fa381)关注

2017.05.02 15:41:57字数 1,504阅读 913



![img](https://upload-images.jianshu.io/upload_images/3010486-f35cdc7354812c28.JPG?imageMogr2/auto-orient/strip|imageView2/2/w/480/format/webp)

目  录

Input是指从设备拷贝数据到内存，而Output是从内存拷贝数据到外部设备的过程，我们平时使用的都是语言提供的标准IO库，如printf和scanf，这些是通过内核提供的系统级IO函数来实现的。我们学习系统级的IO，有助于我们理解其他概念，在读取元数据的时候也需要用到系统级的IO。这一章的内容很简单，来不及解释了，开车了：

#### **1.1 什么是Unix文件**

------

一个Unix文件是一个m个字节的序列，所有的IO设备（网络、磁盘、终端）都被映射为文件，内核提供一个简单的接口，使得对所有这些设备的访问都是以文件的方式的进行。

#### 1.2 操作文件的一般过程

------

**打开文件：**一个应用程序通过要求内核打开相应的文件，内核将返回一个非负整数，称为描述符，记录打开文件的所有信息：标准输入（描述符0）、标准输出（描述符1）、标准错误（描述符2）

**改变当前文件位置**：内核保持一个文件的位置k，初始为0，表示从文件开始处偏移的字节数。通过seek操作。

**读写文件**：读操作就是从文件拷贝n个字节到存储器，如果是从k处开始，就是拷贝k+n为止。文件的大小为m，如果k≥m就会触发（EOF），所有就不需要明确的EOF字符了。写操作就是从存储器拷贝n个字节到文件当前位置k处。

**关闭文件：**内核释放打开文件时创建的数据结构，释放所有的存储器资源。

#### 1.3 文件操作函数

------



![img](https://upload-images.jianshu.io/upload_images/3010486-8e86f130756bc21f.png?imageMogr2/auto-orient/strip|imageView2/2/w/680/format/webp)

**打开文件**

filename：是文件名

flags：O_RDONLY|O_WRONLY|O_RDWR;（O_CREAT\O_TRUNC\O_APPEND）；

mode：访问权限



![img](https://upload-images.jianshu.io/upload_images/3010486-9aae959a93a65a0c.png?imageMogr2/auto-orient/strip|imageView2/2/w/546/format/webp)

返回值：成功为描述符，失败为-1。



![img](https://upload-images.jianshu.io/upload_images/3010486-bba8403fb9439d32.png?imageMogr2/auto-orient/strip|imageView2/2/w/785/format/webp)

**关闭文件：**



![img](https://upload-images.jianshu.io/upload_images/3010486-267a5401ce53898b.png?imageMogr2/auto-orient/strip|imageView2/2/w/797/format/webp)

**读写文件：**

fd：描述符fd的当前位置；buf：存储器位置；n：拷贝大小

（注：当读取时遇到EOF、从终端读取文本行或者读写网络套接字的时候返回不足值）

#### 1.4 对文件操作函数的封装：RIO（Robust健壮的）

------

RIO之所以称之为健壮的IO包，是因为他提供了方便高效的IO访问，你可以从一个描述符中读一些文本行，然后读二进制，最后再读文本行。有两类输入输出函数：



![img](https://upload-images.jianshu.io/upload_images/3010486-6e534785b4b336ae.png?imageMogr2/auto-orient/strip|imageView2/2/w/775/format/webp)

**① 无缓冲输入输出：二进制与网络的直接读写**

对于同一个描述表，可以任意的交错调用rio_readn和rio_wiriten



![img](https://upload-images.jianshu.io/upload_images/3010486-6219ad412378e16f.png?imageMogr2/auto-orient/strip|imageView2/2/w/923/format/webp)



![img](https://upload-images.jianshu.io/upload_images/3010486-01442c068d85ee29.png?imageMogr2/auto-orient/strip|imageView2/2/w/683/format/webp)

这是如何实现的呢：

从上面的代码不难看出，如果程序的信号处理程序返回中断，这个函数会手动重启read或者write。



![img](https://upload-images.jianshu.io/upload_images/3010486-070c02e7b6084b95.png?imageMogr2/auto-orient/strip|imageView2/2/w/777/format/webp)

**② 带缓冲的输入函数**

这个函数有一个好处是，它从内部读缓冲区拷贝的一行，当缓冲区为空的时候，自动调用read填满缓冲区，效率很高。

在调用这两个函数以前，是通过rio_readinitb函数来完成一些初始化的，主要是将fd与一块缓冲区联系起来：



![img](https://upload-images.jianshu.io/upload_images/3010486-6693d0cae19c119c.png?imageMogr2/auto-orient/strip|imageView2/2/w/539/format/webp)



![img](https://upload-images.jianshu.io/upload_images/3010486-4e112f197226f2f2.png?imageMogr2/auto-orient/strip|imageView2/2/w/742/format/webp)



![img](https://upload-images.jianshu.io/upload_images/3010486-8aef7406ddc85c00.png?imageMogr2/auto-orient/strip|imageView2/2/w/703/format/webp)

有了数据上的这个结构，我们来看看readnb和readlineb函数的具体实现：

这里面都用到了一个带缓冲的读函数，rio_read，如下：



![img](https://upload-images.jianshu.io/upload_images/3010486-e0f3b90e6a8e5c81.png?imageMogr2/auto-orient/strip|imageView2/2/w/863/format/webp)

我们再来看一个应用：从标准输入中读取一行并显示



![img](https://upload-images.jianshu.io/upload_images/3010486-3f5276f521a426ec.png?imageMogr2/auto-orient/strip|imageView2/2/w/478/format/webp)

运行结果如下：



![img](https://upload-images.jianshu.io/upload_images/3010486-9b76b449809fba1f.png?imageMogr2/auto-orient/strip|imageView2/2/w/340/format/webp)

#### 1.4 读取文件元数据

------



![img](https://upload-images.jianshu.io/upload_images/3010486-6b30ec2bec704dcc.png?imageMogr2/auto-orient/strip|imageView2/2/w/489/format/webp)

文件元数据是指文件本身的一些信息，包含：访问模式、大小和创建时间：



![img](https://upload-images.jianshu.io/upload_images/3010486-2df257e06c27b761.png?imageMogr2/auto-orient/strip|imageView2/2/w/505/format/webp)

我们只讲解其中的st_mode和st_size字段，其中模式设定中包含三种文件类型：



![img](https://upload-images.jianshu.io/upload_images/3010486-efd48c0bec8f9ee0.png?imageMogr2/auto-orient/strip|imageView2/2/w/420/format/webp)

我们来写一个应用程序，展示文件的读取模式：

运行结果如下，我们读取根目录元信息：



![img](https://upload-images.jianshu.io/upload_images/3010486-70c46b7cd03db5bb.png?imageMogr2/auto-orient/strip|imageView2/2/w/345/format/webp)

#### 1.5 共享文件

------



![img](https://upload-images.jianshu.io/upload_images/3010486-6afeb0292327c9d6.png?imageMogr2/auto-orient/strip|imageView2/2/w/615/format/webp)

不理解文件是如何打开的，理解共享都是耍流氓。内核通过三个数据结构表示打开的文件：

> 描述符表：每个独立的进程1张，指向一打开的文件表；
>
> 文件表：包括打开文件位置，引用数量，以及一个指向元数据的v-node指针；
>
> v-node表：包含stat结构的大部分信息；



![img](https://upload-images.jianshu.io/upload_images/3010486-effef452d3ccbc28.png?imageMogr2/auto-orient/strip|imageView2/2/w/630/format/webp)

**共享文件:**

同一个进程的不同表项，通过文件表指向了同一个位置



![img](https://upload-images.jianshu.io/upload_images/3010486-ced6f7083d50d3be.png?imageMogr2/auto-orient/strip|imageView2/2/w/519/format/webp)

**理解父子进程共享文件：**

子进程只需要将它的描述符表指向，文件表中同样的位置就行了。

#### 1.6 IO重定向

------



![img](https://upload-images.jianshu.io/upload_images/3010486-ef27646d698fe172.png?imageMogr2/auto-orient/strip|imageView2/2/w/393/format/webp)

重定向允许我们把本来输出到终端的内容，从新定位到磁盘文本中去，效果如下图：



![img](https://upload-images.jianshu.io/upload_images/3010486-b4cfa157486096bd.png?imageMogr2/auto-orient/strip|imageView2/2/w/767/format/webp)

将当前目录列表，从终端重定位到foo.txt文本中，这个过程使用的是dup2函数



![img](https://upload-images.jianshu.io/upload_images/3010486-011c4327719dd5f0.png?imageMogr2/auto-orient/strip|imageView2/2/w/512/format/webp)

将新的fd加到老的fd上面，删除掉newfd以前的内容，如果newfd已打开还会被关闭。

#### 1.7  总结：什么时候用什么

------



![img](https://upload-images.jianshu.io/upload_images/3010486-16d82c6bd87a2a05.png?imageMogr2/auto-orient/strip|imageView2/2/w/758/format/webp)

我们这一章讨论了标准IO函数、各种IO包，以及系统级的IO。他们之间的关系可以用下图来表示：

> 建议：
>
> Unix IO 读取文件元信息
>
> 标准IO ：在磁盘和终端中输入输出
>
> RIO：网络套接字首选，如果要格式化先调用sprintf再调用rio

# 深入理解计算机系统》| 网络编程

![img](https://upload.jianshu.io/users/upload_avatars/3010486/d9eee8450714.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[唐鱼的学习探索](https://www.jianshu.com/u/0129e34fa381)关注

2017.05.07 23:01:02字数 3,482阅读 640



![img](https://upload-images.jianshu.io/upload_images/3010486-96b490f63630cdc0.png?imageMogr2/auto-orient/strip|imageView2/2/w/859/format/webp)

网络应用集成了我们已经学到的很多概念：进程、信号、字节顺序、存储器映射、动态分配等，同时客服端-服务器模型是一个新的知识，我们将所有的这些结合起来，创建一个微小的Web服务器，提供浏览器静态和动态的访问。

#### 1.1 客户端--服务器模型

------



![img](https://upload-images.jianshu.io/upload_images/3010486-2a8af66cc50bfbba.png?imageMogr2/auto-orient/strip|imageView2/2/w/639/format/webp)

每一个网络应用都是基于一个客户端进程和一个服务器进程建立起来的，服务器管理资源，客服端请求某种服务，客户端和服务器都是一个运行中的程序。典型的示意图如下：

我们以一个邮件客服端访问文件为例：

① 客户端发送一个浏览文件的请求给Web服务器；

② 服务器接收请求以后，解释它，从资源中取出相应的文件；

③ 服务器将文件发送到请求的客户端；

④ 客户端接收并显示在屏幕上。

#### 1.2 网络

------



![img](https://upload-images.jianshu.io/upload_images/3010486-8a7b5c18c7bfa004.png?imageMogr2/auto-orient/strip|imageView2/2/w/614/format/webp)

网络是连接客户端与服务器之间的通路，对于单个的主机而言，网络只是插在IO总线上的一种，从网络上接收的数据经过适配器-IO总线-桥-存储器总线-主存：

上图只是一个简图，我们来简单的讨论一下具体的实现



![img](https://upload-images.jianshu.io/upload_images/3010486-77dad1456dda4042.png?imageMogr2/auto-orient/strip|imageView2/2/w/741/format/webp)

在网络建立的初期，是通过一个集线器，实现无差别的所有主机之间的数据交换。同交换机不同，集线器不是点到点，它的每次转发都是针对所有的主机，这就形成了一个局域网。后来又加入了桥，实现局域网直接的互相连接，总体的架构图如下：

新加入的桥，可以实现自动学习，哪儿主机可以通过哪个端口方便到达，如果将A发送到B，当到达桥X的时候，桥发现A到B就是本局域网的事情，就会丢弃到这个帧。而当A发送到C的时候，桥X只会将帧发送到桥Y再由桥Y分发到C，而节省了带宽。



![img](https://upload-images.jianshu.io/upload_images/3010486-d4c61a40054d2b09.png?imageMogr2/auto-orient/strip|imageView2/2/w/772/format/webp)

路由器有两个不同的端口，WAN（广域网）连接更大的局域网，LAN（本地网）连接本地主机，结构如下：

网络上的硬件已经全部连接好了，但是我们的主机各有不同，有不同的主机、不同的系统各种千差万别，是如何通过这个网络发送数据实现求同存异的。

通过协议发送，我们人类社会也是一样的，为了达成某种一致性，不至于以后扯皮，我们会实现签订一个协议，将需要调解的问题和责任全部列出，而且竟可能倾其所有，在以后的操作中不会有含糊不清或者界定不明的问题，也就能更好的合作，计算机网络也是一样通过建立一套TCP/IP协议族，实现不同主机之间的数据传输：



![img](https://upload-images.jianshu.io/upload_images/3010486-bbbfd3d03682c6eb.png?imageMogr2/auto-orient/strip|imageView2/2/w/732/format/webp)

**下图是客户端A发送数据到服务端B的过程：**

> ① 客服端将需要发送的数据拷贝到缓冲区；
>
> ② 主机A上运行的协议软件（TCP|IP）把实际要发送的数据加入PH（互联网包头）和FH1（LAN1帧头），创建一个LAN1的帧发送到网络适配器中；
>
> ③ 主机上的网络适配器（连接在IO总线）收到了这个LAN1帧以后通过网线发送到路由器的LAN1端口；
>
> ④ 收到了这个LAN1帧的时候，将其发送到协议软件上；
>
> ⑤ 路由器的协议软件将LAN1帧的旧的LAN1帧头剥落，加入到实际发送的主机LAN2帧头，并将其发送到路由器LAN2端口上；
>
> ⑥ 路由器LAN2将数据拷贝到网线上；
>
> ⑦ 主机B的适配器从网线上收到了这个帧的时候，将其传送到协议软件；
>
> ⑧ 协议软件帧头和包头吧实际的数据拷贝出来；

#### 1.3 全球IP因特网

------



![img](https://upload-images.jianshu.io/upload_images/3010486-df124ed0f20cceb1.png?imageMogr2/auto-orient/strip|imageView2/2/w/819/format/webp)

每台主机都支持TCP\IP协议，并运行着这个软件，IP协议提供基本的命名方法和传送机制，我们来看看windows上运行的这个协议：

**① IP地址**



![img](https://upload-images.jianshu.io/upload_images/3010486-b3603ad8ccb44d6e.png?imageMogr2/auto-orient/strip|imageView2/2/w/580/format/webp)

IP地址是一个无符号的32位整数，存储在如下的结构中：



![img](https://upload-images.jianshu.io/upload_images/3010486-b0ded486d042a1dc.png?imageMogr2/auto-orient/strip|imageView2/2/w/778/format/webp)

统一的网络字节顺序是以大端的字节顺序，IP地址也是使用大端法存放的，如果不同的话需要使用一些函数进行转换：

IP地址有时候是使用点分的十进制表示的如：192.168.1.1，而下面的函数可以实现将点分十进制的IP地址转成网络字节顺序的IP地址：



![img](https://upload-images.jianshu.io/upload_images/3010486-a59613e02b5f915c.png?imageMogr2/auto-orient/strip|imageView2/2/w/772/format/webp)

**② 域名**



![img](https://upload-images.jianshu.io/upload_images/3010486-f4a29cc0e195308f.png?imageMogr2/auto-orient/strip|imageView2/2/w/507/format/webp)

域名是一种将IP地址映射为一组人性化的字符串的机制，而域名的集合是一个层次结构：

第一层域名是一个非营利性组织定义的，常见的有.com、edu、gov等

第二层cmu.edu是按照先后顺序获得的，一旦获得了cmu，就可以向下生成cs\ece等



![img](https://upload-images.jianshu.io/upload_images/3010486-03be937fce3ec1c0.png?imageMogr2/auto-orient/strip|imageView2/2/w/633/format/webp)

每一组由字符串映射到IP地址的数据结构如下图：



![img](https://upload-images.jianshu.io/upload_images/3010486-9ca92b15aefa9299.png?imageMogr2/auto-orient/strip|imageView2/2/w/767/format/webp)

而负责解析这种映射的称为DNS数据库，保存着成千上万的上图中的条目结构。应用程序可以通过gethostbyname和gethostbyaddr函数显示的从DNS数据库中检索条目：



![img](https://upload-images.jianshu.io/upload_images/3010486-900b94038633f15b.png?imageMogr2/auto-orient/strip|imageView2/2/w/647/format/webp)

我们来看一个程序：



![img](https://upload-images.jianshu.io/upload_images/3010486-087401b7a071373d.png?imageMogr2/auto-orient/strip|imageView2/2/w/453/format/webp)

从给定的域名或者IP地址中打印出相应的主机名、别名和地址列表：

可以看出，多个域名可以映射多个IP地址

**③ 因特网的连接**



![img](https://upload-images.jianshu.io/upload_images/3010486-8f514744e38e9912.png?imageMogr2/auto-orient/strip|imageView2/2/w/678/format/webp)

我们通常使用的是一个套接字完成一个客服端与服务端之间的双向连接的

每个端是由该端的地址：端口组成，其中服务端的端口通常是固定的，而客服端的端口是临时分配的，当形成了一个套接字对的时候，就可以开始双向通信了。

#### 1.4 套接字函数

------



![img](https://upload-images.jianshu.io/upload_images/3010486-06efd0ae4b94ff8e.png?imageMogr2/auto-orient/strip|imageView2/2/w/699/format/webp)

当我们进行客户端与服务端之间的双向通信的时候，我们使用的是一组套接字函数，来看一张总的图：

**客户端：**

**① socket函数：创建一个套接字描述符**

我们通常使用clientfd = socket（AF_INET, SOCK_STREAM, 0）；来描述，其中AF_INET表示使用互联网，SOCK_STREAM表示使用套接字连接的一个端点；



![img](https://upload-images.jianshu.io/upload_images/3010486-1363bebd7d97ec03.png?imageMogr2/auto-orient/strip|imageView2/2/w/780/format/webp)

**② connect函数：客服端建立同服务器的连接**



![img](https://upload-images.jianshu.io/upload_images/3010486-5a25a27569a98d06.png?imageMogr2/auto-orient/strip|imageView2/2/w/951/format/webp)

**③ 客户端封装socket和connect函数：open_clientfd函数**

我们首先创建了套接字的描述（行7），然后检索DNS主机条目，并拷贝第一个IP地址到serveraddr中，发起一个connect（行16）请求，成功时返回clientfd给调用函数。

**服务端：**

**① bind函数：高数内核将my_addr中的服务器套接字地址和套接字描述符sockfd联系起来：**

原型是：int bind(int sockfd, struct scokaddr *my_addr, int addrlen);

**② listen函数：被动的监听，告诉内核被服务端使用**

原型是：int listen(int sockfd, int backlog);将sockfd转化为监听套接字



![img](https://upload-images.jianshu.io/upload_images/3010486-a95890288c657d2c.png?imageMogr2/auto-orient/strip|imageView2/2/w/729/format/webp)

**③ 封装：bind和listen成为open_listenfd函数**



![img](https://upload-images.jianshu.io/upload_images/3010486-66f2f9e738de4d14.png?imageMogr2/auto-orient/strip|imageView2/2/w/782/format/webp)

**④ accept函数：等待客户端的连接，创建已连接描述符**

监听描述符创建一次存在于整个生命周期，已连接描述符只存在于一个客户端，可以创建并发服务器。



![img](https://upload-images.jianshu.io/upload_images/3010486-41a6b0d5d0308753.png?imageMogr2/auto-orient/strip|imageView2/2/w/345/format/webp)

第一步：服务器调用accept，等待连接到达监听描述符；

第二步：客户端调用connect函数，发送一个连接请求到监听描述符；

第三步：打开一个已连接描述符connfd（4）通过connfd和clientfd交换数据。

**实例：回声（echo）客服端与服务端**



![img](https://upload-images.jianshu.io/upload_images/3010486-42816bf743c837a9.png?imageMogr2/auto-orient/strip|imageView2/2/w/524/format/webp)

**客户端：echoclient.c**



![img](https://upload-images.jianshu.io/upload_images/3010486-4b856b97e68c21e6.png?imageMogr2/auto-orient/strip|imageView2/2/w/670/format/webp)



![img](https://upload-images.jianshu.io/upload_images/3010486-51da04f74e0f036b.png?imageMogr2/auto-orient/strip|imageView2/2/w/478/format/webp)

**服务端：echoserveri.c**

**运行效果：**

第一步：启动服务器2017端口



![img](https://upload-images.jianshu.io/upload_images/3010486-8c248f8627997cc2.png?imageMogr2/auto-orient/strip|imageView2/2/w/466/format/webp)

第二步：客服端开始连接本机127.0.0.1 2017端口，并发送字符串



![img](https://upload-images.jianshu.io/upload_images/3010486-03a44da93ae4d9b4.png?imageMogr2/auto-orient/strip|imageView2/2/w/514/format/webp)

#### 1.5 Web服务器相关知识 

------

**① 基础：**

Web客户端（浏览器）与服务器之间的交互是基于一个HTTP协议，同常规的FTP协议不同，传输的是超文本标记语言（HTML）

**② Web服务器发送的内容**

是一个MIME类型的序列



![img](https://upload-images.jianshu.io/upload_images/3010486-9d4f5a0b783319b5.png?imageMogr2/auto-orient/strip|imageView2/2/w/592/format/webp)

**以两种不同的方式发送到浏览器：**

1> 取一个磁盘文件，返回给浏览器（静态内容）；

2> 取一个可执行文件，返回给浏览器（动态内容）。

**URL：通用资源定位符（Universal Resource Locator）**

URL是为每个文件定位使用的，其实也就是每个文件的名字，如：

访问：http://www.google.com:80/index.html请求/index.html文件静态内容

访问：http://www.google.com:8000/cgi-bin/adder?15000&213请求可执行文件cgi-bin/adder

> 注：其中1500&213是执行文件的两个传入参数

> 注：后缀中的“/”不代表根目录，请求的时候所有服务器默认为主页，解释为/index.html

③ HTTP事务



![img](https://upload-images.jianshu.io/upload_images/3010486-373e05e1f876ef14.png?imageMogr2/auto-orient/strip|imageView2/2/w/567/format/webp)

**1> 请求**

我们使用telnet 对www.aol.com 80端口进行连接，然后输入我们的请求：由两部分组成

请求行：GET / HTTP/1.1要求获取/index.html文件的内容;

请求头：host:www.aol.com附加额外信息；

最后我们以一个换行符号将我们的请求发送给服务器。

**2> 响应**

响应由三部分组成

响应行：HTTP/1.1 301 Moved Permanently ;

多个响应头和响应主体构成



![img](https://upload-images.jianshu.io/upload_images/3010486-dfc25bec76ed3636.png?imageMogr2/auto-orient/strip|imageView2/2/w/616/format/webp)

其中状态码有以下几种：

**④ 服务动态内容**

**1> 浏览器如何将参数传递给服务器**

使用 ？符号分割文件名和参数，使用&符号分割不同的参数；

2**> 服务器如何将参数传递给子进程**

如果一个服务器收到一个浏览器（客户端）发送的一个类似请求：

GET /cgi-bin/adder?15000&213 HTTP/1.1

我们的adder程序遵照CGI标准编写，这样子进程将传入CGI的环境变量QUERY_STRING设置为15000&213，这样在adder程序运行的时候就可以调用getenv（获取环境变量）来获得参数

**3> 服务器如何将其他信息传递给子进程**



![img](https://upload-images.jianshu.io/upload_images/3010486-7865b5407722c238.png?imageMogr2/auto-orient/strip|imageView2/2/w/445/format/webp)

依照CGI标准定义的函数还可以设置环境变量，有下面这些可以使用

**4> 子进程将输出发送到哪里**

子进程加载并运行CGI程序以前，将CGI程序的标准输出从定位到了客服端已关联描述符（使用dup2函数），这样一来任何标准输出都会发送到客服端去了。同时子进程还要负责生成conten-type和content-length两个响应头，解释所发送的内容，以及终止的空行。



![img](https://upload-images.jianshu.io/upload_images/3010486-40da74aea64bdbbb.png?imageMogr2/auto-orient/strip|imageView2/2/w/704/format/webp)

一个标准的CGI程序adder，只是简单的将传入的参数相加，并返回给客户端

#### 1.6 实例：创建一个微小的Web服务器 

------

我们汇总我们已经学到的所有内容，创建一个只有200多行代码的小型Web服务器，不过麻雀虽小，东西还是满多的，可以实现对静态和动态内容的访问，我们直接上完整的代码。

① 主程序mian部分：



![img](https://upload-images.jianshu.io/upload_images/3010486-8769a44e8a8a17d4.png?imageMogr2/auto-orient/strip|imageView2/2/w/536/format/webp)

首先通过特定的端口创建一个监听描述符，然后就进入了无限循环中，通过accept函数创建已连接的描述符connfd，执行doit事务。

② doti事务



![img](https://upload-images.jianshu.io/upload_images/3010486-658fd8586dda2eb6.png?imageMogr2/auto-orient/strip|imageView2/2/w/811/format/webp)

③ 解析URI函数：parse_uri

首先，我们解析请求行，并且只处理GET方法，然后对URI进行解析，返回一个标识确定到底是静态页面还是动态页面，分别调用相应的函数处理。



![img](https://upload-images.jianshu.io/upload_images/3010486-d5e24543556f02a4.png?imageMogr2/auto-orient/strip|imageView2/2/w/532/format/webp)

首先是确定到底是静态内容还是动态内容，如果是静态内容，首先清除CGI参数串，然后将URI转化为一个相对路径名，如果没有指定，默认的转向到home.html页面，返回1；如果是动态的内容，定位到？后面，抽取相应的参数，将URI转化为一个Unix文件名，返回0；

④ 忽略请求头：read_requesthdrs函数



![img](https://upload-images.jianshu.io/upload_images/3010486-7fb206afcf35281c.png?imageMogr2/auto-orient/strip|imageView2/2/w/467/format/webp)

只是简单的已报头结束的地方循环读取整个报头，然后不做任何处理，忽略它;

⑤ 处理静态页面：serve_static 和get_filetype



![img](https://upload-images.jianshu.io/upload_images/3010486-ef913d6e519edf2a.png?imageMogr2/auto-orient/strip|imageView2/2/w/642/format/webp)



![img](https://upload-images.jianshu.io/upload_images/3010486-5013a7f8d3c92d56.png?imageMogr2/auto-orient/strip|imageView2/2/w/565/format/webp)

⑥ 处理动态内容：serve_dynamic



![img](https://upload-images.jianshu.io/upload_images/3010486-44c7463c7047a30f.png?imageMogr2/auto-orient/strip|imageView2/2/w/614/format/webp)

⑦ 错误处理函数：clienterror



![img](https://upload-images.jianshu.io/upload_images/3010486-62a3e7ba6cb00dd4.png?imageMogr2/auto-orient/strip|imageView2/2/w/657/format/webp)

我们来看看运行的效果，首先是解析动态内容，我们创建了一个主页：home.html文件，并且在服务端启用了



![img](https://upload-images.jianshu.io/upload_images/3010486-0237840569c49842.png?imageMogr2/auto-orient/strip|imageView2/2/w/948/format/webp)

显示动态内容，我们使用之前的adder程序，将1243和12相加，并显示



![img](https://upload-images.jianshu.io/upload_images/3010486-63f767f093511190.png?imageMogr2/auto-orient/strip|imageView2/2/w/674/format/webp)

2017年05月07日 完



2人点赞

《深入理解计算机系统》

# 《深入理解计算机系统》并发编程

![img](https://upload.jianshu.io/users/upload_avatars/3010486/d9eee8450714.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[唐鱼的学习探索](https://www.jianshu.com/u/0129e34fa381)关注

0.0722017.05.30 15:18:14字数 4,704阅读 633



![img](https://upload-images.jianshu.io/upload_images/3010486-b1bf737e3d0e8ee1.JPG?imageMogr2/auto-orient/strip|imageView2/2/w/697/format/webp)

目  录

我们在上一章节中讲到的Tiny Web服务器只能为单个客服端提供访问，这一章里，我们将通过进程、多路复用和线程技术研究并发的服务器。

#### 1.1 使用进程实现并发

------

我们实现过一个echo服务器，但是遗憾的是只能为一个客服端服务，这不是我们的初衷，现在我们来更新上一个版本，使得服务器在接收到连接请求的时候，创建子进程为该客户端提供服务，主进程会关闭已连接的描述符，继续监听下一个客服端，这一个过程我画了一个简图：



![img](https://upload-images.jianshu.io/upload_images/3010486-475fd5749d81a8d2.png?imageMogr2/auto-orient/strip|imageView2/2/w/797/format/webp)

在这个过程中，客服端1连接上了服务器，并创建了一个已连接的描述符4，服务器立即派生子进程，子进程将继承原有的已连接描述符4，通过这个子进程的描述符为客服端1提供给服务。这时候，主进程必须要关闭已连接描述符4，使得不至于发生内存泄漏。



![img](https://upload-images.jianshu.io/upload_images/3010486-bd8c5c68e66f8287.png?imageMogr2/auto-orient/strip|imageView2/2/w/788/format/webp)

客服端2的连接过程和客服端1的过程是一样的，还是由服务器创建子进程2提供服务，并关闭服务器中的已连接描述符5。我们来看看改进代码：只是加入了回收子进程，在子进程中关闭监听描述符和主进程中关闭已连接描述符。运行的效果如下：



![img](https://upload-images.jianshu.io/upload_images/3010486-edca9e3ccc6aa018.png?imageMogr2/auto-orient/strip|imageView2/2/w/1044/format/webp)

可以同时为多个客服端提供服务，实现进程并发，进程级并发的一个明显的缺点是，各个进程都有独立的地址空间，使得共享信息相当困难而且慢速需要IPC，原理已经讲解了，代码就不难理解了：



![img](https://upload-images.jianshu.io/upload_images/3010486-2aafb7a218abcee4.png?imageMogr2/auto-orient/strip|imageView2/2/w/574/format/webp)

#### 1.2 使用IO多路复用实现并发

------

应用程序在一个进程的上下文中显示的调度它们的逻辑流，逻辑流被模型化为状态机，数据到达文件描述后，主程序显示的从一个状态切换到另一个状态。

**① 响应键盘输入和客服端连接**

我们使用select函数创建一个描述符集合，当其中之一的描述符做好准备的时候，将控制权返回给程序，select函数原型如下：

> int select(int n, fd_set *fdset, NULL, NULL, NULL);

fdset被称为一个描述符集合，我们将需要处理的描述符添加到fdset结合中去；第一个参数n是描述符集合中最大的数。select函数会一直阻塞，直到相应的集合中的描述符准备好可以读；

**我们来演示一个例子：**



![img](https://upload-images.jianshu.io/upload_images/3010486-6f4016b0f8d6df18.png?imageMogr2/auto-orient/strip|imageView2/2/w/610/format/webp)

当我们打开了监听描述符以后，我们将一个read_set集合清空，并添加上标准输入和监听描述符3形成集合{0,3}，随后，我们进入一个无限循环，每次调用Select函数会阻塞，直到描述符0或者3到达时。

我们启动以后，随意输入内容，就会看到服务器首先响应了标准输入：



![img](https://upload-images.jianshu.io/upload_images/3010486-36bb39d7f9970cf4.png?imageMogr2/auto-orient/strip|imageView2/2/w/610/format/webp)

我们接下来启动 已连接描述符，就会发现一个问题：



![img](https://upload-images.jianshu.io/upload_images/3010486-7daa9037802e477b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1150/format/webp)

不论是服务端的标准输入，还是新启动的客户端2都被阻塞了。只有当已连接描述符客户端1关闭的时候才能使用。



![img](https://upload-images.jianshu.io/upload_images/3010486-25e1d50385f7c99a.png?imageMogr2/auto-orient/strip|imageView2/2/w/697/format/webp)

一个解决之道是服务器每次循环最多回送一个文本行，就不会让已连接的描述符连续回送了。

**② 多路复用实现并发**



![img](https://upload-images.jianshu.io/upload_images/3010486-46970c789863256f.png?imageMogr2/auto-orient/strip|imageView2/2/w/619/format/webp)

服务器为每一个客户端创建一个状态机，每个状态机三个阶段：

> 【准备】——【输入事件】——【写回】

**我们来看看main函数主要部分：**



![img](https://upload-images.jianshu.io/upload_images/3010486-0bf458d1af6cfa00.png?imageMogr2/auto-orient/strip|imageView2/2/w/638/format/webp)

说明：活动的客户端是在pool池塘中，通过调用init_pool完成初始化后进入一个while循环，select函数检测两种不同的输入（新的连接、已经连接的描述符准备好可以读），当新的连接到达时，accept并add_client。最后使用check_clients函数将文本行回送。

分析：init_pool函数



![img](https://upload-images.jianshu.io/upload_images/3010486-c4679dd66abd8edf.png?imageMogr2/auto-orient/strip|imageView2/2/w/411/format/webp)

分析：add_client函数



![img](https://upload-images.jianshu.io/upload_images/3010486-f63cd88138c92a22.png?imageMogr2/auto-orient/strip|imageView2/2/w/533/format/webp)

分析：check_clients函数



![img](https://upload-images.jianshu.io/upload_images/3010486-1646ab7c1bb7d656.png?imageMogr2/auto-orient/strip|imageView2/2/w/602/format/webp)

运行的效果如图：



![img](https://upload-images.jianshu.io/upload_images/3010486-c87c371a5053a8fe.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

**总结：**我们这个版本的并发服务器，使用的是事件驱动的形式，它的优点就是共享数据的效果好很多，因为都是同一个进程上下文。开销也没有多进程的版本大，缺点就是复杂度要高些。总之，是优秀很多的。

#### 1.3 基于线程的并发

------

线程是一个运行在进程上下文中的逻辑流，由内核自动调度，集成了多进程与多路复用的优点，每个线程就像在舞台上跳舞的演员一样，各自分工和角色不一样，共享舞台的地址空间，当然也有自己私有的服装和台词。

**① 执行模型**



![img](https://upload-images.jianshu.io/upload_images/3010486-6f774ce7b1ac2d06.png?imageMogr2/auto-orient/strip|imageView2/2/w/422/format/webp)

每个线程在开始的时候都是单一的主线程，这个主线程可以创建对等线程，然后两个线程并发执行，不断的切换上下文，分别执行一段时间。与进程之间不同的是线程的上下文切换要小的多，还有就是线程之间是完全对等的关系，也就是一个线程可以杀死它的对等线程。

**我们来看一个简单的例子：**



![img](https://upload-images.jianshu.io/upload_images/3010486-cfa0a0e8b07b5c68.png?imageMogr2/auto-orient/strip|imageView2/2/w/418/format/webp)

主线程main中通过使用Pthread_create创建了一个新的tid线程，成功以后两个线程同时运行，主线程还使用了Pthread_join函数等待对等线程终止。对等线程只是简单的打印了一下Hello world。

**② 创建线程**

> 原型：int pthread_create(pthread_t *tid， pthread_attr_t *attr， func *f， void *arg);

其中调用成功后tid是运行中的线程ID，attr设置线程默认属性，f是线程函数，arg是传递参数

可以使用：pthread_t pthread_self（void）函数获取当前线程的ID；

**③ 终止线程**

> 原型：int pthread_cancel(pthread_t tid); 终止当前线程
>
> 原型：void pthread_exit(void *thread_return);等待所有对等线程终止

**④ 回收已经终止的线程**

> 原型：int pthread_join(pthread_t tid， void **thread_return);

函数会阻塞，直到线程tid终止并回收所有存储器资源。与wait不同的是该函数只能回收一个特定的线程；

**⑤ 分离线程：分离后的线程终止以后由系统自动释放**

> 原型：int pthread_detach(pthread_t tid); 

**⑥ 初始化线程**

> 原型：int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));

**⑦ 一个基于线程的并发服务器**



![img](https://upload-images.jianshu.io/upload_images/3010486-84457cd3e994d1a4.png?imageMogr2/auto-orient/strip|imageView2/2/w/581/format/webp)

这个版本同线程的版本没有多大的变化，有两个地方需要注意，我们使用了一个connfdp指针指向一个动态分配的空间来传递已连接的描述符，避免出现竞争。同时在每个线程的函数中使用deatach进行分离，每个线程终止后由系统释放。

运行效果：



![img](https://upload-images.jianshu.io/upload_images/3010486-9d31c53785dbb2b0.png?imageMogr2/auto-orient/strip|imageView2/2/w/539/format/webp)

#### 1.4 多线程中的共享变量

------

我们前面说过线程集中了多路复用中的共享的优点，也举例说了就像同一个舞台表演的不同演员一样，整个舞台空间是共享的。那么多线程中的共享是如何实现的，工作原理是什么？

我们看一个简单的例子，加入一些说明：



![img](https://upload-images.jianshu.io/upload_images/3010486-2b6d78919d610dba.png?imageMogr2/auto-orient/strip|imageView2/2/w/672/format/webp)

**① 线程存储器模型**

寄存器是不共享的，虚拟存储器总是共享的。就像同一个家庭的两个孩子一样，可以在一个饭厅吃饭，在客厅看电视，甚至共享同一个厕所，但是各自的房间通常是不一样的，各自的个人物品也不同。

**② 将变量映射到存储器**

全局变量：如ptr，可以使得本地变量msgs变成了共享（有时候两个孩子要共享一个厕所）；

本地自动变量：如myid是不能共享的，每个线程的myid都不一样；

本地静态变量：加入static如cnt，只有一个实例，两个对等线程访问的是同一个地方

**③ 共享变量：**被1个以上的线程访问过的变量，如cnt。需要注意的是msgs也变成了共享的。

#### 1.5 用信号量同步线程

------

智人在进化意义上最成功的由于其合作的规模，单个的智人个体虽然远远不及同时代的尼安德特人，但是合作的规模更大，力量也就更大。我们今天探讨的就是线程的同步，如果每个线程都各顾各的，势必会影响到程序的正常运行。我们来看一个未经同步的线程的运行情况：



![img](https://upload-images.jianshu.io/upload_images/3010486-2c970d68caf881e0.png?imageMogr2/auto-orient/strip|imageView2/2/w/457/format/webp)

这个程序的运行结果就不OK了，原因在于每个单独的进程对共享变量cnt的访问不是独占式的，这种不同步导致了错误的结果。我们来研究一下最核心的代码的运行过程：



![img](https://upload-images.jianshu.io/upload_images/3010486-e5c501c55463f7c1.png?imageMogr2/auto-orient/strip|imageView2/2/w/974/format/webp)

这里我们将线程函数中的for循环翻译成汇编代码，其中：Li是循环头，Ti是循环尾，Li对应于加载cnt，Ui对应于更新cnt，Si对应于存储cnt。线程的执行顺序并不一定总是我们所期望的，如果遇到下面这种运行顺序，就可能会出错。



![img](https://upload-images.jianshu.io/upload_images/3010486-623045eb1a747193.png?imageMogr2/auto-orient/strip|imageView2/2/w/824/format/webp)

上图中左边是正确的运行顺序，（b）就会得到错误的结果，关键点在于线程1更新了eax的值以后并没有立即写入到cnt中，就开始运行了线程2，线程2由于cnt没有更新所有eax加载还是为0，当线程2完成写入命令以后cnt就仍然是1，不会得到累加。

为了帮助大家正确理解各个线程的执行顺序，我们来画图

**① 进度图**



![img](https://upload-images.jianshu.io/upload_images/3010486-a8e88cf119883e19.png?imageMogr2/auto-orient/strip|imageView2/2/w/575/format/webp)

上图展现了两个线程，1和2，分别用x轴和y轴表示，其中Hi、Li、Ui、Si、Ti分别代表对共享变成操作的for循环的关键步骤，其中Li、Ui、Si涉及对cnt临界区的操作，所有经过这一区域的执行顺序都是不安全的。为了使得线程之间的同步变得科学，不跨越临界区。我们发明了信号量这种特殊的变量。

**② 信号量：非负整数全局变量**

信号量s其实就是一个非负整数的全局变量，对这一变量有两个操作：P（s）使得s减1，而V（s）使得s加1。我们操作信号量s的时候，通常的情况是将其初始化为1，执行P操作的时候为加锁，执行V操作的时候为解锁。为了限定线程不经由不安全区域，我们将不安全区域的设置为-1，如下图：



![img](https://upload-images.jianshu.io/upload_images/3010486-d0f937dcfec2c3a5.png?imageMogr2/auto-orient/strip|imageView2/2/w/682/format/webp)

我们的信号量s被初始化为1，只能在0和1之间变化：

1>加锁：执行P（s），有两种情况，如果原有的值为1，那么减至0；如果为0则挂起线程;

2>解锁：执行V（s），也有两种情况，如果s=0就加1；如果s=1就等待；

**③ 更新我们的badcnt程序**



![img](https://upload-images.jianshu.io/upload_images/3010486-d21e0e43d2e7143d.png?imageMogr2/auto-orient/strip|imageView2/2/w/444/format/webp)

这样以来我们的全局共享变量cnt在运行的各个线程中就会经由加锁执行++和解锁，得到正确的结果了。

**④ 信号量调度共享资源**

**生产者——消费者问题**



![img](https://upload-images.jianshu.io/upload_images/3010486-dc85a2f86bf1b66f.png?imageMogr2/auto-orient/strip|imageView2/2/w/437/format/webp)

以小区的自动售货机为例，消费者如果直接以下订单的方式与生产者沟通，这样的效率就太低下了。我不可能想要喝一瓶可能才让可口可乐公司给我生产。这时候缓冲区就是一个很好的发明，我们发现在小区建立几个自动售货机，假设每个自动售货机可以装100瓶饮料。这样一来只要自动售货机不为空生产者就可以将饮料放入到自动售货机中去，当然只要售货机有饮料消费者也直接从自动售货机购买饮料。这样一来就方便的多了。

我们前面讲过信号量，P操作遇到为0的情况就会等待。但是现实的生活中，这样的情况就不很科学。回到我们上面的自动售货机的例子。如果我们的消费者发现了自动售货机是空的，我们就开始在原地等待，直到生产者将生产好的饮料送到自动售货机上的时候，再购买。这样以来对个人来说是精力的极大浪费。我们有什么好的方法没有，就像我们滴滴打车一样，我们下单以后就可以去做其他事情了，一有车子接单以后就会电话联系我们。

我们使用一种新的数据结构来解决这种问题：



![img](https://upload-images.jianshu.io/upload_images/3010486-2efc8b8ac6d46579.png?imageMogr2/auto-orient/strip|imageView2/2/w/290/format/webp)

操作函数



![img](https://upload-images.jianshu.io/upload_images/3010486-13968707c6e2a6a1.png?imageMogr2/auto-orient/strip|imageView2/2/w/510/format/webp)

**读者——写者问题**

这个问题类似于上一个，有点儿像我们的购票系统，票数就是我们的共享变量，同一时刻我们允许多个客户从不同的端口登录查看票数在售情况（读者优先），但是当有一个购买者（写者）的买票的时候，写会独占票数。有一个解答如下：



![img](https://upload-images.jianshu.io/upload_images/3010486-7d0764c62db0231d.png?imageMogr2/auto-orient/strip|imageView2/2/w/605/format/webp)

**⑤ 实现一个预线程化的并发服务器**

我们通常所用到的线程并发服务器，要求服务器为每个客户端单独生成一个线程来提供服务，就相当于一种下订单再生产的落后经济模型，我们学习了生产者消费者模型以后，尝试加入新的内容：服务器 由一个主线程和一组工作线程构成，主线程接收客户端的连接请求，并将连接的描述符放入到一个缓冲区中，每个工作线程反复的从缓冲区中取出描述符，提供服务，然后等待下一个描述符。



![img](https://upload-images.jianshu.io/upload_images/3010486-69cbe41bc7826318.png?imageMogr2/auto-orient/strip|imageView2/2/w/387/format/webp)

我们来看看实现代码：



![img](https://upload-images.jianshu.io/upload_images/3010486-8ab5e2ba1125aebd.png?imageMogr2/auto-orient/strip|imageView2/2/w/678/format/webp)

#### 1.6 使用线程提高并行性

------

现代的CPU往往是多核的，如何利用这个特性变得相当重要。我们这里所的并行是并发的一个子集，代表的是在多核处理器上运行的并发程序。

如果我们要计算1,2,3…… 100各个数字相加的和，我们知道经典的答案是：（1+100）*50=5050，我们使用多线程求一个集合数字的和的方法，就是将100个数字分成5个区域，这样每个区域有20个数字，每个对等线程求出5个区域20个数字的和，然后由主线程将不同的和相加，就会得到这100个数字的和。我们来看一段代码：



![img](https://upload-images.jianshu.io/upload_images/3010486-7577994ef9467fc4.png?imageMogr2/auto-orient/strip|imageView2/2/w/697/format/webp)

再来看看求和线程函数sum：



![img](https://upload-images.jianshu.io/upload_images/3010486-c27a69b75afaade2.png?imageMogr2/auto-orient/strip|imageView2/2/w/653/format/webp)

运行结果如下：

#### 1.7 其他并发问题

------

我们在实现程序的并发操作中，要注意很多问题。包括对共享变量的互斥访问，使得程序无论何时何系统，都能得到正确的返回值。不安全的操作有以下四类：

> 1> 不保护共享变量的函数；
>
> 2> 保持跨越多个调用状态的函数（rand、srand）；
>
> 3> 返回指向静态变量指针的函数（ctime）；
>
> 4> 调用线程不安全函数的函数；

说明：对于第3类函数，我们通常使用的是加锁——拷贝模式：



![img](https://upload-images.jianshu.io/upload_images/3010486-08a36fb64e26f233.png?imageMogr2/auto-orient/strip|imageView2/2/w/663/format/webp)

**① 在库函数中使用_r版本**



![img](https://upload-images.jianshu.io/upload_images/3010486-564b8208c0e279f7.png?imageMogr2/auto-orient/strip|imageView2/2/w/565/format/webp)

以上我们列出的是线程不安全函数的_r版本，这些版本不会引用共享的数据，因而在线程中使用是安全的，我们推荐使用_r版本的这类函数。

**② 竞争**

要理解竞争我们最好先来看一个例子：



![img](https://upload-images.jianshu.io/upload_images/3010486-70d0caec2128d0c9.png?imageMogr2/auto-orient/strip|imageView2/2/w/565/format/webp)

这是一个很简单的程序，在主线程中11-12行创建了4个对等线程，分别给每个对等线程传递了一个本地变量i，期望在线程函数中将每个对等线程的id号输出显示。

**当竞争发生的时候：**

如果：先创建了一个线程(1)，传递了本地变量1到线程函数thread中，并显示，这是合理的

如果：创建线程后，thread函数还未输出结果，就切换到主线程又创建新线程就会发生竞争

在不同的系统上得到了不同的结果，我们的改进方法如下：



![img](https://upload-images.jianshu.io/upload_images/3010486-105de4781edf46ce.png?imageMogr2/auto-orient/strip|imageView2/2/w/618/format/webp)

**③ 死锁**



![img](https://upload-images.jianshu.io/upload_images/3010486-4b723def9583ae99.png?imageMogr2/auto-orient/strip|imageView2/2/w/689/format/webp)

死锁是由于我们交替对一对互斥变量（s、t）加锁，如上图所示，线程1先对s加锁，线程2先对t加锁，然后线程1要求对t加锁的时候就必须等待，线程2要求对s加锁的时候也陷入了等待，两个线程都在等待就死锁了。解决之道很简单：

> 线程按照相同的顺序对s、t加锁，也就是说线程1先加锁s再加锁t，线程2先加锁s再加锁t。