# 第一章 操作系统概述

## 1.1 课程概述

wiki

学堂在线

在线交流piazza

预备知识

计算机结构原理

c

汇编

数据结构

教材

操作系统概念

操作系统精髓与设计原理

成绩

- 练习
- 参与
- 实验

考试

- 30期中
- 35期末

## 1.2 教学安排

教学内容

- 操作系统结构
- 中断与系统调用
  - 系统调用：为用户提供的接口
- 内存管理
- 内存管理
- 进程与线程
- 处理机调度
- 同步互斥
- 文件系统
- I/O子系统

练习与实验

课堂练习

实验

- 0 实验环境准备
- 1 系统启动与中断
- 2 物理内存管理
- 3 虚拟内存管理
- 4 内核线程管理
- 5 用户进程管理
- 6 CPU调度
- 7 同步与互斥
- 8 文件系统

ucore+模块化改进

不同硬件上进行

- 多平台上内核可加载模块完善
- 多种平台的动态链接库完善
- 内核功能模块化改造
  - 文件系统、处理机调度算法、内存置换算法、设备驱动程序
- 在真实系统上运行ucore+
  - 树莓派
  - 基于树莓派的集群系统
  - intel edison
- 自选操作系统题目

## 1.3 什么是操作系统

操作系统定义

没有明确定义

操作系统是一个控制程序

- 一个系统软件
- 控制程序执行过程、防止错误不当使用
- 执行用户数据，给用户提供服务
- 方便用户使用操作系统

操作系统是一个资源管理器

- 应用程序与硬件的中间层
- 管理各种计算机软硬件资源
- 提供访问计算机软硬件资源的高效手段
- 解决资源访问冲突。确保资源公平使用

操作系统结构

- 计算机硬件
- 操作系统
- 系统应用
- 应用程序

人群

- 系统设计者
- 程序开发者
- 用户

操作系统的地位

暴露给上层的抽象

- 进程
- 文件
- 地址空间

隐藏下层的内容

- cpu
- 磁盘
- 内存

操作系统软件的分类

软件

- 应用软件
- 系统软件
  - 系统应用
  - 操作系统
    - 命令行
    - 内核

操作系统软件的组成

- kernel-操作系统的内部
  - 资源的管理
- shell-命令行接口
  - 键盘操作
  - 方便用户及命令输入
- GUI图形化接口
- - WIWP
    - 视窗window 图标 icon 选单 menu 指标 point
  - 直接操作和所见即所得

操作系统->用户接口与应用->用户

ucore操作系统

- 应用程序
- 命令行程序 编译器 解释器 系统库
- 系统调用接口
  - 信号
  - 文件管理系统
  - cpu调度
  - 字符设备io
  - 块设备io
  - 虚拟内存管理
  - 物理内存管理
  - 串口驱动
  - 硬盘驱动
- 硬件抽象层
  - 串口控制器
  - 块设备控制器
  - 存储控制器
  - 终端设备
  - 磁盘和磁带
  - 物理内存

操作系统内核特征

- 并发
  - 多个运行的程序，os管理与控制
- 共享
  - 同时访问
  - 互斥访问
- 虚拟
  - 每个用户感觉是专用的
  - 多道程序设计技术
- 异步
  - 不是一部到底，走走停停的，速度不可知
  - 运行环境相同保证程序运行的结果相同

## 1.4 为社么学习操作系统，怎样学习操作系统

操作系统的一个综合课程

- 程序设计语言
- 数据结构
- 算法
- 计算机体系结构

材料

- 操作系统概念与原理、源代码

技能

- 操作系统设计与实现

学习操作系统的目的

- 已经有很好的操作系统
- 知道操作系统已经做的事情，有利于帮助解决新的问题

为什么学？

- 写os酷
- os由用
- 想了解os运行机制
- 参与os开发

操作系统的地位

操作系统：计算机科学研究的基石

- 计算机系统重要组成部分
- 硬件发展和应用需求驱动
- 学术与工业的持续发展

谁在研究操作系统

- 顶尖大学计算机科学部门
- 计算机产业
  - 旧时代：xero,ibm,dec,bell labs
  - 现代：ms,google,yahho,ib,,hp,sum,vmeare,amazon
  - 国内：ali,baidu,huawei
- 研究协会
  - acm sigops
  - usenix

操作系统顶级会议

- acm操作总系统原理研讨会
- usenix操作系统设计研讨会

最有影响力的论文

- sigops hall of fame awards

操作系统的挑战性

- 操作系统很大
  - xp 4500w行
- 操作系统管理并发
  - 并发导致编程挑战
- 操作系统管理硬件
  - 时间依赖行为，非法行为，硬件故障
- 操作系统代码必须高效，低耗cpu 内存 磁盘
- 操作系统出错代价很大，机器崩溃
  - 操作系统稳定性要求更高
- 操作系统安全越来越重要
- 操作系统不仅仅关于并发和琐碎的调度算法
- 并发性是小部分
  - 内核里不存在管程和哲学家问题
  - 内核锁需要太多背景知识
- 磁盘调度大多不相干
- 进程调度已经是很小的话题
- 权衡
  - 时间与空间
  - 性能与可预测性
  - 公平与性能
- 硬件
  - 如何让终端、异常、上下文切换真正有效
  - tlb如何工作、对页表的影响
  - 需要汇编代码

如何学习？

不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之

linux也是本科生

## 1.5 操作系统实例

主流操作系统

window linux 

最早

unix 肯汤姆逊 丹尼斯里奇

bsd系列

solaris

linux

minux转变

windows

微软从dec聘请做window nt

图形接口起家，火爆

## 1.6操作系统的演变

功能：硬件抽象与协调管理

原则：随着技术改变而改变

20年底层技术很大的变化

cpu 4M-3G

处理能力 0.33-76

内存 64k-8G

存储 160kb-1TB

操作系统演变

- 单用户系统
- 批处理系统
- 多道程序系统
- 分时系统
- 个人计算机：一个用户一个系统
- 分布式计算：一个用户多个系统

单用户系统 45-55

操作系统 = 装载器+通用子程序库

问题 昂贵的组件与低利用率

执行时间/执行时间+读卡时间 = 利用率

做法

- 顺序执行与批处理
- cpu执行 job1 job2 job3
- 打印

读卡器

IBM公司发家就靠这个

多道系统 65-80

- 多个工作在内存种工作 复用cpu
- 作业的切换，交替执行

分时系统

- 定时中断用于工作对cpu的复用
- cpu调度

个人计算机系统

- 单用户
- 利用率不是重点
- 重点是用户界面与多媒体功能
- 老服务功能不复存在

演变

- 开始 简单的服务提供者
- 现在 协调与沟通的多应用系统
- 越来越多的安全问题

分布式操作系统

- 网络成为重要功能
- 支持分布式服务
  - 跨多系统的数据共享与协调
- 使用多个处理器
  - 松紧耦合系统
- 高可用性与可靠性的要求

分布式操作系统

- 多个用户通过网络互联
- 计算机硬件的改变影响了操作系统的变化
- 未来计算机
  - 普适计算，云计算，大数据处理，多机联网

## 1.7 操作系统结构

简单结构

硬件 服务

rom bios - ms-dos设备驱动 常驻系统程序 应用程序

没有模块化

汇编编写

没有移植性

x86 dos

**分层结构**

操作系统分层

- 每层建立在低层上
- 0是硬件
- N是用户界面
- 类似于网络分层
- 可移植性是目标
  - 硬件无关 高级语言
  - 硬件相关 汇编程序
- unix与c语言

ucore操作系统

- 应用程序
- 命令行程序 编译器 解释器 系统库
- 系统调用接口
  - 信号
  - 文件管理系统
  - cpu调度
  - 字符设备io
  - 块设备io
  - 虚拟内存管理
  - 物理内存管理
  - 串口驱动
  - 硬盘驱动
- 硬件抽象层
  - 串口控制器
  - 块设备控制器
  - 存储控制器
  - 终端设备
  - 磁盘和磁带
  - 物理内存

需要学习

- 命令行程序
- 文件管理系统
- cpu调度
- 物理内存
- 磁盘驱动
- 串口驱动

微内核结构

内核服务到用户态

- 内核只保留进程通信与硬件支持
- 用户模块通信使用消息传递
- 性能下降
- 灵活
- 安全

外核结构

- 内核放更少功能
- 保护与隔离
- 管理放应用态完成
- 操作系统库实现操作系统抽象
- 类似于虚拟机

虚拟机vm

- 硬件虚拟化
- 虚拟机管理器管理硬件
- 操作系统和虚拟机管理器打交道

操作系统很有趣，控制一个计算机

- 不完备
- 很庞大
- 我们能做到

# 第二章 操作系统实验准备

## 2.1 前言与国内外现状

前言

对操作系统课程的理解

- 原理加实验结合

- 科学与工程结合

- 原理实验并行进行

- 强调动手编程实践

实验要求

- 理解系统
- 循序渐进
- 阅读代码
  - 要完成实验需要阅读大量代码
- 把握全局
- 功能完善
- 改进创新

国外情况——国外

mit xv6 jos

7k行 c语言 x86

实验促进原理理解

solaris windows wrk wince rtems

## 2.2 实验目标

目标：原理与实现建立桥梁

- 原理知识的补充
- 对操作系统一个全局的理解
- 不用层次学生的需求

设计思路

- 差异化教学
  - 高水平 鼓励创新
  - 中水平 完成实验
  - 低水平 理解实验内容
- 方便理解
  - 大量开源软件
  - 环境 win/linux
  - 源代码阅读工具
  - 生成自动文档
  - 编译环境 gcc make binutils
  - 运行环境 x86机器 或 qemu
  - 调试工具 gdb qumu
  - eclips-cdt
- 实验设计
  - 设计思路
    - 小巧全面操作系统改进
    - 外设：Io中断
    - 内存 虚拟内存 页表 缺页 页替换
    - cpu 进程通信 调度器
    - 并发 信号量与互斥
    - 存储 基于链表与fat的文件系统
  - 代码1w行内
  - 提供实验讲义与源码分析文档


 ## 2.3 8个实验概述

1 os 启动，中断与设备管理

2 物理内存管理

3 虚拟内存管理

4 内核线程管理

5 用户进程管理

6 处理及调度

7 同步互斥

8 文件系统

硬件层

boot loader加载os

管理：硬盘 磁盘处理机 内存 进程通信 网络

硬件 内核 应用  

课程设计

lab1 bootloader/interrupt/device driver

- 启动操作系统的bootloader，了解操作系统启动前的状态和要做的准备工作，了解运行操作系统的硬件支持，操作系统如何加载到内存中，理解两类中断-外设中断与陷阱中断
  - 分段机制的存储通道
  - 设备管理的基本概念
  - PC启动bootloader的过程
  - bootloader的文件组成
  - 编译运行bootloader的过程
  - 调试boot loader的方法
  - 汇编级别的栈的结构与处理过程
  - 中断处理机制
  - 串口/并口/CGA输出字符的方法

lab 2 物理内存管理

- 理解x86分段/分页模式，了解操作系统如何管理连续空间的物理内存
  - 理解内存地址的转换与保护
  - 实现页表的建立与使用方法
  - 实现物理内存的管理方法
  - 了解常用的减少碎片的方法

lab3 虚拟内存管理

- 了解页表机制的换出机制，以及中断-故障中断，缺页故障，页面置换算法；
  - 理解换页的软硬件协同机制
  - 实现虚拟内存的page fault异常处理
  - 实现页替换算法

lab4 内核线程管理

- 了解如何利用cpu来搞笑完成各种工作的设计与实现基础，如何创建相对于用户进程更加简单的内核态线程，如何对内核线程进行动态管理

  - 建立内核线程的关键信息

  - 实现内核线程的管理方法

  - 线程切换

    

lab 5 用户进程管理

了解用户态进程创建，执行，切换和结束和动态管理过程，了解用户态通过系统调用得到的内核态的内核服务的过程

- 建立用户进程的关键信息
- 实现用户进程管理
- 分析进程与内存管理的关系
- 实现系统调用的处理过程

lab 6进程调度

用于理解操作系统的调度过程和调度算法

- 熟悉ucore的系统调度器框架，以及内置的round-robin调度算法
- 基于调度器实现一个调度算法

lab 7 同步互斥

了解进程间如何进行信息交换与共享，了解同步互斥的具体实现以及对系统性能的影响，研究死锁产生的原因，以及如何避免死锁

- 熟悉ucore的同步互斥机制
- 理解基本的splinlock，semphpore.condition,carible实现
- 同步机制解决同部问题

lab8 文件系统

了解文件系统的具体实现，与进程管理的关系，了解缓存对操作系统io访问性能的改进，了解虚拟文件系统vfs buffer cache 和disk driver之间的关系

- 掌握基本文件系统调用的实现方法
- 了解一个基于索引节点组织方式的simple fs文件系统的设计与原理
- 了解文件系统抽象层vfs的设计与实现



扩展实验

- 不同的替换算法，类似于linux
- 支持其他cpu arm版的
- 新的文件系统，fat文件系统
- 支持go开发

效果

好的方面

- 理论与实践结合，不再是死记硬背
- 全局观，理解了一个os的整体
- 抽象与细节，硬件的结合
- 大学阶段最复杂的软件设计

值得！

## 2.3 环境搭建

安装实验环境

- 虚拟机安装ubantu

- 使用工具

  - shell
  - 系统维护工具 apt git
  - 源码阅读调试 eclipse-cdt geidt vim
  - 源码比较工具 diff meld
  - 开发编译调试工具gcc gdb make
  - 硬件模拟器 qemu

  内容提要

  了解x86-32硬件

  - 80836运行模式概述
  - 内存架构概述
  - 寄存器特点

  了解ucore编程方法与通用数据结构

  - 面向对象编程方法
  - 通用数据结构

  

  安装实验环境

  虚拟机安装ubantu环境

  - 下载virtualBox虚拟机
  - github上是所有的环境
  - 解压
  - 用户名moocos 口令是空格键、、

  使用实验工具

  shell命令 ls cd rm pwd mkdir find

  - 基于bash
  - 完成对文件目录操作

  系统维护工具

  - apt 安装管理软件
  - git开发版本维护软件

  源码编译工具

  - eclipsecdt
  - understand
  - geit
  - vim

  开发编译

  - gcc
  - gdb
  - make makefile
  - qemu

  

  ## 2.5 x86-32硬件介绍

  了解x86-32运行模式

  80386有四种运行模式

  - 实模式
  - 保护模式
  - SMM模式
  - 虚拟8086模式

  实模式

  80386加电后处于实模式，这种状态下软件可访问的物理内存不超过1MB,无法发挥80386以上界别32位cpu 4GB的内存管理能力

  早期dos系统

  保护模式

  支持内存分页机制，提供了对虚拟内存的良好支持，保护模式下支持多任务，还支持优先级机制，操作系统运行在0级，应用程序在更低级。

  提供了很好的检查机制，实现数据安全共享也很好分离了各个任务

  了解x86-32内存架构

  - 地址是访问内存空间的索引
  - 32位处理器，寻址空间2的32次 4GB
  - 物理内存地址空间是处理器提交总线上用于访问计算机系统中内存与外设的最终地址，一个计算机系统只有一个物理空间
  - 线性地址空间是在操作系统的虚拟管理之下每个运行的应用程序能访问的地址空间。每个运行的应用程序都认为自己独享整个计算机系统的地址空间，使得多个应用程序相互分离 段页模式
  - 逻辑地址空间是应用程序直接使用的地址空间
  - 段机制启动 页机制未启动 逻辑地址->段机制处理->线性地址=物理地址
  - 段机制和也机制都启动 逻辑地址->段机制处理->页机制处理->物理地址

  

  x80286寄存器分为8组

  - 通用寄存器
  - 段寄存器
  - 指令指针寄存器
  - 标志寄存器
  - 控制寄存器
  - 系统地址寄存器，调试寄存器，测试寄存器

  通用寄存器

  - EAX 累加
  - EBX 基址寄存器
  - ECX 计数器
  - EDX 数据寄存器
  - ESI 源地址指针寄存器
  - EDI 目的地址指针
  - EBP基址指针寄存器
  - ESP堆栈指针寄存器

  

  段寄存器

  - CS 代码段
  - DS 数据段
  - ES 附加数据段
  - SS 堆栈段
  - FS 附加段
  - GS 附加段

  指令寄存器和标志寄存器

  EIP 指令寄存器

  EIP 的低16位是8086IP 存储下一条执行的指令的呢村地址，分段地址转换中，表示短萼你偏移地址

  EFLAGS 标志寄存器

  IF 中断允许位

  IF 使得CPU可识别外部中断请求。

  复位IF则禁止中断

  IF对不可屏蔽外部中断的故障中断的识别没有任何作用

  CF，PF,ZF

  ## 2.6 ucore部分编程技巧

  - unore主要基于c语言设计，采用了一定的面向对象的编程方法

  

  - 双向循环链表
    - 通用
  - 链表操作哈数
    - 初始化
    - 增加
    - 删除
  - 访问链表节点所在的宿主数据结构

  ## 2.7 实验演示

  # 第三章 启动 中断 异常和系统调用

  

  

  

- 方便利用理解细节
  - 大量采用开源软件
  - 实验环境
  - 阅读源码工具
# 第三章 启动、中断、异常和系统调用

## 3.1 BIOS

计算机体系结构

cpu

总线

io设备

内存

cpu加电后第一条指令干什么？

第一条指令在内存种？

内存分为 ram rom

rom只读，这种地方内容没了电也会有

启动计算机的系统布局

空闲空间

bios启动固件

空闲空间

cs:ip=0xf000:fff0

cs代码段寄存器 ip指令指针寄存器

系统处于实模式

pc = 16*cs+ip

20位地址空间 1mb空间

bios功能

- 基本输入输出程序
- 系统设置信息
- 开机自检程序
- 系统自启动程序

磁盘

- 程序加载 操作系统

bios

- 磁盘读引导扇区
- 512字节 加载到 0x7c00
- 跳转到cs:ip=0000:7c00

加载程序

- 将操作系统的代码和数据从硬盘加载到内存中
- 跳转到操作系统起始地址

bios数据 加载程序  空闲空间 bios固件 操作系统 空闲空间

BIOS系统调用

BIOS以中断调用方式提供了基本的io功能

INT 10h:字符显示

INT 13h:磁盘扇区读写

INT 15h:检测内存大小

INT 16h:键盘输入

只能在x86实模式下工作

## 3.2 系统启动流程

读bios 读加载程序 加内核

系统加电 bios初始化 硬件

bios

主引导记录：bios读取主引导扇区代码 

活动分区：主引导扇区代码读取活动分区的引导扇区代码

加载程序： 引导扇区代码读取文件系统的加载程序

CPU初始化

cpu加电稳定后从0xfff0读取第一条指令

- cs:ip=0xf000:fff0
- 第一条指令是跳转指令

cpu初始状态为16位实模式

- cs:ip是16位寄存器

- 指令指针pc = 16*cs+ip

- 最大地址空间是1MB

   

BIOS初始化过程

硬件自检POST

检查系统中内存与显卡等关键不见的存在和工作状态

查找并执行显卡等接口bios 进行设备初始化

执行系统bios 进行系统检测

- 检查和配置系统安装的即插即用设备

更新CMOS中扩展配置数据ESCD

按指定启动顺序从软盘、硬盘或光驱启动

主引导记录MBR格式

启动代码 466字节

- 检查分区表正确性
- 加载并跳转到磁盘的引导程序

硬盘分区表：64字节

- 描述分区状态和位置
- 每个分区信息占据16字节





结束标志 2 字节（55AA)

- 主引导记录的有效标志


