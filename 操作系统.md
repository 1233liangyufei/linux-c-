# 第一章 操作系统概述

## 1.1 课程概述

wiki

学堂在线

在线交流piazza

预备知识

计算机结构原理

c

汇编

数据结构

教材

操作系统概念

操作系统精髓与设计原理

成绩

- 练习
- 参与
- 实验

考试

- 30期中
- 35期末

## 1.2 教学安排

教学内容

- 操作系统结构
- 中断与系统调用
  - 系统调用：为用户提供的接口
- 内存管理
- 内存管理
- 进程与线程
- 处理机调度
- 同步互斥
- 文件系统
- I/O子系统

练习与实验

课堂练习

实验

- 0 实验环境准备
- 1 系统启动与中断
- 2 物理内存管理
- 3 虚拟内存管理
- 4 内核线程管理
- 5 用户进程管理
- 6 CPU调度
- 7 同步与互斥
- 8 文件系统

ucore+模块化改进

不同硬件上进行

- 多平台上内核可加载模块完善
- 多种平台的动态链接库完善
- 内核功能模块化改造
  - 文件系统、处理机调度算法、内存置换算法、设备驱动程序
- 在真实系统上运行ucore+
  - 树莓派
  - 基于树莓派的集群系统
  - intel edison
- 自选操作系统题目

## 1.3 什么是操作系统

操作系统定义

没有明确定义

操作系统是一个控制程序

- 一个系统软件
- 控制程序执行过程、防止错误不当使用
- 执行用户数据，给用户提供服务
- 方便用户使用操作系统

操作系统是一个资源管理器

- 应用程序与硬件的中间层
- 管理各种计算机软硬件资源
- 提供访问计算机软硬件资源的高效手段
- 解决资源访问冲突。确保资源公平使用

操作系统结构

- 计算机硬件
- 操作系统
- 系统应用
- 应用程序

人群

- 系统设计者
- 程序开发者
- 用户

操作系统的地位

暴露给上层的抽象

- 进程
- 文件
- 地址空间

隐藏下层的内容

- cpu
- 磁盘
- 内存

操作系统软件的分类

软件

- 应用软件
- 系统软件
  - 系统应用
  - 操作系统
    - 命令行
    - 内核

操作系统软件的组成

- kernel-操作系统的内部
  - 资源的管理
- shell-命令行接口
  - 键盘操作
  - 方便用户及命令输入
- GUI图形化接口
- - WIWP
    - 视窗window 图标 icon 选单 menu 指标 point
  - 直接操作和所见即所得

操作系统->用户接口与应用->用户

ucore操作系统

- 应用程序
- 命令行程序 编译器 解释器 系统库
- 系统调用接口
  - 信号
  - 文件管理系统
  - cpu调度
  - 字符设备io
  - 块设备io
  - 虚拟内存管理
  - 物理内存管理
  - 串口驱动
  - 硬盘驱动
- 硬件抽象层
  - 串口控制器
  - 块设备控制器
  - 存储控制器
  - 终端设备
  - 磁盘和磁带
  - 物理内存

操作系统内核特征

- 并发
  - 多个运行的程序，os管理与控制
- 共享
  - 同时访问
  - 互斥访问
- 虚拟
  - 每个用户感觉是专用的
  - 多道程序设计技术
- 异步
  - 不是一部到底，走走停停的，速度不可知
  - 运行环境相同保证程序运行的结果相同

## 1.4 为社么学习操作系统，怎样学习操作系统

操作系统的一个综合课程

- 程序设计语言
- 数据结构
- 算法
- 计算机体系结构

材料

- 操作系统概念与原理、源代码

技能

- 操作系统设计与实现

学习操作系统的目的

- 已经有很好的操作系统
- 知道操作系统已经做的事情，有利于帮助解决新的问题

为什么学？

- 写os酷
- os由用
- 想了解os运行机制
- 参与os开发

操作系统的地位

操作系统：计算机科学研究的基石

- 计算机系统重要组成部分
- 硬件发展和应用需求驱动
- 学术与工业的持续发展

谁在研究操作系统

- 顶尖大学计算机科学部门
- 计算机产业
  - 旧时代：xero,ibm,dec,bell labs
  - 现代：ms,google,yahho,ib,,hp,sum,vmeare,amazon
  - 国内：ali,baidu,huawei
- 研究协会
  - acm sigops
  - usenix

操作系统顶级会议

- acm操作总系统原理研讨会
- usenix操作系统设计研讨会

最有影响力的论文

- sigops hall of fame awards

操作系统的挑战性

- 操作系统很大
  - xp 4500w行
- 操作系统管理并发
  - 并发导致编程挑战
- 操作系统管理硬件
  - 时间依赖行为，非法行为，硬件故障
- 操作系统代码必须高效，低耗cpu 内存 磁盘
- 操作系统出错代价很大，机器崩溃
  - 操作系统稳定性要求更高
- 操作系统安全越来越重要
- 操作系统不仅仅关于并发和琐碎的调度算法
- 并发性是小部分
  - 内核里不存在管程和哲学家问题
  - 内核锁需要太多背景知识
- 磁盘调度大多不相干
- 进程调度已经是很小的话题
- 权衡
  - 时间与空间
  - 性能与可预测性
  - 公平与性能
- 硬件
  - 如何让终端、异常、上下文切换真正有效
  - tlb如何工作、对页表的影响
  - 需要汇编代码

如何学习？

不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之

linux也是本科生

## 1.5 操作系统实例

主流操作系统

window linux 

最早

unix 肯汤姆逊 丹尼斯里奇

bsd系列

solaris

linux

minux转变

windows

微软从dec聘请做window nt

图形接口起家，火爆

## 1.6操作系统的演变

功能：硬件抽象与协调管理

原则：随着技术改变而改变

20年底层技术很大的变化

cpu 4M-3G

处理能力 0.33-76

内存 64k-8G

存储 160kb-1TB

操作系统演变

- 单用户系统
- 批处理系统
- 多道程序系统
- 分时系统
- 个人计算机：一个用户一个系统
- 分布式计算：一个用户多个系统

单用户系统 45-55

操作系统 = 装载器+通用子程序库

问题 昂贵的组件与低利用率

执行时间/执行时间+读卡时间 = 利用率

做法

- 顺序执行与批处理
- cpu执行 job1 job2 job3
- 打印

读卡器

IBM公司发家就靠这个

多道系统 65-80

- 多个工作在内存种工作 复用cpu
- 作业的切换，交替执行

分时系统

- 定时中断用于工作对cpu的复用
- cpu调度

个人计算机系统

- 单用户
- 利用率不是重点
- 重点是用户界面与多媒体功能
- 老服务功能不复存在

演变

- 开始 简单的服务提供者
- 现在 协调与沟通的多应用系统
- 越来越多的安全问题

分布式操作系统

- 网络成为重要功能
- 支持分布式服务
  - 跨多系统的数据共享与协调
- 使用多个处理器
  - 松紧耦合系统
- 高可用性与可靠性的要求

分布式操作系统

- 多个用户通过网络互联
- 计算机硬件的改变影响了操作系统的变化
- 未来计算机
  - 普适计算，云计算，大数据处理，多机联网

## 1.7 操作系统结构

简单结构

硬件 服务

rom bios - ms-dos设备驱动 常驻系统程序 应用程序

没有模块化

汇编编写

没有移植性

x86 dos

**分层结构**

操作系统分层

- 每层建立在低层上
- 0是硬件
- N是用户界面
- 类似于网络分层
- 可移植性是目标
  - 硬件无关 高级语言
  - 硬件相关 汇编程序
- unix与c语言

ucore操作系统

- 应用程序
- 命令行程序 编译器 解释器 系统库
- 系统调用接口
  - 信号
  - 文件管理系统
  - cpu调度
  - 字符设备io
  - 块设备io
  - 虚拟内存管理
  - 物理内存管理
  - 串口驱动
  - 硬盘驱动
- 硬件抽象层
  - 串口控制器
  - 块设备控制器
  - 存储控制器
  - 终端设备
  - 磁盘和磁带
  - 物理内存

需要学习

- 命令行程序
- 文件管理系统
- cpu调度
- 物理内存
- 磁盘驱动
- 串口驱动

微内核结构

内核服务到用户态

- 内核只保留进程通信与硬件支持
- 用户模块通信使用消息传递
- 性能下降
- 灵活
- 安全

外核结构

- 内核放更少功能
- 保护与隔离
- 管理放应用态完成
- 操作系统库实现操作系统抽象
- 类似于虚拟机

虚拟机vm

- 硬件虚拟化
- 虚拟机管理器管理硬件
- 操作系统和虚拟机管理器打交道

操作系统很有趣，控制一个计算机

- 不完备
- 很庞大
- 我们能做到

# 第二章 操作系统实验准备

## 2.1 前言与国内外现状

前言

对操作系统课程的理解

- 原理加实验结合

- 科学与工程结合

- 原理实验并行进行

- 强调动手编程实践

实验要求

- 理解系统
- 循序渐进
- 阅读代码
  - 要完成实验需要阅读大量代码
- 把握全局
- 功能完善
- 改进创新

国外情况——国外

mit xv6 jos

7k行 c语言 x86

实验促进原理理解

solaris windows wrk wince rtems

## 2.2 实验目标

目标：原理与实现建立桥梁

- 原理知识的补充
- 对操作系统一个全局的理解
- 不用层次学生的需求

设计思路

- 差异化教学
  - 高水平 鼓励创新
  - 中水平 完成实验
  - 低水平 理解实验内容
- 方便理解
  - 大量开源软件
  - 环境 win/linux
  - 源代码阅读工具
  - 生成自动文档
  - 编译环境 gcc make binutils
  - 运行环境 x86机器 或 qemu
  - 调试工具 gdb qumu
  - eclips-cdt
- 实验设计
  - 设计思路
    - 小巧全面操作系统改进
    - 外设：Io中断
    - 内存 虚拟内存 页表 缺页 页替换
    - cpu 进程通信 调度器
    - 并发 信号量与互斥
    - 存储 基于链表与fat的文件系统
  - 代码1w行内
  - 提供实验讲义与源码分析文档


 ## 2.3 8个实验概述

1 os 启动，中断与设备管理

2 物理内存管理

3 虚拟内存管理

4 内核线程管理

5 用户进程管理

6 处理及调度

7 同步互斥

8 文件系统

硬件层

boot loader加载os

管理：硬盘 磁盘处理机 内存 进程通信 网络

硬件 内核 应用  

课程设计

lab1 bootloader/interrupt/device driver

- 启动操作系统的bootloader，了解操作系统启动前的状态和要做的准备工作，了解运行操作系统的硬件支持，操作系统如何加载到内存中，理解两类中断-外设中断与陷阱中断
  - 分段机制的存储通道
  - 设备管理的基本概念
  - PC启动bootloader的过程
  - bootloader的文件组成
  - 编译运行bootloader的过程
  - 调试boot loader的方法
  - 汇编级别的栈的结构与处理过程
  - 中断处理机制
  - 串口/并口/CGA输出字符的方法

lab 2 物理内存管理

- 理解x86分段/分页模式，了解操作系统如何管理连续空间的物理内存
  - 理解内存地址的转换与保护
  - 实现页表的建立与使用方法
  - 实现物理内存的管理方法
  - 了解常用的减少碎片的方法

lab3 虚拟内存管理

- 了解页表机制的换出机制，以及中断-故障中断，缺页故障，页面置换算法；
  - 理解换页的软硬件协同机制
  - 实现虚拟内存的page fault异常处理
  - 实现页替换算法

lab4 内核线程管理

- 了解如何利用cpu来搞笑完成各种工作的设计与实现基础，如何创建相对于用户进程更加简单的内核态线程，如何对内核线程进行动态管理

  - 建立内核线程的关键信息

  - 实现内核线程的管理方法

  - 线程切换

    

lab 5 用户进程管理

了解用户态进程创建，执行，切换和结束和动态管理过程，了解用户态通过系统调用得到的内核态的内核服务的过程

- 建立用户进程的关键信息
- 实现用户进程管理
- 分析进程与内存管理的关系
- 实现系统调用的处理过程

lab 6进程调度

用于理解操作系统的调度过程和调度算法

- 熟悉ucore的系统调度器框架，以及内置的round-robin调度算法
- 基于调度器实现一个调度算法

lab 7 同步互斥

了解进程间如何进行信息交换与共享，了解同步互斥的具体实现以及对系统性能的影响，研究死锁产生的原因，以及如何避免死锁

- 熟悉ucore的同步互斥机制
- 理解基本的splinlock，semphpore.condition,carible实现
- 同步机制解决同部问题

lab8 文件系统

了解文件系统的具体实现，与进程管理的关系，了解缓存对操作系统io访问性能的改进，了解虚拟文件系统vfs buffer cache 和disk driver之间的关系

- 掌握基本文件系统调用的实现方法
- 了解一个基于索引节点组织方式的simple fs文件系统的设计与原理
- 了解文件系统抽象层vfs的设计与实现



扩展实验

- 不同的替换算法，类似于linux
- 支持其他cpu arm版的
- 新的文件系统，fat文件系统
- 支持go开发

效果

好的方面

- 理论与实践结合，不再是死记硬背
- 全局观，理解了一个os的整体
- 抽象与细节，硬件的结合
- 大学阶段最复杂的软件设计

值得！

## 2.3 环境搭建

安装实验环境

- 虚拟机安装ubantu

- 使用工具

  - shell
  - 系统维护工具 apt git
  - 源码阅读调试 eclipse-cdt geidt vim
  - 源码比较工具 diff meld
  - 开发编译调试工具gcc gdb make
  - 硬件模拟器 qemu

  内容提要

  了解x86-32硬件

  - 80836运行模式概述
  - 内存架构概述
  - 寄存器特点

  了解ucore编程方法与通用数据结构

  - 面向对象编程方法
  - 通用数据结构

  

  安装实验环境

  虚拟机安装ubantu环境

  - 下载virtualBox虚拟机
  - github上是所有的环境
  - 解压
  - 用户名moocos 口令是空格键、、

  使用实验工具

  shell命令 ls cd rm pwd mkdir find

  - 基于bash
  - 完成对文件目录操作

  系统维护工具

  - apt 安装管理软件
  - git开发版本维护软件

  源码编译工具

  - eclipsecdt
  - understand
  - geit
  - vim

  开发编译

  - gcc
  - gdb
  - make makefile
  - qemu

  

  ## 2.5 x86-32硬件介绍

  了解x86-32运行模式

  80386有四种运行模式

  - 实模式
  - 保护模式
  - SMM模式
  - 虚拟8086模式

  实模式

  80386加电后处于实模式，这种状态下软件可访问的物理内存不超过1MB,无法发挥80386以上界别32位cpu 4GB的内存管理能力

  早期dos系统

  保护模式

  支持内存分页机制，提供了对虚拟内存的良好支持，保护模式下支持多任务，还支持优先级机制，操作系统运行在0级，应用程序在更低级。

  提供了很好的检查机制，实现数据安全共享也很好分离了各个任务

  了解x86-32内存架构

  - 地址是访问内存空间的索引
  - 32位处理器，寻址空间2的32次 4GB
  - 物理内存地址空间是处理器提交总线上用于访问计算机系统中内存与外设的最终地址，一个计算机系统只有一个物理空间
  - 线性地址空间是在操作系统的虚拟管理之下每个运行的应用程序能访问的地址空间。每个运行的应用程序都认为自己独享整个计算机系统的地址空间，使得多个应用程序相互分离 段页模式
  - 逻辑地址空间是应用程序直接使用的地址空间
  - 段机制启动 页机制未启动 逻辑地址->段机制处理->线性地址=物理地址
  - 段机制和也机制都启动 逻辑地址->段机制处理->页机制处理->物理地址

  

  x80286寄存器分为8组

  - 通用寄存器
  - 段寄存器
  - 指令指针寄存器
  - 标志寄存器
  - 控制寄存器
  - 系统地址寄存器，调试寄存器，测试寄存器

  通用寄存器

  - EAX 累加
  - EBX 基址寄存器
  - ECX 计数器
  - EDX 数据寄存器
  - ESI 源地址指针寄存器
  - EDI 目的地址指针
  - EBP基址指针寄存器
  - ESP堆栈指针寄存器

  

  段寄存器

  - CS 代码段
  - DS 数据段
  - ES 附加数据段
  - SS 堆栈段
  - FS 附加段
  - GS 附加段

  指令寄存器和标志寄存器

  EIP 指令寄存器

  EIP 的低16位是8086IP 存储下一条执行的指令的呢村地址，分段地址转换中，表示短萼你偏移地址

  EFLAGS 标志寄存器

  IF 中断允许位

  IF 使得CPU可识别外部中断请求。

  复位IF则禁止中断

  IF对不可屏蔽外部中断的故障中断的识别没有任何作用

  CF，PF,ZF

  ## 2.6 ucore部分编程技巧

  - unore主要基于c语言设计，采用了一定的面向对象的编程方法

  

  - 双向循环链表
    - 通用
  - 链表操作哈数
    - 初始化
    - 增加
    - 删除
  - 访问链表节点所在的宿主数据结构

  ## 2.7 实验演示
# 第三章 启动、中断、异常和系统调用

## 3.1 BIOS

计算机体系结构

cpu

总线

io设备

内存

cpu加电后第一条指令干什么？

第一条指令在内存种？

内存分为 ram rom

rom只读，这种地方内容没了电也会有

启动计算机的系统布局

空闲空间

bios启动固件

空闲空间

cs:ip=0xf000:fff0

cs代码段寄存器 ip指令指针寄存器

系统处于实模式

pc = 16*cs+ip

20位地址空间 1mb空间

bios功能

- 基本输入输出程序
- 系统设置信息
- 开机自检程序
- 系统自启动程序

磁盘

- 程序加载 操作系统

bios

- 磁盘读引导扇区
- 512字节 加载到 0x7c00
- 跳转到cs:ip=0000:7c00

加载程序

- 将操作系统的代码和数据从硬盘加载到内存中
- 跳转到操作系统起始地址

bios数据 加载程序  空闲空间 bios固件 操作系统 空闲空间

BIOS系统调用

BIOS以中断调用方式提供了基本的io功能

INT 10h:字符显示

INT 13h:磁盘扇区读写

INT 15h:检测内存大小

INT 16h:键盘输入

只能在x86实模式下工作

## 3.2 系统启动流程

读bios 读加载程序 加内核

系统加电 bios初始化 硬件

bios

主引导记录：bios读取主引导扇区代码 

活动分区：主引导扇区代码读取活动分区的引导扇区代码

加载程序： 引导扇区代码读取文件系统的加载程序

CPU初始化

cpu加电稳定后从0xfff0读取第一条指令

- cs:ip=0xf000:fff0
- 第一条指令是跳转指令

cpu初始状态为16位实模式

- cs:ip是16位寄存器

- 指令指针pc = 16*cs+ip

- 最大地址空间是1MB

   

BIOS初始化过程

硬件自检POST

检查系统中内存与显卡等关键不见的存在和工作状态

查找并执行显卡等接口bios 进行设备初始化

执行系统bios 进行系统检测

- 检查和配置系统安装的即插即用设备

更新CMOS中扩展配置数据ESCD

按指定启动顺序从软盘、硬盘或光驱启动

主引导记录MBR格式

启动代码 466字节

- 检查分区表正确性
- 加载并跳转到磁盘的引导程序

硬盘分区表：64字节

- 描述分区状态和位置
- 每个分区信息占据16字节

结束标志 2 字节（55AA)

- 主引导记录的有效标志

分区引导扇区格式

- 文件卷头结构 文件系统描述信息
- 结束标志【0x555 0xAA】
- 跳转指令：跳转到启动代码
  - 平台有关
- 文件卷头：文件系统描述信息
- 启动代码：跳转加载程序
- 结束标志 0x555 0xAA

加载程序

- 文件系统中读取启动配置信息
- 启动菜单：可选的操作系统列表和加载参数
- 依据配置加载 指定内核并跳转带内核执行

系统启动规范

BIOS

- 固化到计算机主板上的程序
- 包括系统设置、自检程序和系统自启动程序
- BIOS-MBR、BIOS-GPT、PXE

UEFI

- 接口标准
- 在所有平台上一致的操作系统启动服务

## 3.3 中断、异常和系统调用的比较

背景

为什么需要中断、异常、系统调用

- 计算机运行中，内核是可以信任的第三方
- 只有内核可以执行特权指令
- 方便应用程序
- 当外设连接计算机时候？敲键盘，外设与系统交互需要处理
- 当应用程序处理意想不到的行为时候，会怎样？处以0咋办

系统调用希望解决问题

- 用户应用程序是如何得到系统服务
- 系统调用与功能调用的区别？

内核

- 外部设备交互
- 中断
- 驱动
- 异常
- 函数库 系统调用
- 异常服务例程
- 中断向量表
- 系统调用表
- 设备驱动程序

系统调用

- 应用程序主动向操作系统发出的服务请求

异常

- 非法指令或其他原因导致指令执行失败

中断

- 硬件设备的处理请求

比较

**源头**

- 中断：外设

- 异常：应用程序想不到的行为

- 系统调用：应用程序请求操作系统提供服务

响应方式

- 中断：异步
- 异常：同步
- 系统调用：异步或同步

硬件处理

- cpu初始化设置中断使能标志
- 中断向量调用中断服务例程

软件

- 现场保存（编译器）
- 中断服务处理（服务例程）
- 清楚中断标记（服务例程）
- 现场恢复（编译器）

中断嵌套

硬件中断服务例程可以被打断

- 不同硬件中断源头可能硬件中断处理同时出现
- 硬件中断服务例程中需要临时禁止中断请求
- 中断请求会保持到cpu做出响应

异常服务例程可被打断

- 异常服务例程执行时候可以被硬件中断

异常服务例程可被嵌套

- 异常服务例程可能出现缺页

## 3.4 系统调用

printf()会除法系统调用write()

- 操作系统服务的编程接口
- 通常由高级语言编写
- 程序访问通过更高层次的AP接口而不是直接系统调用
- 三种常用的应用程序接口API
  - win32 API
  - POSIX API
  - Java API用于JAVA虚拟机

系统调用实现每个系统调用都有一个编号

- 系统调用根据编号来维护表的索引
- 系统调用接口调用内核态的系统调用功能实现，并返回系统调用的状态与结果
- 用户不需要直到系统调用的实现
  - 设置调用参数和获取返回结果
  - 操作系统接口细节大部分隐藏在应用编程接口后
    - 通过运行程序支持的库来管理



系统调用与函数调用不同

系统调用

- INT 和IRET
- 系统调用，堆栈切换与特权级别转换

函数调用

- call和RET用于常规调用
  - 常规调用没有堆栈切换

x86指令手册

中断、异常、系统调用的开销

- 超过函数调用

- 中断、异常与系统调用

  - 引导机制
  - 建立内核堆栈
  - 验证参数
  - 内核映射到用户的地址空间
    - 更新页面映射权限
  - 内核态独立地址空间
    - TLB

  

## 3.5系统调用实例

文件复制过程

源文件->目标文件

- 获取输入文件名
  - 品目现实提示
  - 等待键盘输入
- 获取用户名
- 打开输入文件
- 不存在退出
- 创建输出文件
- 文件存在，出错退出
- 循环
  - 读取输入文件
  - 写入输出文件
- 直到读取结束
- 关闭输出文件
- 屏幕显示完成信息
- 正常退出

需要的调用

- write
- read
- open
- close

ucore库函数read()读文件

read()参数和返回值

- int fd——文件句柄
- void *buf——数据缓冲区指针
- int length——数据缓冲区长度
- int return_value:返回读出数据长度

库函数read()使用实例

- in sfs_filetest1.c:ret = read（fd,data,len)
- 压栈
- 系统调用

read(fd,buffer,length)实现

1 kern/trap/trapentry.S:alltraps()

2.kern/trap/trap.c:trap()

​	tf->trapno==T_SYSCALL

3.kern/syscall/syscall.c:syscall()

tf->tf_regs.reg_eax==SYS_read

4.kern/syscall/syscall.c:sys_read()

tf->sp获取fd,buf,length

5.kern/fd/sysfile.c:sysfilr_read()

读取文件

## 3.6 ucore系统调用代码

# 第四讲 实验一 bootloader启动ucore os

## 4.1启动顺序

理解x86平台启动过程

理解实模式与保护模式

理解段机制

x86启动顺序-第一条指令

CS=F000H , EIP = 0000FFFOH

实际地址：

Base+EIP = FFFF0000H+0000FF0H=FFFFFFF0H

这是BIOS的EPROM所在地

当CS被新值加载，则地址转换规则开始起作用

通常第一条指令是一条长跳转指令（CS和EIP都会更新）到BIOSd代码中执行

x86启动顺序-处于实模式的段

base+offset = 20位地址

段选择子 CS DS SS 

偏移量 EIP

**BIOS到bootloader**

BIOS加载存储设备上第一个扇区（主引导扇区MBR）512字节读取到内存0x7c00

然后转后 0x7c00第一条指令开始执行

bootloader干什么？

- 使能保护模式&段机制 切换模式到切换寻址空间
- 硬盘读取kernel in ELF格式的ucore kernel（MBR后面扇区）并放到内存固定位置
- 跳转到ucore OS入口点执行，这时控制权到了ucore OS中

段机制

段寄存器->段描述符

基地址+偏移地址 = 线性地址=物理地址

GDT 段描述符

使能保护模式

CR0设置为1

- 建立GDT

- CSDS设置好

- 使能保护机制

加载ELF格式的ucore OS kernel

## 4.2 c函数调用的实现

- c函数调用在汇编级别如何实现
- 汇编代码调用c函数
- EBP寄存器函数调用栈

C函数调用实现

压栈

调用函数

弹出

函数

- push ebp
- movl esp ebp
- pop ebp
- 压栈：返回地址，实参

注意事项

- 参数&函数返回值通过寄存器或内存栈来实现
- 不需要保存恢复所有的寄存器

## 4.3 gcc内联汇编

INLINE　ＡＳＳＥＭＢＬＹ

什么是内联汇编

- gcc对c的扩张
- c插入汇编指令

有什么用

- 调用c不支持的指令
- 汇编在c中手动优化

如何工作

- 给定模板和约束来生成汇编
- 在c函数内实现会变汇编

内联汇编

asm 关键字

volatile 不优化

## 4.4 x86中断处理过程

x86中断源

cpu操作系统如何处理中断

对中断像量表进行初始化

中断

- 外部中断 串口 硬盘 网卡 时钟
- 软件产生中断 INT n指令，系统调用

异常

- 程序错误
- 软件产生异常
- 机器检查的异常

x86中断处理-确定中断服务例程

- 每个中断或异常与一个中断服务例程关联，关联存储在中断描述符
- IDT起始地址和大小保存在中断描述符表寄存器IDTR中

不同特权级别中断切换对堆栈的影响

- 内核的中断还在内核
- 用户的中断栈需要栈切换

iret ret retf

iret 弹出eflags ss eip

ret 弹出eip

ret 弹出cs eip

x86中断处理-系统调用

- 用户程序需要系统调用访问os内核服务

- 如何实现

  - 指定中断号
  - 使用trap
  - 使用特殊指令

  ## 4.5 练习1

  实验目的：

  bootloader

  计算机原理

  - cpu编址与寻址
  - cpu中断
  - 外设：串口/并口，时钟，硬盘

  bootloader

  - 编译运行
  - 调试
  - pc启动过程
  - elf文件加载
  - 外设访问

  ucore os

  - 编译
  - 启动
  - 调试
  - 函数调用
  - 中断管理
  - 外设管理

练习

6个基本练习1个扩展联系

练习1 理解make生成执行文件的过程

如何知道主引导扇区是否复合规范

## 4.6 练习2

使用qemu执行并调试lab1的软件

- 单步跟踪

  

## 4.7 练习3



分析bootloader进入保护模式的过程

开启A20，开启A20

初始化GDT表

如何使能和进入保护模式

## 4.8练习4 5

分析bootloader加载elf文件

分析函数调用栈

## 4.9 练习6

完善中断初始化与处理

中断向量表

扩展练习 实习不同特权级别的切换

# 第五章 物理内存管理：连续内存

## 5.1 计算机体系结构和内存层次

计算机体系结构

- 总线
- cpu
- io
- 内存

cpu

- alu
- 寄存器
- 高速缓存
- 存储管理单元mmu

内存

- 最小访问单位8bit 字节
- 32位总线 4字节 对齐

内存层次

- cpu
- L1缓存
- L2缓存
- 内存
- 外存（虚拟内存）

内存管理

内存 外村

内核

- 进程
- 共同地址空间
- 程序地址不重叠
- mmu存储管理：逻辑地址到物理地址

抽象

逻辑地址空间

保护

独立地址空间

共享

访问相同内存

虚拟化

更大的地址空间

**操作系统内存管理方式**

- 重定位 段加偏移
- 分段
- 分页
- 虚拟内存

高度依赖硬件

- mmu cpu识别页表

## 5.2 地址空间和地址生成

地址生成

地址空间定义

物理地址空间——硬件支持的地址空间

- 起始地址0，知道MAX 

逻辑地址空间——CPU运行的进程看到的地址

起始0，最大MAX

地址（address）哪里来？

逻辑到物理

总线访问

逻辑地址的生成

程序

编译

汇编 名字到地址

链接

加载

地址生成时机与限制

- 编译
  - 假设地址已知
  - 如果起始地址改变，重新编译
- 加载
  - 编译时起始位置未知，编译器生成可重定位的代码
  - 加载时，生成绝对地址
- 执行时
  - 执行时代码可移动
  - 需要地址转换硬件支持

执行时最灵活

地址生成过程

cpu

- alu 需要逻辑地址的内存内容
- mmu 进行逻辑地hi和物理地址的转换
- cpu控制逻辑

内存

- 发送物理地址给cpu
- 接受cpu数据到物理地址

os

- 建立逻辑地址与物理地址映射

地址检查

指令

逻辑地址

段基地址和长度 

超过长度非法，内存异常

段长度与段基地址寄存器

物理地址

访问内存

操作系统控制

## 5.3 连续内存分配

连续内存分配

内存碎片

动态分配

- 最先匹配
- 最佳匹配
- 最差匹配

碎片整理

计算机体系结构内存层次

进程分配一块指定大小的连续物理内存



内存碎片

- 空闲内存无法利用

外部碎片

- 分配单元之间未被利用的内存

内部碎片

- 分配单元内部未被使用的内存
- 取决于分配大小是否取整

动态分区分配

- 当程序被加载执行时候，分配一个进程指定大小可变的分区（块）
- 分区地址是连续的

操作系统需要维护的数据结构

- 当所有进程已被分配分区
- 空闲分区

动态分区分配策略

- 最佳匹配 大小
- 最先匹配 地址
- 最差匹配 小大

最先匹配策略

思路：

- 分配n个字节，使用第一个比n大的空闲快

原理与是西安

- 空闲分区地址排序
- 分配时候搜索第一个合适的分区
- 释放分区时候，检查是否可于临近分区合并

优先

- 简单
- 高地址有大块空闲分区

缺点

- 外部碎片
- 分配大块时候较慢

最佳匹配

思路

- 分配n字节分区，查找并使用不小于n的最小空闲分区

实例

- 分配400字节，使用第三给空闲块

原理于实践

- 空闲分区按照大小排序
- 分配，查找一个合适的分区
- 释放时候，查找合并临近的空闲分区

有点

- 大部分分配尺寸较小，效果好
  - 避免大的空闲分区被拆分
  - 可减小外部碎片带线啊哦
  - 简单

缺点

- 外部碎片
- 释放分区慢
- 产生无用的小碎片

最差匹配

分配n字节使用不小于n的最大分区

原理与实践

- 空闲分区大小排序
- 分配选择最大的
- 释放时候与邻近分区合并，进行河滨，调整空闲分区列表

优先

- 中等大小分配表现好
- 避免太多小碎片

缺点

- 释放分区慢
- 外部碎片
- 破坏大分区，难以分配大分区

## 5.4 碎片整理

- 紧凑 
- 分区对换

碎片整理

- 通过调整进程占用的分区位置来减少或避免分区碎片

碎片紧凑

- 通过易懂分配给进程的内存分区，以何冰外部碎片
- 碎片紧凑的条件
  - 所有应用程序可以动态重定位
- 需要解决的问题
  - 什么时候移动
  - 开销

分区兑换

抢占并回收处于等待状态的分区，以增大可用内存空间

进程 就绪 运行 等待 

对换 来实现多进程交替运行

暂停进程放入外存

问题：

交换哪个程序

## 5.5伙伴系统

伙伴系统的实现

折中分配与回收

整个可分配分区大小 2 ^u

需要的分区大小 2u-1<s<2u，整个块分配给进程

s<2i-1，将大小2i的当前空闲分区划分两个空闲分区

重复划分这一过程，一个空闲分区分配一个进程



实现

数据结构

- 空闲快带线啊哦和起始地址组织位二维数组
- 初始状态：只有一个大小位2^u的空闲快

分配过程

- 小到大在空闲分区找最小
- 如果空闲块过大，对其二等分，知道得到合适的可用空闲块

1Mb 块 需要100k 切了又切 切一个128k

240k 256k分配

64k 分配128 切分 分64k

分分合合

释放过程

- 释放块放入空闲十足
- 合并满足合并条件的空闲块

合并条件

- 大小相同
- 地址相邻
- 低地址空闲快起始位2的幂


 
# 第六章 物理内存管理: 非连续内存分配

## 6.1 非连续内存分配的需求背景

分配内存可以不连续吗

非连续分配大小

块与段

大与小

页表

段页式

需求

过去的不够好

连续分配的缺点

- 分配给程序的物理内存必须连续
- 存在外碎片与内碎片
- 内存分配的动态修改困难
- 内存效率低

非连续内存分配目标：提高内存利用率和管理灵活性

- 允许一个程序的使用使用非连续的物理地址空间
- 允许共享代码与数据来减少内存使用
- 允许动态加载于动态链接，动态变化，更加灵活

实现

要解决的问题

- 虚拟地址到物理地址的转换 连续只需要知道头在哪 不连续可能一个程序放在不同地方，难度变大
  - 硬件实现 够用，开销小 
  - 软件实现 灵活，开销大 使用类似外排序来实现
- 非连续分配硬件辅助机制
  - 如何选择飞来内需分配中的内存分配
    - 段式存储 段内连续，段间不连续
    - 页式存储 页页不连续

## 6.2 段式内存分配

段地址空间

段访问机制

段地址空间

- 进程的段地址空间由多个段构成

  - 主代码段
  - 子模块代码段
  - 公共库代码段
  - 对战段
  - 堆数据
  - 初始化数据段
  - 符号表

  段式存储目的

  - 精细灵活以分离共享



段式内存空间的不连续二维结构

代码

数据

堆

栈

不同部分内部连续 外部不连续

段的概念

- 段表示访问方式和存储数据等属性相同的一段地址空间
- 对应一个连续的内存块
- 若干个段组成进程逻辑地址空间

段访问

- s 段号
- addr 段内偏移

段基地址与段内偏移

程序

逻辑地址

短号与段内偏移

查阅段表 软件实现

硬件mmu 查阅越界没有 是否合法

访问物理地址

## 6.3页式存储管理

概念

地址转换

页帧 桢 

- 把物理地址空间划分为大小相同的基本分配单位
- 2的n次方 512 4096 目前通常 4096

页面 

- 把逻辑地址空间划分为相同大小的基本分配单位
- 帧和页大小必须相同

页面到页帧

- 逻辑地址到物理地址
- 页表
- mmu / tlb

页帧

- 物理内存基本快的名称
- 帧号与桢内偏移

内存地址表示二元组(f,o)

物理地址

F+S

f-帧号 f位

o 桢内偏移 s位



假定

16 bit 地址空间

9 bit 带线啊哦的页帧

物理地址计算

3，6

逻辑地址空间划分为大小相等的页

业内偏移 = 桢内偏移

页号 ！= 桢号



进程逻辑地址表示 p o

页号 P位

业内偏移 S位

虚拟地址 p *2^s+o

页式存储地址转换

- 页到桢映射
- 逻辑地址页号连续
- 物理地址帧号不连续
- 不是所有的页都对应桢

页表

页表保存一个映射

页表基地址 页号

## 6.4 页表

页表概述

每个进程一个页表

- 每个页面对应一个页表想
- 随进程运行而动态变化
- 页表基地址寄存器

页表项组成

帧号：f

页表项标志

- 存在位
- 修改位
- 引用位

实例

16位地址

物理内存 32kb

页 1024

页式存储的性能问题

性能问题

- 访问一个内存单元需要2次访存
- 第一次访问：获取页表项
- 第二次访问：访问数据

页表大小问题

- 页表可能很大
- 64位机器每页1024字节，页表项2^54个页面 光地址8个字节*2 54次方，这太奢侈了

处理方法

- 缓存 块表
- 间接访问 多级页表

## 6.5 块表 多级页表

块表 tle

缓存到cpu

缓存近期访问页表

- tle使用关联存储，具有快速访问的性能
- tle命中，物理也好可以快速被获取
- tle不命中，对应页表更新到tle

多级页表

间接引用

页号分为若干级别

p1 p2 p3 0

一级页表 二级页表 三级页表 树状结构

建立树

减少每级页表长度

cr3 ptbr

一级页表 二级页表

多级页表减少长度

## 6.6 反置页表

大地址空间问题

大地址空间系统，多级页表繁琐

- 比如：5级页表
- 逻辑地址空间增长速度快于物理地址空间

页寄存器和反置页面的思路

- 不让页表与逻辑地址空间大小相对应
- 让页表与物理地址空间大小相呼应

页寄存器

美一个帧与一个页寄存器关联，寄存器内容包含

- 使用位：帧是否被占用
- 占用页号：对应页号p
- 保护位

也寄存器实例

物理内存 4096+4096=16MB

页面大小 4kb

页帧数 4k

页寄存器使用空间 8*4096 =32kb

页寄存器额外开销 0.2

虚拟内存大小 任意

优点

- 页表大小相对于物理内存很小
- 页表大小与逻辑地址空间大小无关

缺点

- 页表信息对调后，需要根据帧号找到页号
- 页寄存器搜索逻辑地址找到页号

页寄存器的地址转换

cpu逻辑地址

逻辑地址需要进行hash映射，减少搜索范围

解决冲突问题



块表缓存页表项后页寄存器搜索步骤

- 堆逻辑地址hash变换
- 块表查找对应页表项
- 有冲突遍历冲突项链表
- 查找失败，产生异常

块表的限制

- 快表功耗限制
- 快表功耗限制

反置页表

基于hash映射查找对应页表帧号

- 进程表示与页号的hash值可能冲突
- 页表项包括保护位、修改位、访问位和存在位冲突

## 6.7 段页式存储管理

需求

段式页式各有优势，

段 内存保护

页 内存利用和优化转移到后被存储有优势

结合起来

段页式存储 段式存储加页表

段号 页号 页内偏移

页号 业内偏移



段表项 页表项

内存共享方便

- 通过指向相同页表基地址，实现进程段共享

# **第七章 实验二 物理内存管理**

## 7.1 x86保护模式的特权级

特权级

内存管理单元

X86特权级

内核态 用户态

切换 多态

x86特权及 0 1 2 3 4个

内核 0 级别

应用程序 3级别

实验只需要 0 3

x86特权级别 区别

一些指令只能执行在ring 0 

cpu在如下时刻会检查特权级

- 访问数据段
- 访问页
- 进入中断服务例程

检查失败会如何？

X86特权级 段选择子

特权级 段选择子

RPL 数据段

段描述符号

门描述符

中断门 陷入门

DPL

中断/trap访问

内存段访问

当前特权级别

RPL CPL DPL

RPL 数据

CPL 指令

段/门描述符

访问门 CPL <= DPL CPL>= DPL

访问段时候 MAX(CPL,RPL)<=DPL

## 7.2 了解特权级切换过程

不同特权级别跳转

基于中断来实现

ESP 异常 

软中断

压入数据以便于恢复

SS ESP  EFLAGS CS  EIP  Error Code

切换特权级 0 to 3

3-0

压栈保存现场

x86特权级 tss格式

tss描述符 保存地址 可以找到内核态的数据

## 7.3 了解段/页表

MMU

段机制概述

寄存器

段描述符

cs es ss ds fs gs

基地址与限制

段选择子中隐藏部分

GDT内存里面

段表，访问速度太慢

硬件完成，

可见 16bit

不可见 基地址与段大小 放在cpu里面

建立GDT tables

- init GDT table as an array
- init GDT decriptor
- invoke lgbt
- set bot 0 in cro
- update cs using ljmp

页机制映射

## 7.4建立段页表

mmu 页机制

offset 12 二级 10 一级10

PDE PTE 物理地址

二级页表

线性地址 =虚拟地址

页目录表 页表 页帧

页表项目存放地址是线性地址

cr3指示页目录的地址

页表项

属性

- r/w
- u/s
- a

使能页机制

cr0指示页目录

建立页表

allocate a page as d directory table

clear the page allocated



页面中建立页的映射关系

x86 

段机制

页机制

## 7.5 lab2

实验目的

- 理解基于段页式内存地址的转换机制
- 理解页表的建立与使用方法
- 理解物理内存的管理方法

练习

3基本 2扩展

0 填写已有的实验

1 实现fist fit物理内存分配算法

2 实现寻找虚拟地址对应的页表项

3 释放虚拟地址所在页并取消对应二级页表的映射

扩展 伙伴系统分配算法

扩展 任意大小内存单元slub分配算法

# 第八章 虚拟内存概念

## 8.1 虚拟存储的需求背景

虚拟内存需求

内存 外存

覆盖

交换

局部性

虚拟存储

缺页异常

需求

存储需求的要求更高

电脑游戏

400K大小 软盘

警察抓小偷

更好的画面

足球游戏

交互性 3d动画

程序规模的增长远远大于存储的发展

存储层次结构

理想的存储器

- 容量
- 速度
- 价格
- 非易失性存储

实际

- 寄存器
- 高速缓存
- 内存
- 磁盘
- 磁带

操作系统对存储的抽象：地址空间

p1 p2 p3 内核

操作系统来抽象 不依赖硬件的程序

内存不够用？怎么办

多进程 多线程的问题

咋办？

- 覆盖
  - 手动把需要的指令和数据保存在内存
- 兑换
  - 操作系统自动把不能执行的程序保存到外存
- 虚拟存储
  - 有限内存内，页位单位自动装入更大的程序

## 8.2 覆盖与交换

覆盖与交换

覆盖

目标：

较小的可用内存运行大程序

方法

根据逻辑结构，程序划分为功能独立模块，将不会同时执行的模块共享同一块内存区域

- 必要部分（常用功能）的代码和数据常驻内存
- 可选部分（不常用功能）放在其他程序模块中，需要时候再装入内存

例子

190k的程序

物理内存不够190k

咋办？

划分 根据独立划分a b c d f

a 

b c

d e f

a   max(b c) max(d e f)

110k 能用了

覆盖牛逼啊

换一个分区方式 用的内存更小了

dos turbo pascal overlay支持覆盖技术

太难了

覆盖技术不足

- 编程困难
  - 程序员决定划分模块
  - 编程困难
- 增加执行时间
  - 时间换空间
  - 外存装入覆盖 耗费时间



交换技术

目标

增加正在运行或需要运行的程序的内存

只讨论多个程序导致不够用的问题

方法

- 将不能运行的程序放到外存
- 换入换出基本单位是整个进程
- 换入 进程地址空间到外存
- 换出 反之

问题

交换时机：啥时候整？

- 内存不够时候换出

交换区大小

- 存放所有进程的内存映像的拷贝

换入重定位：换出换入能否放原处

- 动他地址转换

覆盖

- 只发生没有调用的模块
- 程序员给出模块划分
- 发生再程序内部模块

交换

- 进程为单位
- 操作系统做
- 发生内存进程间
- 不需要模块间逻辑覆盖结构

## 8.3虚拟存储


