# 第一章 操作系统概述

## 1.1 课程概述

wiki

学堂在线

在线交流piazza

预备知识

计算机结构原理

c

汇编

数据结构

教材

操作系统概念

操作系统精髓与设计原理

成绩

- 练习
- 参与
- 实验

考试

- 30期中
- 35期末

## 1.2 教学安排

教学内容

- 操作系统结构
- 中断与系统调用
  - 系统调用：为用户提供的接口
- 内存管理
- 内存管理
- 进程与线程
- 处理机调度
- 同步互斥
- 文件系统
- I/O子系统

练习与实验

课堂练习

实验

- 0 实验环境准备
- 1 系统启动与中断
- 2 物理内存管理
- 3 虚拟内存管理
- 4 内核线程管理
- 5 用户进程管理
- 6 CPU调度
- 7 同步与互斥
- 8 文件系统

ucore+模块化改进

不同硬件上进行

- 多平台上内核可加载模块完善
- 多种平台的动态链接库完善
- 内核功能模块化改造
  - 文件系统、处理机调度算法、内存置换算法、设备驱动程序
- 在真实系统上运行ucore+
  - 树莓派
  - 基于树莓派的集群系统
  - intel edison
- 自选操作系统题目

## 1.3 什么是操作系统

操作系统定义

没有明确定义

操作系统是一个控制程序

- 一个系统软件
- 控制程序执行过程、防止错误不当使用
- 执行用户数据，给用户提供服务
- 方便用户使用操作系统

操作系统是一个资源管理器

- 应用程序与硬件的中间层
- 管理各种计算机软硬件资源
- 提供访问计算机软硬件资源的高效手段
- 解决资源访问冲突。确保资源公平使用

操作系统结构

- 计算机硬件
- 操作系统
- 系统应用
- 应用程序

人群

- 系统设计者
- 程序开发者
- 用户

操作系统的地位

暴露给上层的抽象

- 进程
- 文件
- 地址空间

隐藏下层的内容

- cpu
- 磁盘
- 内存

操作系统软件的分类

软件

- 应用软件
- 系统软件
  - 系统应用
  - 操作系统
    - 命令行
    - 内核

操作系统软件的组成

- kernel-操作系统的内部
  - 资源的管理
- shell-命令行接口
  - 键盘操作
  - 方便用户及命令输入
- GUI图形化接口
- - WIWP
    - 视窗window 图标 icon 选单 menu 指标 point
  - 直接操作和所见即所得

操作系统->用户接口与应用->用户

ucore操作系统

- 应用程序
- 命令行程序 编译器 解释器 系统库
- 系统调用接口
  - 信号
  - 文件管理系统
  - cpu调度
  - 字符设备io
  - 块设备io
  - 虚拟内存管理
  - 物理内存管理
  - 串口驱动
  - 硬盘驱动
- 硬件抽象层
  - 串口控制器
  - 块设备控制器
  - 存储控制器
  - 终端设备
  - 磁盘和磁带
  - 物理内存

操作系统内核特征

- 并发
  - 多个运行的程序，os管理与控制
- 共享
  - 同时访问
  - 互斥访问
- 虚拟
  - 每个用户感觉是专用的
  - 多道程序设计技术
- 异步
  - 不是一部到底，走走停停的，速度不可知
  - 运行环境相同保证程序运行的结果相同

## 1.4 为社么学习操作系统，怎样学习操作系统

操作系统的一个综合课程

- 程序设计语言
- 数据结构
- 算法
- 计算机体系结构

材料

- 操作系统概念与原理、源代码

技能

- 操作系统设计与实现

学习操作系统的目的

- 已经有很好的操作系统
- 知道操作系统已经做的事情，有利于帮助解决新的问题

为什么学？

- 写os酷
- os由用
- 想了解os运行机制
- 参与os开发

操作系统的地位

操作系统：计算机科学研究的基石

- 计算机系统重要组成部分
- 硬件发展和应用需求驱动
- 学术与工业的持续发展

谁在研究操作系统

- 顶尖大学计算机科学部门
- 计算机产业
  - 旧时代：xero,ibm,dec,bell labs
  - 现代：ms,google,yahho,ib,,hp,sum,vmeare,amazon
  - 国内：ali,baidu,huawei
- 研究协会
  - acm sigops
  - usenix

操作系统顶级会议

- acm操作总系统原理研讨会
- usenix操作系统设计研讨会

最有影响力的论文

- sigops hall of fame awards

操作系统的挑战性

- 操作系统很大
  - xp 4500w行
- 操作系统管理并发
  - 并发导致编程挑战
- 操作系统管理硬件
  - 时间依赖行为，非法行为，硬件故障
- 操作系统代码必须高效，低耗cpu 内存 磁盘
- 操作系统出错代价很大，机器崩溃
  - 操作系统稳定性要求更高
- 操作系统安全越来越重要
- 操作系统不仅仅关于并发和琐碎的调度算法
- 并发性是小部分
  - 内核里不存在管程和哲学家问题
  - 内核锁需要太多背景知识
- 磁盘调度大多不相干
- 进程调度已经是很小的话题
- 权衡
  - 时间与空间
  - 性能与可预测性
  - 公平与性能
- 硬件
  - 如何让终端、异常、上下文切换真正有效
  - tlb如何工作、对页表的影响
  - 需要汇编代码

如何学习？

不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之

linux也是本科生

## 1.5 操作系统实例

主流操作系统

window linux 

最早

unix 肯汤姆逊 丹尼斯里奇

bsd系列

solaris

linux

minux转变

windows

微软从dec聘请做window nt

图形接口起家，火爆

## 1.6操作系统的演变

功能：硬件抽象与协调管理

原则：随着技术改变而改变

20年底层技术很大的变化

cpu 4M-3G

处理能力 0.33-76

内存 64k-8G

存储 160kb-1TB

操作系统演变

- 单用户系统
- 批处理系统
- 多道程序系统
- 分时系统
- 个人计算机：一个用户一个系统
- 分布式计算：一个用户多个系统

单用户系统 45-55

操作系统 = 装载器+通用子程序库

问题 昂贵的组件与低利用率

执行时间/执行时间+读卡时间 = 利用率

做法

- 顺序执行与批处理
- cpu执行 job1 job2 job3
- 打印

读卡器

IBM公司发家就靠这个

多道系统 65-80

- 多个工作在内存种工作 复用cpu
- 作业的切换，交替执行

分时系统

- 定时中断用于工作对cpu的复用
- cpu调度

个人计算机系统

- 单用户
- 利用率不是重点
- 重点是用户界面与多媒体功能
- 老服务功能不复存在

演变

- 开始 简单的服务提供者
- 现在 协调与沟通的多应用系统
- 越来越多的安全问题

分布式操作系统

- 网络成为重要功能
- 支持分布式服务
  - 跨多系统的数据共享与协调
- 使用多个处理器
  - 松紧耦合系统
- 高可用性与可靠性的要求

分布式操作系统

- 多个用户通过网络互联
- 计算机硬件的改变影响了操作系统的变化
- 未来计算机
  - 普适计算，云计算，大数据处理，多机联网

## 1.7 操作系统结构

简单结构

硬件 服务

rom bios - ms-dos设备驱动 常驻系统程序 应用程序

没有模块化

汇编编写

没有移植性

x86 dos

**分层结构**

操作系统分层

- 每层建立在低层上
- 0是硬件
- N是用户界面
- 类似于网络分层
- 可移植性是目标
  - 硬件无关 高级语言
  - 硬件相关 汇编程序
- unix与c语言

ucore操作系统

- 应用程序
- 命令行程序 编译器 解释器 系统库
- 系统调用接口
  - 信号
  - 文件管理系统
  - cpu调度
  - 字符设备io
  - 块设备io
  - 虚拟内存管理
  - 物理内存管理
  - 串口驱动
  - 硬盘驱动
- 硬件抽象层
  - 串口控制器
  - 块设备控制器
  - 存储控制器
  - 终端设备
  - 磁盘和磁带
  - 物理内存

需要学习

- 命令行程序
- 文件管理系统
- cpu调度
- 物理内存
- 磁盘驱动
- 串口驱动

微内核结构

内核服务到用户态

- 内核只保留进程通信与硬件支持
- 用户模块通信使用消息传递
- 性能下降
- 灵活
- 安全

外核结构

- 内核放更少功能
- 保护与隔离
- 管理放应用态完成
- 操作系统库实现操作系统抽象
- 类似于虚拟机

虚拟机vm

- 硬件虚拟化
- 虚拟机管理器管理硬件
- 操作系统和虚拟机管理器打交道

操作系统很有趣，控制一个计算机

- 不完备
- 很庞大
- 我们能做到

# 第二章 操作系统实验准备

## 2.1 前言与国内外现状

前言

对操作系统课程的理解

- 原理加实验结合

- 科学与工程结合

- 原理实验并行进行

- 强调动手编程实践

实验要求

- 理解系统
- 循序渐进
- 阅读代码
  - 要完成实验需要阅读大量代码
- 把握全局
- 功能完善
- 改进创新

国外情况——国外

mit xv6 jos

7k行 c语言 x86

实验促进原理理解

solaris windows wrk wince rtems

## 2.2 实验目标

目标：原理与实现建立桥梁

- 原理知识的补充
- 对操作系统一个全局的理解
- 不用层次学生的需求

设计思路

- 差异化教学
  - 高水平 鼓励创新
  - 中水平 完成实验
  - 低水平 理解实验内容
- 方便理解
  - 大量开源软件
  - 环境 win/linux
  - 源代码阅读工具
  - 生成自动文档
  - 编译环境 gcc make binutils
  - 运行环境 x86机器 或 qemu
  - 调试工具 gdb qumu
  - eclips-cdt
- 实验设计
  - 设计思路
    - 小巧全面操作系统改进
    - 外设：Io中断
    - 内存 虚拟内存 页表 缺页 页替换
    - cpu 进程通信 调度器
    - 并发 信号量与互斥
    - 存储 基于链表与fat的文件系统
  - 代码1w行内
  - 提供实验讲义与源码分析文档


 ## 2.3 8个实验概述

1 os 启动，中断与设备管理

2 物理内存管理

3 虚拟内存管理

4 内核线程管理

5 用户进程管理

6 处理及调度

7 同步互斥

8 文件系统

硬件层

boot loader加载os

管理：硬盘 磁盘处理机 内存 进程通信 网络

硬件 内核 应用  

课程设计

lab1 bootloader/interrupt/device driver

- 启动操作系统的bootloader，了解操作系统启动前的状态和要做的准备工作，了解运行操作系统的硬件支持，操作系统如何加载到内存中，理解两类中断-外设中断与陷阱中断
  - 分段机制的存储通道
  - 设备管理的基本概念
  - PC启动bootloader的过程
  - bootloader的文件组成
  - 编译运行bootloader的过程
  - 调试boot loader的方法
  - 汇编级别的栈的结构与处理过程
  - 中断处理机制
  - 串口/并口/CGA输出字符的方法

lab 2 物理内存管理

- 理解x86分段/分页模式，了解操作系统如何管理连续空间的物理内存
  - 理解内存地址的转换与保护
  - 实现页表的建立与使用方法
  - 实现物理内存的管理方法
  - 了解常用的减少碎片的方法

lab3 虚拟内存管理

- 了解页表机制的换出机制，以及中断-故障中断，缺页故障，页面置换算法；
  - 理解换页的软硬件协同机制
  - 实现虚拟内存的page fault异常处理
  - 实现页替换算法

lab4 内核线程管理

- 了解如何利用cpu来搞笑完成各种工作的设计与实现基础，如何创建相对于用户进程更加简单的内核态线程，如何对内核线程进行动态管理

  - 建立内核线程的关键信息

  - 实现内核线程的管理方法

  - 线程切换

    

lab 5 用户进程管理

了解用户态进程创建，执行，切换和结束和动态管理过程，了解用户态通过系统调用得到的内核态的内核服务的过程

- 建立用户进程的关键信息
- 实现用户进程管理
- 分析进程与内存管理的关系
- 实现系统调用的处理过程

lab 6进程调度

用于理解操作系统的调度过程和调度算法

- 熟悉ucore的系统调度器框架，以及内置的round-robin调度算法
- 基于调度器实现一个调度算法

lab 7 同步互斥

了解进程间如何进行信息交换与共享，了解同步互斥的具体实现以及对系统性能的影响，研究死锁产生的原因，以及如何避免死锁

- 熟悉ucore的同步互斥机制
- 理解基本的splinlock，semphpore.condition,carible实现
- 同步机制解决同部问题

lab8 文件系统

了解文件系统的具体实现，与进程管理的关系，了解缓存对操作系统io访问性能的改进，了解虚拟文件系统vfs buffer cache 和disk driver之间的关系

- 掌握基本文件系统调用的实现方法
- 了解一个基于索引节点组织方式的simple fs文件系统的设计与原理
- 了解文件系统抽象层vfs的设计与实现



扩展实验

- 不同的替换算法，类似于linux
- 支持其他cpu arm版的
- 新的文件系统，fat文件系统
- 支持go开发

效果

好的方面

- 理论与实践结合，不再是死记硬背
- 全局观，理解了一个os的整体
- 抽象与细节，硬件的结合
- 大学阶段最复杂的软件设计

值得！

## 2.3 环境搭建

安装实验环境

- 虚拟机安装ubantu

- 使用工具

  - shell
  - 系统维护工具 apt git
  - 源码阅读调试 eclipse-cdt geidt vim
  - 源码比较工具 diff meld
  - 开发编译调试工具gcc gdb make
  - 硬件模拟器 qemu

  内容提要

  了解x86-32硬件

  - 80836运行模式概述
  - 内存架构概述
  - 寄存器特点

  了解ucore编程方法与通用数据结构

  - 面向对象编程方法
  - 通用数据结构

  

  安装实验环境

  虚拟机安装ubantu环境

  - 下载virtualBox虚拟机
  - github上是所有的环境
  - 解压
  - 用户名moocos 口令是空格键、、

  使用实验工具

  shell命令 ls cd rm pwd mkdir find

  - 基于bash
  - 完成对文件目录操作

  系统维护工具

  - apt 安装管理软件
  - git开发版本维护软件

  源码编译工具

  - eclipsecdt
  - understand
  - geit
  - vim

  开发编译

  - gcc
  - gdb
  - make makefile
  - qemu

  

  ## 2.5 x86-32硬件介绍

  了解x86-32运行模式

  80386有四种运行模式

  - 实模式
  - 保护模式
  - SMM模式
  - 虚拟8086模式

  实模式

  80386加电后处于实模式，这种状态下软件可访问的物理内存不超过1MB,无法发挥80386以上界别32位cpu 4GB的内存管理能力

  早期dos系统

  保护模式

  支持内存分页机制，提供了对虚拟内存的良好支持，保护模式下支持多任务，还支持优先级机制，操作系统运行在0级，应用程序在更低级。

  提供了很好的检查机制，实现数据安全共享也很好分离了各个任务

  了解x86-32内存架构

  - 地址是访问内存空间的索引
  - 32位处理器，寻址空间2的32次 4GB
  - 物理内存地址空间是处理器提交总线上用于访问计算机系统中内存与外设的最终地址，一个计算机系统只有一个物理空间
  - 线性地址空间是在操作系统的虚拟管理之下每个运行的应用程序能访问的地址空间。每个运行的应用程序都认为自己独享整个计算机系统的地址空间，使得多个应用程序相互分离 段页模式
  - 逻辑地址空间是应用程序直接使用的地址空间
  - 段机制启动 页机制未启动 逻辑地址->段机制处理->线性地址=物理地址
  - 段机制和也机制都启动 逻辑地址->段机制处理->页机制处理->物理地址

  

  x80286寄存器分为8组

  - 通用寄存器
  - 段寄存器
  - 指令指针寄存器
  - 标志寄存器
  - 控制寄存器
  - 系统地址寄存器，调试寄存器，测试寄存器

  通用寄存器

  - EAX 累加
  - EBX 基址寄存器
  - ECX 计数器
  - EDX 数据寄存器
  - ESI 源地址指针寄存器
  - EDI 目的地址指针
  - EBP基址指针寄存器
  - ESP堆栈指针寄存器

  

  段寄存器

  - CS 代码段
  - DS 数据段
  - ES 附加数据段
  - SS 堆栈段
  - FS 附加段
  - GS 附加段

  指令寄存器和标志寄存器

  EIP 指令寄存器

  EIP 的低16位是8086IP 存储下一条执行的指令的呢村地址，分段地址转换中，表示短萼你偏移地址

  EFLAGS 标志寄存器

  IF 中断允许位

  IF 使得CPU可识别外部中断请求。

  复位IF则禁止中断

  IF对不可屏蔽外部中断的故障中断的识别没有任何作用

  CF，PF,ZF

  ## 2.6 ucore部分编程技巧

  - unore主要基于c语言设计，采用了一定的面向对象的编程方法

  

  - 双向循环链表
    - 通用
  - 链表操作哈数
    - 初始化
    - 增加
    - 删除
  - 访问链表节点所在的宿主数据结构

  ## 2.7 实验演示
# 第三章 启动、中断、异常和系统调用

## 3.1 BIOS

计算机体系结构

cpu

总线

io设备

内存

cpu加电后第一条指令干什么？

第一条指令在内存种？

内存分为 ram rom

rom只读，这种地方内容没了电也会有

启动计算机的系统布局

空闲空间

bios启动固件

空闲空间

cs:ip=0xf000:fff0

cs代码段寄存器 ip指令指针寄存器

系统处于实模式

pc = 16*cs+ip

20位地址空间 1mb空间

bios功能

- 基本输入输出程序
- 系统设置信息
- 开机自检程序
- 系统自启动程序

磁盘

- 程序加载 操作系统

bios

- 磁盘读引导扇区
- 512字节 加载到 0x7c00
- 跳转到cs:ip=0000:7c00

加载程序

- 将操作系统的代码和数据从硬盘加载到内存中
- 跳转到操作系统起始地址

bios数据 加载程序  空闲空间 bios固件 操作系统 空闲空间

BIOS系统调用

BIOS以中断调用方式提供了基本的io功能

INT 10h:字符显示

INT 13h:磁盘扇区读写

INT 15h:检测内存大小

INT 16h:键盘输入

只能在x86实模式下工作

## 3.2 系统启动流程

读bios 读加载程序 加内核

系统加电 bios初始化 硬件

bios

主引导记录：bios读取主引导扇区代码 

活动分区：主引导扇区代码读取活动分区的引导扇区代码

加载程序： 引导扇区代码读取文件系统的加载程序

CPU初始化

cpu加电稳定后从0xfff0读取第一条指令

- cs:ip=0xf000:fff0
- 第一条指令是跳转指令

cpu初始状态为16位实模式

- cs:ip是16位寄存器

- 指令指针pc = 16*cs+ip

- 最大地址空间是1MB

   

BIOS初始化过程

硬件自检POST

检查系统中内存与显卡等关键不见的存在和工作状态

查找并执行显卡等接口bios 进行设备初始化

执行系统bios 进行系统检测

- 检查和配置系统安装的即插即用设备

更新CMOS中扩展配置数据ESCD

按指定启动顺序从软盘、硬盘或光驱启动

主引导记录MBR格式

启动代码 466字节

- 检查分区表正确性
- 加载并跳转到磁盘的引导程序

硬盘分区表：64字节

- 描述分区状态和位置
- 每个分区信息占据16字节

结束标志 2 字节（55AA)

- 主引导记录的有效标志

分区引导扇区格式

- 文件卷头结构 文件系统描述信息
- 结束标志【0x555 0xAA】
- 跳转指令：跳转到启动代码
  - 平台有关
- 文件卷头：文件系统描述信息
- 启动代码：跳转加载程序
- 结束标志 0x555 0xAA

加载程序

- 文件系统中读取启动配置信息
- 启动菜单：可选的操作系统列表和加载参数
- 依据配置加载 指定内核并跳转带内核执行

系统启动规范

BIOS

- 固化到计算机主板上的程序
- 包括系统设置、自检程序和系统自启动程序
- BIOS-MBR、BIOS-GPT、PXE

UEFI

- 接口标准
- 在所有平台上一致的操作系统启动服务

## 3.3 中断、异常和系统调用的比较

背景

为什么需要中断、异常、系统调用

- 计算机运行中，内核是可以信任的第三方
- 只有内核可以执行特权指令
- 方便应用程序
- 当外设连接计算机时候？敲键盘，外设与系统交互需要处理
- 当应用程序处理意想不到的行为时候，会怎样？处以0咋办

系统调用希望解决问题

- 用户应用程序是如何得到系统服务
- 系统调用与功能调用的区别？

内核

- 外部设备交互
- 中断
- 驱动
- 异常
- 函数库 系统调用
- 异常服务例程
- 中断向量表
- 系统调用表
- 设备驱动程序

系统调用

- 应用程序主动向操作系统发出的服务请求

异常

- 非法指令或其他原因导致指令执行失败

中断

- 硬件设备的处理请求

比较

**源头**

- 中断：外设

- 异常：应用程序想不到的行为

- 系统调用：应用程序请求操作系统提供服务

响应方式

- 中断：异步
- 异常：同步
- 系统调用：异步或同步

硬件处理

- cpu初始化设置中断使能标志
- 中断向量调用中断服务例程

软件

- 现场保存（编译器）
- 中断服务处理（服务例程）
- 清楚中断标记（服务例程）
- 现场恢复（编译器）

中断嵌套

硬件中断服务例程可以被打断

- 不同硬件中断源头可能硬件中断处理同时出现
- 硬件中断服务例程中需要临时禁止中断请求
- 中断请求会保持到cpu做出响应

异常服务例程可被打断

- 异常服务例程执行时候可以被硬件中断

异常服务例程可被嵌套

- 异常服务例程可能出现缺页

## 3.4 系统调用

printf()会除法系统调用write()

- 操作系统服务的编程接口
- 通常由高级语言编写
- 程序访问通过更高层次的AP接口而不是直接系统调用
- 三种常用的应用程序接口API
  - win32 API
  - POSIX API
  - Java API用于JAVA虚拟机

系统调用实现每个系统调用都有一个编号

- 系统调用根据编号来维护表的索引
- 系统调用接口调用内核态的系统调用功能实现，并返回系统调用的状态与结果
- 用户不需要直到系统调用的实现
  - 设置调用参数和获取返回结果
  - 操作系统接口细节大部分隐藏在应用编程接口后
    - 通过运行程序支持的库来管理



系统调用与函数调用不同

系统调用

- INT 和IRET
- 系统调用，堆栈切换与特权级别转换

函数调用

- call和RET用于常规调用
  - 常规调用没有堆栈切换

x86指令手册

中断、异常、系统调用的开销

- 超过函数调用

- 中断、异常与系统调用

  - 引导机制
  - 建立内核堆栈
  - 验证参数
  - 内核映射到用户的地址空间
    - 更新页面映射权限
  - 内核态独立地址空间
    - TLB

  

## 3.5系统调用实例

文件复制过程

源文件->目标文件

- 获取输入文件名
  - 品目现实提示
  - 等待键盘输入
- 获取用户名
- 打开输入文件
- 不存在退出
- 创建输出文件
- 文件存在，出错退出
- 循环
  - 读取输入文件
  - 写入输出文件
- 直到读取结束
- 关闭输出文件
- 屏幕显示完成信息
- 正常退出

需要的调用

- write
- read
- open
- close

ucore库函数read()读文件

read()参数和返回值

- int fd——文件句柄
- void *buf——数据缓冲区指针
- int length——数据缓冲区长度
- int return_value:返回读出数据长度

库函数read()使用实例

- in sfs_filetest1.c:ret = read（fd,data,len)
- 压栈
- 系统调用

read(fd,buffer,length)实现

1 kern/trap/trapentry.S:alltraps()

2.kern/trap/trap.c:trap()

​	tf->trapno==T_SYSCALL

3.kern/syscall/syscall.c:syscall()

tf->tf_regs.reg_eax==SYS_read

4.kern/syscall/syscall.c:sys_read()

tf->sp获取fd,buf,length

5.kern/fd/sysfile.c:sysfilr_read()

读取文件

## 3.6 ucore系统调用代码

# 第四讲 实验一 bootloader启动ucore os

## 4.1启动顺序

理解x86平台启动过程

理解实模式与保护模式

理解段机制

x86启动顺序-第一条指令

CS=F000H , EIP = 0000FFFOH

实际地址：

Base+EIP = FFFF0000H+0000FF0H=FFFFFFF0H

这是BIOS的EPROM所在地

当CS被新值加载，则地址转换规则开始起作用

通常第一条指令是一条长跳转指令（CS和EIP都会更新）到BIOSd代码中执行

x86启动顺序-处于实模式的段

base+offset = 20位地址

段选择子 CS DS SS 

偏移量 EIP

**BIOS到bootloader**

BIOS加载存储设备上第一个扇区（主引导扇区MBR）512字节读取到内存0x7c00

然后转后 0x7c00第一条指令开始执行

bootloader干什么？

- 使能保护模式&段机制 切换模式到切换寻址空间
- 硬盘读取kernel in ELF格式的ucore kernel（MBR后面扇区）并放到内存固定位置
- 跳转到ucore OS入口点执行，这时控制权到了ucore OS中

段机制

段寄存器->段描述符

基地址+偏移地址 = 线性地址=物理地址

GDT 段描述符

使能保护模式

CR0设置为1

- 建立GDT

- CSDS设置好

- 使能保护机制

加载ELF格式的ucore OS kernel

## 4.2 c函数调用的实现

- c函数调用在汇编级别如何实现
- 汇编代码调用c函数
- EBP寄存器函数调用栈

C函数调用实现

压栈

调用函数

弹出

函数

- push ebp
- movl esp ebp
- pop ebp
- 压栈：返回地址，实参

注意事项

- 参数&函数返回值通过寄存器或内存栈来实现
- 不需要保存恢复所有的寄存器

## 4.3 gcc内联汇编

INLINE　ＡＳＳＥＭＢＬＹ

什么是内联汇编

- gcc对c的扩张
- c插入汇编指令

有什么用

- 调用c不支持的指令
- 汇编在c中手动优化

如何工作

- 给定模板和约束来生成汇编
- 在c函数内实现会变汇编

内联汇编

asm 关键字

volatile 不优化

## 4.4 x86中断处理过程

x86中断源

cpu操作系统如何处理中断

对中断像量表进行初始化

中断

- 外部中断 串口 硬盘 网卡 时钟
- 软件产生中断 INT n指令，系统调用

异常

- 程序错误
- 软件产生异常
- 机器检查的异常

x86中断处理-确定中断服务例程

- 每个中断或异常与一个中断服务例程关联，关联存储在中断描述符
- IDT起始地址和大小保存在中断描述符表寄存器IDTR中

不同特权级别中断切换对堆栈的影响

- 内核的中断还在内核
- 用户的中断栈需要栈切换

iret ret retf

iret 弹出eflags ss eip

ret 弹出eip

ret 弹出cs eip

x86中断处理-系统调用

- 用户程序需要系统调用访问os内核服务

- 如何实现

  - 指定中断号
  - 使用trap
  - 使用特殊指令

  ## 4.5 练习1

  实验目的：

  bootloader

  计算机原理

  - cpu编址与寻址
  - cpu中断
  - 外设：串口/并口，时钟，硬盘

  bootloader

  - 编译运行
  - 调试
  - pc启动过程
  - elf文件加载
  - 外设访问

  ucore os

  - 编译
  - 启动
  - 调试
  - 函数调用
  - 中断管理
  - 外设管理

练习

6个基本练习1个扩展联系

练习1 理解make生成执行文件的过程

如何知道主引导扇区是否复合规范

## 4.6 练习2

使用qemu执行并调试lab1的软件

- 单步跟踪

  

## 4.7 练习3



分析bootloader进入保护模式的过程

开启A20，开启A20

初始化GDT表

如何使能和进入保护模式

## 4.8练习4 5

分析bootloader加载elf文件

分析函数调用栈

## 4.9 练习6

完善中断初始化与处理

中断向量表

扩展练习 实习不同特权级别的切换

# 第五章 物理内存管理：连续内存

## 5.1 计算机体系结构和内存层次

计算机体系结构

- 总线
- cpu
- io
- 内存

cpu

- alu
- 寄存器
- 高速缓存
- 存储管理单元mmu

内存

- 最小访问单位8bit 字节
- 32位总线 4字节 对齐

内存层次

- cpu
- L1缓存
- L2缓存
- 内存
- 外存（虚拟内存）

内存管理

内存 外村

内核

- 进程
- 共同地址空间
- 程序地址不重叠
- mmu存储管理：逻辑地址到物理地址

抽象

逻辑地址空间

保护

独立地址空间

共享

访问相同内存

虚拟化

更大的地址空间

**操作系统内存管理方式**

- 重定位 段加偏移
- 分段
- 分页
- 虚拟内存

高度依赖硬件

- mmu cpu识别页表

## 5.2 地址空间和地址生成

地址生成

地址空间定义

物理地址空间——硬件支持的地址空间

- 起始地址0，知道MAX 

逻辑地址空间——CPU运行的进程看到的地址

起始0，最大MAX

地址（address）哪里来？

逻辑到物理

总线访问

逻辑地址的生成

程序

编译

汇编 名字到地址

链接

加载

地址生成时机与限制

- 编译
  - 假设地址已知
  - 如果起始地址改变，重新编译
- 加载
  - 编译时起始位置未知，编译器生成可重定位的代码
  - 加载时，生成绝对地址
- 执行时
  - 执行时代码可移动
  - 需要地址转换硬件支持

执行时最灵活

地址生成过程

cpu

- alu 需要逻辑地址的内存内容
- mmu 进行逻辑地hi和物理地址的转换
- cpu控制逻辑

内存

- 发送物理地址给cpu
- 接受cpu数据到物理地址

os

- 建立逻辑地址与物理地址映射

地址检查

指令

逻辑地址

段基地址和长度 

超过长度非法，内存异常

段长度与段基地址寄存器

物理地址

访问内存

操作系统控制

## 5.3 连续内存分配

连续内存分配

内存碎片

动态分配

- 最先匹配
- 最佳匹配
- 最差匹配

碎片整理

计算机体系结构内存层次

进程分配一块指定大小的连续物理内存



内存碎片

- 空闲内存无法利用

外部碎片

- 分配单元之间未被利用的内存

内部碎片

- 分配单元内部未被使用的内存
- 取决于分配大小是否取整

动态分区分配

- 当程序被加载执行时候，分配一个进程指定大小可变的分区（块）
- 分区地址是连续的

操作系统需要维护的数据结构

- 当所有进程已被分配分区
- 空闲分区

动态分区分配策略

- 最佳匹配 大小
- 最先匹配 地址
- 最差匹配 小大

最先匹配策略

思路：

- 分配n个字节，使用第一个比n大的空闲快

原理与是西安

- 空闲分区地址排序
- 分配时候搜索第一个合适的分区
- 释放分区时候，检查是否可于临近分区合并

优先

- 简单
- 高地址有大块空闲分区

缺点

- 外部碎片
- 分配大块时候较慢

最佳匹配

思路

- 分配n字节分区，查找并使用不小于n的最小空闲分区

实例

- 分配400字节，使用第三给空闲块

原理于实践

- 空闲分区按照大小排序
- 分配，查找一个合适的分区
- 释放时候，查找合并临近的空闲分区

有点

- 大部分分配尺寸较小，效果好
  - 避免大的空闲分区被拆分
  - 可减小外部碎片带线啊哦
  - 简单

缺点

- 外部碎片
- 释放分区慢
- 产生无用的小碎片

最差匹配

分配n字节使用不小于n的最大分区

原理与实践

- 空闲分区大小排序
- 分配选择最大的
- 释放时候与邻近分区合并，进行河滨，调整空闲分区列表

优先

- 中等大小分配表现好
- 避免太多小碎片

缺点

- 释放分区慢
- 外部碎片
- 破坏大分区，难以分配大分区

## 5.4 碎片整理

- 紧凑 
- 分区对换

碎片整理

- 通过调整进程占用的分区位置来减少或避免分区碎片

碎片紧凑

- 通过易懂分配给进程的内存分区，以何冰外部碎片
- 碎片紧凑的条件
  - 所有应用程序可以动态重定位
- 需要解决的问题
  - 什么时候移动
  - 开销

分区兑换

抢占并回收处于等待状态的分区，以增大可用内存空间

进程 就绪 运行 等待 

对换 来实现多进程交替运行

暂停进程放入外存

问题：

交换哪个程序

## 5.5伙伴系统

伙伴系统的实现

折中分配与回收

整个可分配分区大小 2 ^u

需要的分区大小 2u-1<s<2u，整个块分配给进程

s<2i-1，将大小2i的当前空闲分区划分两个空闲分区

重复划分这一过程，一个空闲分区分配一个进程



实现

数据结构

- 空闲快带线啊哦和起始地址组织位二维数组
- 初始状态：只有一个大小位2^u的空闲快

分配过程

- 小到大在空闲分区找最小
- 如果空闲块过大，对其二等分，知道得到合适的可用空闲块

1Mb 块 需要100k 切了又切 切一个128k

240k 256k分配

64k 分配128 切分 分64k

分分合合

释放过程

- 释放块放入空闲十足
- 合并满足合并条件的空闲块

合并条件

- 大小相同
- 地址相邻
- 低地址空闲快起始位2的幂


 
# 第六章 物理内存管理: 非连续内存分配

## 6.1 非连续内存分配的需求背景

分配内存可以不连续吗

非连续分配大小

块与段

大与小

页表

段页式

需求

过去的不够好

连续分配的缺点

- 分配给程序的物理内存必须连续
- 存在外碎片与内碎片
- 内存分配的动态修改困难
- 内存效率低

非连续内存分配目标：提高内存利用率和管理灵活性

- 允许一个程序的使用使用非连续的物理地址空间
- 允许共享代码与数据来减少内存使用
- 允许动态加载于动态链接，动态变化，更加灵活

实现

要解决的问题

- 虚拟地址到物理地址的转换 连续只需要知道头在哪 不连续可能一个程序放在不同地方，难度变大
  - 硬件实现 够用，开销小 
  - 软件实现 灵活，开销大 使用类似外排序来实现
- 非连续分配硬件辅助机制
  - 如何选择飞来内需分配中的内存分配
    - 段式存储 段内连续，段间不连续
    - 页式存储 页页不连续

## 6.2 段式内存分配

段地址空间

段访问机制

段地址空间

- 进程的段地址空间由多个段构成

  - 主代码段
  - 子模块代码段
  - 公共库代码段
  - 对战段
  - 堆数据
  - 初始化数据段
  - 符号表

  段式存储目的

  - 精细灵活以分离共享



段式内存空间的不连续二维结构

代码

数据

堆

栈

不同部分内部连续 外部不连续

段的概念

- 段表示访问方式和存储数据等属性相同的一段地址空间
- 对应一个连续的内存块
- 若干个段组成进程逻辑地址空间

段访问

- s 段号
- addr 段内偏移

段基地址与段内偏移

程序

逻辑地址

短号与段内偏移

查阅段表 软件实现

硬件mmu 查阅越界没有 是否合法

访问物理地址

## 6.3页式存储管理

概念

地址转换

页帧 桢 

- 把物理地址空间划分为大小相同的基本分配单位
- 2的n次方 512 4096 目前通常 4096

页面 

- 把逻辑地址空间划分为相同大小的基本分配单位
- 帧和页大小必须相同

页面到页帧

- 逻辑地址到物理地址
- 页表
- mmu / tlb

页帧

- 物理内存基本快的名称
- 帧号与桢内偏移

内存地址表示二元组(f,o)

物理地址

F+S

f-帧号 f位

o 桢内偏移 s位



假定

16 bit 地址空间

9 bit 带线啊哦的页帧

物理地址计算

3，6

逻辑地址空间划分为大小相等的页

业内偏移 = 桢内偏移

页号 ！= 桢号



进程逻辑地址表示 p o

页号 P位

业内偏移 S位

虚拟地址 p *2^s+o

页式存储地址转换

- 页到桢映射
- 逻辑地址页号连续
- 物理地址帧号不连续
- 不是所有的页都对应桢

页表

页表保存一个映射

页表基地址 页号

## 6.4 页表

页表概述

每个进程一个页表

- 每个页面对应一个页表想
- 随进程运行而动态变化
- 页表基地址寄存器

页表项组成

帧号：f

页表项标志

- 存在位
- 修改位
- 引用位

实例

16位地址

物理内存 32kb

页 1024

页式存储的性能问题

性能问题

- 访问一个内存单元需要2次访存
- 第一次访问：获取页表项
- 第二次访问：访问数据

页表大小问题

- 页表可能很大
- 64位机器每页1024字节，页表项2^54个页面 光地址8个字节*2 54次方，这太奢侈了

处理方法

- 缓存 块表
- 间接访问 多级页表

## 6.5 块表 多级页表

块表 tle

缓存到cpu

缓存近期访问页表

- tle使用关联存储，具有快速访问的性能
- tle命中，物理也好可以快速被获取
- tle不命中，对应页表更新到tle

多级页表

间接引用

页号分为若干级别

p1 p2 p3 0

一级页表 二级页表 三级页表 树状结构

建立树

减少每级页表长度

cr3 ptbr

一级页表 二级页表

多级页表减少长度

## 6.6 反置页表

大地址空间问题

大地址空间系统，多级页表繁琐

- 比如：5级页表
- 逻辑地址空间增长速度快于物理地址空间

页寄存器和反置页面的思路

- 不让页表与逻辑地址空间大小相对应
- 让页表与物理地址空间大小相呼应

页寄存器

美一个帧与一个页寄存器关联，寄存器内容包含

- 使用位：帧是否被占用
- 占用页号：对应页号p
- 保护位

也寄存器实例

物理内存 4096+4096=16MB

页面大小 4kb

页帧数 4k

页寄存器使用空间 8*4096 =32kb

页寄存器额外开销 0.2

虚拟内存大小 任意

优点

- 页表大小相对于物理内存很小
- 页表大小与逻辑地址空间大小无关

缺点

- 页表信息对调后，需要根据帧号找到页号
- 页寄存器搜索逻辑地址找到页号

页寄存器的地址转换

cpu逻辑地址

逻辑地址需要进行hash映射，减少搜索范围

解决冲突问题



块表缓存页表项后页寄存器搜索步骤

- 堆逻辑地址hash变换
- 块表查找对应页表项
- 有冲突遍历冲突项链表
- 查找失败，产生异常

块表的限制

- 快表功耗限制
- 快表功耗限制

反置页表

基于hash映射查找对应页表帧号

- 进程表示与页号的hash值可能冲突
- 页表项包括保护位、修改位、访问位和存在位冲突

## 6.7 段页式存储管理

需求

段式页式各有优势，

段 内存保护

页 内存利用和优化转移到后被存储有优势

结合起来

段页式存储 段式存储加页表

段号 页号 页内偏移

页号 业内偏移



段表项 页表项

内存共享方便

- 通过指向相同页表基地址，实现进程段共享

# **第七章 实验二 物理内存管理**

## 7.1 x86保护模式的特权级

特权级

内存管理单元

X86特权级

内核态 用户态

切换 多态

x86特权及 0 1 2 3 4个

内核 0 级别

应用程序 3级别

实验只需要 0 3

x86特权级别 区别

一些指令只能执行在ring 0 

cpu在如下时刻会检查特权级

- 访问数据段
- 访问页
- 进入中断服务例程

检查失败会如何？

X86特权级 段选择子

特权级 段选择子

RPL 数据段

段描述符号

门描述符

中断门 陷入门

DPL

中断/trap访问

内存段访问

当前特权级别

RPL CPL DPL

RPL 数据

CPL 指令

段/门描述符

访问门 CPL <= DPL CPL>= DPL

访问段时候 MAX(CPL,RPL)<=DPL

## 7.2 了解特权级切换过程

不同特权级别跳转

基于中断来实现

ESP 异常 

软中断

压入数据以便于恢复

SS ESP  EFLAGS CS  EIP  Error Code

切换特权级 0 to 3

3-0

压栈保存现场

x86特权级 tss格式

tss描述符 保存地址 可以找到内核态的数据

## 7.3 了解段/页表

MMU

段机制概述

寄存器

段描述符

cs es ss ds fs gs

基地址与限制

段选择子中隐藏部分

GDT内存里面

段表，访问速度太慢

硬件完成，

可见 16bit

不可见 基地址与段大小 放在cpu里面

建立GDT tables

- init GDT table as an array
- init GDT decriptor
- invoke lgbt
- set bot 0 in cro
- update cs using ljmp

页机制映射

## 7.4建立段页表

mmu 页机制

offset 12 二级 10 一级10

PDE PTE 物理地址

二级页表

线性地址 =虚拟地址

页目录表 页表 页帧

页表项目存放地址是线性地址

cr3指示页目录的地址

页表项

属性

- r/w
- u/s
- a

使能页机制

cr0指示页目录

建立页表

allocate a page as d directory table

clear the page allocated



页面中建立页的映射关系

x86 

段机制

页机制

## 7.5 lab2

实验目的

- 理解基于段页式内存地址的转换机制
- 理解页表的建立与使用方法
- 理解物理内存的管理方法

练习

3基本 2扩展

0 填写已有的实验

1 实现fist fit物理内存分配算法

2 实现寻找虚拟地址对应的页表项

3 释放虚拟地址所在页并取消对应二级页表的映射

扩展 伙伴系统分配算法

扩展 任意大小内存单元slub分配算法

# 第八章 虚拟内存概念

## 8.1 虚拟存储的需求背景

虚拟内存需求

内存 外存

覆盖

交换

局部性

虚拟存储

缺页异常

需求

存储需求的要求更高

电脑游戏

400K大小 软盘

警察抓小偷

更好的画面

足球游戏

交互性 3d动画

程序规模的增长远远大于存储的发展

存储层次结构

理想的存储器

- 容量
- 速度
- 价格
- 非易失性存储

实际

- 寄存器
- 高速缓存
- 内存
- 磁盘
- 磁带

操作系统对存储的抽象：地址空间

p1 p2 p3 内核

操作系统来抽象 不依赖硬件的程序

内存不够用？怎么办

多进程 多线程的问题

咋办？

- 覆盖
  - 手动把需要的指令和数据保存在内存
- 兑换
  - 操作系统自动把不能执行的程序保存到外存
- 虚拟存储
  - 有限内存内，页位单位自动装入更大的程序

## 8.2 覆盖与交换

覆盖与交换

覆盖

目标：

较小的可用内存运行大程序

方法

根据逻辑结构，程序划分为功能独立模块，将不会同时执行的模块共享同一块内存区域

- 必要部分（常用功能）的代码和数据常驻内存
- 可选部分（不常用功能）放在其他程序模块中，需要时候再装入内存

例子

190k的程序

物理内存不够190k

咋办？

划分 根据独立划分a b c d f

a 

b c

d e f

a   max(b c) max(d e f)

110k 能用了

覆盖牛逼啊

换一个分区方式 用的内存更小了

dos turbo pascal overlay支持覆盖技术

太难了

覆盖技术不足

- 编程困难
  - 程序员决定划分模块
  - 编程困难
- 增加执行时间
  - 时间换空间
  - 外存装入覆盖 耗费时间



交换技术

目标

增加正在运行或需要运行的程序的内存

只讨论多个程序导致不够用的问题

方法

- 将不能运行的程序放到外存
- 换入换出基本单位是整个进程
- 换入 进程地址空间到外存
- 换出 反之

问题

交换时机：啥时候整？

- 内存不够时候换出

交换区大小

- 存放所有进程的内存映像的拷贝

换入重定位：换出换入能否放原处

- 动他地址转换

覆盖

- 只发生没有调用的模块
- 程序员给出模块划分
- 发生再程序内部模块

交换

- 进程为单位
- 操作系统做
- 发生内存进程间
- 不需要模块间逻辑覆盖结构

## 8.3 局部性原理

虚拟存储技术的目的

物理内存+磁盘 = 虚拟存储



只把部分程序放到内存中，从而运行比物理内存大的程序

- 操作系统自动完成，无需程序员的干涉

实现进程在内存外村之间的交换，从而获得更多的空闲与空间

- 在内存和外存之间只交换进程的部分内容



局部性原理

程序在执行过程中，一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域

- 时间局部性

  - 一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内

- 空间局部性

  - 当前指令和临近的几条指令，当前访问的数据和临近的几个数据都集中在较小的区域内

- 分支局部性

  - 一条跳转指令的两次执行，很可能跳到相同的内存位置

-  局部性意义

  - 理论上虚拟存储可行的

  不同程序局部性例子

页面 4k

分配进程页面1

定义一个数组A[][1024]$[1024][1024]$

一行一个页面，数字内存存放

```c++
for(int i=0;i<1024;i++)
	for(int j=0;j<1024;j++)
		a[i][j];
```

```c++
for(int i=0;j<1024;i++)
	for(int j=0;i<1024;j++)
		a[i][j];
```

程序2次次缺页

程序1一行缺页一次

## 8.4虚拟存储概念

思路

- 不常用部分内存放到外存

原理

- 装载程序时候
  - 只将当前指令执行需要部分页面或段存入内存
- 指令执行需要的指令或数据不存在称为缺页
  - 处理器通知操作系统将相应页面或段调入内存
- 操作系统将内存暂时不用的页面或段保存到外存

如何确定谁不用？置换算法

实现方式

- 虚拟段式存储
- 虚拟页式存储

基本特征

- 不连续
- 虚拟地址空间不连续

大用户空间

- 提供广用户虚拟地址空间进行调入调出

硬件

- 地址转换 段页都有

操作系统

- 管理内存和外村段页的换入换出

## 8.5虚拟页式存储

页式存储管理的基础上，增加请求调页和页面置换算法

思路

- 程序加载内存，只加载部分页面，就启动程序进行
- 进程在运行中发现有需要的代码或数据不再内存时候，则向操作系统发出缺页异常请求
- 操作系统处理缺页异常时，将外存相应页面调入以使得进程能够继续运行

页表结构

加标志位

- 驻留位 是否在内存中
  - 1 在内存 可用访问
  - 0  外村，缺页
- 修改位：内存中是否修改过
  - 回收物理页面时候，判断是否其内容写回内存
- 访问位：页面是否被访问（读写）
  - 页面置换算法
- 保护位：运行读写吗
  - 只读，可读写，可执行

虚拟页式实例

16 逻辑地址 64k

物理内存 32K

页面 4K

x86页表结构

10 10 12 地址

物理地址

20 12 地址

20页帧号 驻留 可写 内核访问 修改 保留位

##  8.6 缺页异常

缺页异常处理流程

load M 有效 访问

无效 缺页

查找外存位置

换出

换入

更改页表



缺页异常 找空闲物理页面

没找到 页面置换算法他替换

q修改过写外存

修改q页表项内存

访问的p装入物理页面

修改p页表驻留位

重新执行产生缺页的指令

**外存管理**

如何保存未被映射的页？

- 方便在外村找
- 交换空间（磁盘或者文件）
  - 特殊格式存储未被映射的页面
- 虚拟页式存储的外存选择
  - 代码段：可执行二进制文件
  - 动态加载的共享库程序段：动态调用的库文件
  - 其他段：交换空间

性能

有效存储访问时间

EAT=访存时间（1-p)+缺页异常处理时间*p

例子

访问存 10ns

磁盘5ms

缺页p

页面修改q

EAT = 10(1-p)+5e6p(1+q)

# 第九章 页面置换算法

## 9.1 页面置换算法

概念

局部

全局

置换算法功能于目标

功能

- 出现缺页异常，调入新页面而内存满了置换算法选择被置换的物理页面

设计目标

- 尽可能减少页面的调入调出次数
- 未来不再访问或短期不访问的页面调出

对未来做预测

页面锁定

- 描述必须常驻内存的逻辑页面
- 描述操作系统的关键代码
- 要求响应速度的代码和数据
- 页表中的锁定标志位

置换算法评价方法

- 记录访问内存的轨迹
  - 举例 虚拟地址访问用页号位移表示

评价方法

- 模拟置换行为，记录缺页次数
- 缺页少就是好的

局部置换算法

- 分配给一个进程的物理页面数确定，限于当前进程占用的物理页面
- 最优算法，先进先出算法，最近最久未使用算法
- 时钟 最不常用

全局置换算法

- 所有可能换出的物理页面
- 工作集算法与缺页率算法

## 9.2 最优算法、先进先出算法和最近最久未使用算法



最优页面置换算法opy

基本思路

- 置换未来最长时间不访问的页面

算法实现

- 缺页时候，计算内存中每个逻辑页面的下一次访问时间
- 选择未来最长时间不访问的页面

特征

- 缺页最少，理想情况
- 无法实现
- 下一次我哪知道
- 作为评测依据
  - 模拟器运行程序，记录访问情况
  - 第二次运行用最优算法

先进先出算法

思路

- 选择内存驻留时间最长的页面进行置换

实现

- 维护一个记录所有位于内存中的逻辑页面链表
- 链表元素按驻留内粗你的时间排序，链首最长，链尾部最短
- 出现缺页，选择链条首进行置换，新页面加到链尾

特征

- 实现简答
- 性能较差，调出的可能是最常访问的
- 进程物理页面增加，缺页次数不一定减少
- 很少单独使用

FIFO 简单

这种 

LRU

最近最早

思路

- 最长时间没有被引用的页面进行置换
- 页面长时间未被访问，将来也这样

实现

- 缺页，计算内存

最近最久没用算法 LRU

思路

- 最长时间没用的页
- 以后的事情我不知道，我用过去的预测未来
- 以前没用的页面，未来应该也不会访问

实现

- 缺页时候，计算每个页面上一次访问时间
- 找上一次使用到当前时间的最长页面

页面链表

- 维护一个按最近一次访问时间排序的页面链表
  - 链表首节点是最近刚使用过的页面
  - 链表尾节点是最久未被使用的页面
- 访问内存，找到相应页面，将其移动到链表首部
- 缺页时候，置换链表节点的页面

活动页面栈

- 访问时候，页号压入栈顶，站内相同页号抽出来

- 缺页时候，置换栈底部页面

问题

开销大

## 9.3 时钟置换算法和最不常用算法

时钟 FIFO 的折中

最不常用算法



clock算法

思路

- 仅对页面访问情况进行大致统计

数据结构

- 页表加访问位，描述是否被访问过
- 页面组织环形链表
- 指针指向最先调入的页面

算法

- 访问页面，页表项记录页面访问情况
- 缺页时候，指针处开始顺序查找未被访问的页面置换

特征

- 时钟是LRU和FIFO这种

实现

- 页面装入内存，访问位初始化为0

- 访问页面时候访问位置1
- 缺页时候，指针当前位置顺序检查环形链表
  - 访问位0 置换
  - 访问位1 将其置0 指针移动到下一个页面，知道找到可以置换的页面

改进的clock算法

思路

- 减少修改页的缺页处理开销

算法

- 页表加修改位，访问时候进行修改
- 缺页时候，修改页面标志位，跳过有修改的页面
- 0 0 置换
- 01  00
- 10 00
- 1 1  01

最不常用算法

思路

- 缺页时候置换访问次数最少的页面

实现

- 每个页面设置一个访问计数
- 访问页面时，访问计数+1
- 缺页时，置换计数最小的页面

LRU LFU区别

LRU 多久没访问

LFU 访问次数

## 9.4 belady现象与局部置换算法

belady现象

缺页率会不会随着页面多而增长

FIFO算法，分配页面增加，缺页次数反而升高

原因

- FIFO算法置换特征与进程访问内存动态特征矛盾

那些有belady

LRU没有belady现象

区别

LRU和FIFO本质都是先进先出

- L'RU依据页面最近访问时间顺序
- LRU动态调整顺序
- FIFO根据进内存时间
- FIFO页面进入时间是固定不变的

LRU退化未FIFO

- 如果页面进入内存没有被访问，最近访问时间与进入内存使时间相同

LRU性能好 开销大

FIFO开销小，belady

Clock 折衷

- 访问做标记，不调整顺序
- 缺页再把它移动到链表尾

未被访问 Clock lru一样好

被访问 clock不记录详细信息，lru详细

9.5 工作集置换算法

全局置换算法

局部置换算法没有考虑进程访存差异

全局置换算法解决的问题

- 进程在不同阶段内存需求变化的
- 分配给进程的内存不同阶段也会变化
- 全局置换算法需要确定分配给进程的物理页面数 

cpu利用率与并发进程数

- 进程数少，提高并发进程数提高cpu利用率
- 并发进程导致内存访问增加
- 并发进程的内存访问降低访存局部性特征
- 局部性特征下降会导致缺页率上升和cpu利用率下降

工作集

一个进程当前使用的逻辑页面集合，表示二元函数W(t,Δ)

- t是当前执行时刻
- Δ是工作集窗口，即一个定长的页面访问时间窗口
- W(t,Δ)是当前t前的时间窗口内所有访问页面集合

工作集变化

开始执行，随着访问新界面逐步建立较为稳定的工作集

内存局部性区域大致稳定后工作集大致稳定

局部性区域位置改变时，工作集快速增长到下一个稳定值

常驻集

在当前时刻，进程实际驻留在内存的页面集合

- 工作集和常驻集的关系
  - 工作集是进程在运行过程固有属性
  - 常驻集取决于系统分配给进程的物理页面数目和页面置换算法

缺页率与常驻集关系

- 常驻集大于工作集合 缺页少
- 工作集剧烈抖动，缺页过多
- 进程常驻集带线啊哦达到一定规模，缺页率下降不明显

工作集置换算法

- 换出不再工作集的页面

窗口大小 ε

- 当前时刻ε个内存访问的页引用是工作集，是敞口大小

实现方法

- 访存链表：维护窗口的访存页链表
- 访存时，换出不在工作集的页面，更新访存链表
- 缺页时候，换入页面，更新访存链表

## 9.6缺页绿置换算法

缺页次数/内存访问次数 或者 缺页平均时间间隔的倒数



影响缺页率

- 置换算法
- 页面大小
- 分配进程页个数
- 程序代码

算法

- 调整常驻集大小，进程缺页率合理范围

缺页率过高 增加常驻集以分配更多页面

缺页率过低，减少常驻集，减少页面



访存，设计引用标志

缺页时候，计算上次缺页时间t到现在的间隔

如果间隔很长，置换没有引用的页面，

如果间隔小，增加缺失页到工作集中

## 9.7抖动与负载控制

抖动

- 进程物理页面太少，不能包括工作集
- 大量缺页，频繁置换
- 进程运行速度变慢

抖动原因

- 随着驻留内存数目太多，分配给每个进程页面少，缺页率上升

操作系统需要并发与缺页率平衡



负载控制

- 通过调节并发进程数
- 平均缺页间隔时间=缺页异常处理时间

## 第十章 实验三 虚拟内存管理

目标

历史

当下

处理流程，关键数据结构和功能

页访问异常

页换入换出机制

借助页表机制和中断异常处理机制

虚拟内存 提供一个比实际大的空间，更大的虚拟内存空间

虚拟内存 

练习1 未映射的地址 映射到物理页

练习2 FIFO页面替换算法



## 10.2 回顾过去与现在

lab1

- 保护模式和段机制
- 中断机制
- 输出字符串

lab2

查找内存物理空间

建立连续内存分配

页机制的建立

lab3

页访问错误异常中断服务例程

swap分区读写

页替换算法

页表处理

虚拟内存总体框架

1. 初始化内存管理机制 硬盘读写 缺页异常
2. 设置虚拟页空间和物理页帧空间
3. 完善页映射，缺页异常
4. 4 执行测试，查看时候虚拟内存
5. 是都描述了是否硬盘
6. 是否内存之间读写
7. 页替换算法正确否

## 10.3 处理流程、关键数据结构和功能

swap init

vmm init

## 10.4 页访问异常

异常

中断

## 10.5 页换入换出机制

扈三娘哪个

虚拟也与磁盘关系

换入换出

页替换算法

如何换入换出

换出哪个页

映射关系 PTE

h换入换出机制

FIFO

换出换出

主动

被动

# 第十一章 进程和线程

## 11.1进程的概念

进程 具有独立功能的程序在一个数据集合上一次动态执行过程

源代码 可执行文件 进程地址空间

进程的组成，程序执行所有状态

- 代码
- 数据
- 状态寄存器
- 通用寄存器
- 占用系统资源

进程的特点

- 动态性
  - 动态创建与接受
- 并发性
  - 进程可用被独立调度并占用处理机运行
- 独立性
  - 不同进程工作不相互影响
- 制约性
  - 因访问共享数据/资源或进程同步而产生制约

进程执行过程

进程切换

四个指令指针

进程交替进行，宏观上并发进行



进程与程序的联系

- 进程是操作系统处于执行状态程序的抽象
  - 程序=文件（静态的可执行文件）
  - 进程=执行中的程序=程序+执行状态
- 同一个程序的多次执行过程对应不同进程
  - 如ls多次执行
- 进程执行需要资源
  - 内存：保存代码和数据
  - cpu:执行指令

进程是动态的，程序是静态的

- 程序是有序代码的集合
- 进程是程序的执行，进程有核心态/用户态

进程是暂时的，程序是永久的

- 进程是一个状态变化的过程
- 程序可永久保存



## 第二节 进程控制块

进程控制块PCB

操作系统管理控制进程运行所用的信息集合

- 操作系统用PCB来描述进程的基本情况以及运行变化的过程
- PCB是进程存在的唯一标识
  - 每个进程都在操作系统有一个对应的pcb

进程创建

- 生成该进程的pcb

进程终止

- 回收它的pcb

进程的组织管理

- 通过对pcb的组织管理来实现

pcb有数目？如何组织？

进程的状态转换



进程控制块

- 进程标识信息
- 处理机现场保存
- 进程控制信息

PC 指令指针

SP栈顶

PID标识信息

UID

调度优先级

打开的文件列表

使用的寄存器



调度和状态信息

- 进程和处理机使用状况调度

进程间通信信息

- 进程间通信相关的各种标识

存储管理信息

- 指向进程映像存储空间数据结构

进程所用资源

- 进程使用的系统资源，如打开文件等

有关数据结构连接的信息

- 与PCB相关的进程队列

进程控制块的组织

链表

同一状态的进程其pcb组织一个链表，多个状态对应多个不同的链表

- 各个状态的进程行程不同的链表，就绪链表，阻塞链表



索引表

同一状态的进程归入一个索引表（由索引指向PCB)，多个状态对应不同索引表

第三节 进程状态

进程状态

进程的生命周期

- 进程创建
- 进程执行
- 进程等待
- 进程抢占
- 进程唤醒
- 进程结束

进程创建

创建 就绪 运行

引起创建的情况

- 系统初始化
- 用户请求创建新进程
- 正在运行的进程执行创建进程的系统调用

进程执行

- 内核选择一个就绪的进程，让它占用处理机并执行

如何选择？

进程进入等待阻塞的情况：

- 请求并等待系统服务，无法马上完成
- 启动某种操作，无法马上完成
- 需要的数据没有到

只有进程自身才能知道何时需要等待某种事件的发生

进程抢占

进程被抢占的情况

- 搞优先级进程就绪
- 进程执行当前事件用完

进程唤醒

- 需要的资源满足了
- 等待的事件到达了

进程智能被别的进程或操作系统唤醒

进程结束

进程结束的情况

- 正常退出 自愿的
- 错误退出 资源的
- 致命错误 强制性的
- 被其他进程所杀 强制的



sleep系统调用

创建 就绪 运行 等待 就绪 运行 退出

进程切换

进程1 进程2 

sleep()   add_timer()  schedule 

保存现场 恢复现场

## 11.4 三状态进程模型

进程主要三种状态

就绪 运行 等待

运行状态

进程正在处理机上运行

就绪状态

进程获得除去处理机以外的资源

等待状态

进程正在等待某一事件而出现暂停的状态

创建状态

进程正在被创建，还没到就绪状态之前的状态

结束状态

进程正在从系统中消失



null-创建

新的进程被产生来执行一个程序

创建-就绪

进程被创建完成并初始化，一切就绪准备运行时，变为就绪态

就绪到运行

处于就绪状态的进程被进程调度程序选中后，就分配带处理机上来运行

运行到就绪

处于运行状态的进程在其运行过程中，由于分配给它的处理机时间片用完而让出处理机

运行到等待

进程请求某资源且必须等待

等待到就绪

进程要等待的事件到来，从卒社变到就绪状态

11.5 挂起进程模型

进程挂起

处在挂起状态的进程映像在磁盘上，目的是减少进程占用内存

挂起

- 就绪挂起
- 等待挂起

等待挂起状态

进程在外存并等待某事件的出现

就绪挂起状态

进程在外存，但是进入内存就可以进行了

挂起：把进程从内存到外存

- 等待到等待挂起
  - 没有进程处于就绪状态或酒席进程要求更多内存资源
- 就绪到就绪挂起
  - 高优先级等待进程和和低优先级就绪进程
- 运行到就绪挂起
  - 抢占分时系统，当有高优先级等待挂起进程因事件出现而进入就绪状态

外存状态转换

- 等待挂起到就绪挂起
  - 当有等待挂起进程因相关事件出现

激活：把进程外存到内存

- 就绪挂起到就绪
- 等待挂起到等待
- 当一个进程释放足够内存，激活高优先级等待挂起进程

状态队列

由操作系统来维护一个队列，表示系统所有进程的状态

不同队列表示不同状态

根据进程状态的不同，进程pcb进入相应队列



## 11.6 线程概念

为什么引入线程

mp3播放软件

1. 音频读数据
2. 解压数据
3. 声卡播放

单进程

    while(true){
        read();
        decompress();
        play();
    }

read io

decompress cpu

问题

1. 播放出来声音连贯
2. 各个函数之间不是并发进行，影响资源使用效率

多进程实现

一个进程读

一个进程解压

一个进程播放

问题

1. 进程如何通信，共享数据
2. 系统开销大，创建进程，进程结束，进程切换

多进程解决的思路

进程增加实体

1. 实体可以并发进行
2. 实体之间共享地址空间

线程

线程是进程的一部分，描述指令执行状态，它是进程中的指令执行流的最小单元，cpu调度的基本单位

进程的资源分配角色：

进程由一组相关资源构成，包括地址空间，打开的文件资源

线程处理机调度角色，线程描述在进程资源环境中的指令执行状态

进程与线程关系

代码 数据 打开文件 进程

寄存器 堆栈 线程



线程 = 进程 - 资源共享

线程的优点：

- 一个进程多个进程
- 各个线程之间可以并发执行
- 各个进程可以共享资源

缺点

- 一个崩溃，所有都崩溃

不同操作系统对线程的支持

单进程系统 ms-dos

传统unix 多进程系统

多线程系统 现代unix

单进程多线程 psos 路由器



线程与进程比较

- 进程资源分配，线程cpu调度
- 进程完整资源平台，线程独享指令流必要的资源，寄存器与栈
- 线程具有就绪，等待，运行三种基本状态
- 线程能减少并发执行的时间和空间开销
  - 线程的创建时间比进程短
  - 线程的终止时间比进程短
  - 同一进程内的线程切换时间比进程短
  - 由于同一进程的各线程共享内存与文件，可不通过内核进行通信



## 11.7 用户线程

用户线程：在用户空间实现

posix pthreads mach c-threads solaris threads

内核线程：内核实现

windows solaris linux

轻量级进程：内核中实现，支持用户线程

用户线程

用户及函数库完成线程管理，包括线程创建，终止，同步，调度

内核pcb

用户空间 tcb 函数支持

用户线程的特征

- 不依赖内核
  - 内核不知道线程存在
  - 用于不支持线程的多进程操作系统
- 用户空间实现线程机制
  - 每个进程私有线程库列表
  - tcb由线程库维护
- 同一进程内用户线程切换速度块
  - 无需用户核心切换
- 运行每个进程拥有自己的调度算法

不足

- 一个阻塞，整个进程阻塞
- 不支持基于线程的处理机抢占
  - 除非当前线程主动放弃，所在进程其他线程无法抢占cpu
- 只能按进程分配cpu时间
  - 多线程进程中，每个线程时间片少

## 11.8内核线程

内核线程

进程由内核用过系统调用来实现的线程机制，由内核完成线程的创建，终止和管理

内核线程的特征

- 内核维护pcb和tcb
- 线程执行系统调用而不阻塞其他线程
- 线程创建，终止和切换开销更大
  - 通过在内核实现，需要系统调度
- 以线程为单位进程cpu时间分配
  - 多线程的进程可以获得更多cpu时间

轻权进程

内核支持的用户线程，进程可以有一个或多个轻量级线程，每个轻权进程由一个单独的内核线程来支持

未绑定的进程

绑定的进程

用户线程与内核线程

一对一

多对一

多对多

# 第12章 进程控制

## 12.1进程切换

父子进程

进程切换（上下文切换）

- 暂停当前运行进程，运行状态到其他状态
- 调度另一个进程从就绪状态到运行状态

进程切换的要求

- 切换前，保存进程上下文
- 切换后，恢复进程上下文
- 快速切换

进程生命周期信息

- 寄存器pc sp
- cpu状态
- 内存地址空间

上下文切换

保护线程

pcb保存进去

进程控制块 pcb 内核进程状态记录

内核为每个进程维护了对应的进程控制块

内核讲相同状态的进程的pcb放置在同一队列

就绪队列

io等待队列 每个设备一个

io等待队列

ucore进程控制块 

    cr3 flags
    mm
    stcak
    tf
    context
    

ucore进程队列

链表

哈希

进程切换

- 开始调度
- 清楚调度标志
- 查找就绪进程
- 修改进程状态
- 切换进程
2 进程创建

创建新进程

windows API creatprocess

- 创建时候关闭所在子进程文件描述符号
- 创建时候改变子进程环境

unix进程创建系统调到

fork exec

fork 把一个进程复制给两个进程

 old PID new PID

exec 用新程序改写进程

pid不变

fork创建一个继承的子进程

- 复制父进程的所有变量和内存
- 复制父进程的所有cpu寄存器(1个寄存器例外)

fork返回值

- 子进程fork返回9
- 父进程fork返回子进程PID
- fork返回值可方便后续使用，子进程可使用getpid获得PID

fork地址空间复制

fork()执行过程对于子进程而言，是调用时间对父进程地址空间的一次复制

- 父进程fork,返回childPID,子进程返回0



shell调用fork

fork使用实例

空闲进程的创建

空闲进程的创建

idleproc

分配资源

初始化进程控制块

完成初始化

创建一个内核线程

initproc 

初始化trapframe

初始化内核堆栈

内存共享





fork开销

- 子进程分配内存
- 复制父进程的内存和cpu寄存器到子进程
- 开销昂贵

99情况下，调用fork调用exec

- fork内存复制没用
- 子进程可能关闭打开的文件和连接
- 为什么不结合他们在一块

vfork

- 创建进程时候，不再创建一个同样的内存映像
- 一些被称为轻量级fork
- 子进程用过立刻调用exec
- 现在使用写时复制技术

## 12.3进程加载

程序加载和执行系统调用exec

- 允许进程加载一个完全不同的进程，从main开始执行
- 运行进程加载指定启动参数
- exec调用成功
  - 它是相同的进程
  - 执行了不停的程序
- 代码段，堆栈，堆重写

sys exec

do execve

load iode

 ucore第一个进程

proc_init

init_main

12.4进程等待与退出

父子进程交互

wait 系统调用，父进程等待子进程结束

- 子进程结束通过exit向父进程返回一个值
- 父进程通过wait接受并处理返回值

wait系统调用功能

- 有子进程存活，父进程进入等待，等待子进程返回结果
  - 子进程调用exit唤醒父进程，将exit返回值作为父进程wait返回值
  - 有僵尸子进程等待，wait 立即返回一个值
  - 无子进程，wait直接返回
  进程有序终止exit
  进程执行exit，完成堆资源的回收
  exit系统调用功能
  	调用参数作为返回结果
  	关闭打开的文件等资源
  	释放内存
  	释放大部分进程相关的内核数据结构
  	检查是否父进程存活
  		如果存活，进入僵尸状态
  		如果没有，释放数据结构，进程结束
  	清理所有僵尸进程
- 进程终止是最终的垃圾收集

其他进程控制系统调用

优先级控制

- nice指定进程初始优先级
- unix系统进程优先级会随时间而衰减

进程调度支持

- ptrace允许一个进程控制另一个进程的执行
- 设置断点和查看寄存器

定时

- sleep让进程在定时器等待队列中等待



进程控制与进程状态

创建 就绪 运行 等待 退出

fork 创建进程

wait 运行到等待

exit 运行到退出

子进程exit 等待到就绪







## 2 进程创建

创建新进程

windows API creatprocess

- 创建时候关闭所在子进程文件描述符号
- 创建时候改变子进程环境

unix进程创建系统调到

fork exec

fork 把一个进程复制给两个进程

 old PID new PID

exec 用新程序改写进程

pid不变

fork创建一个继承的子进程

- 复制父进程的所有变量和内存
- 复制父进程的所有cpu寄存器(1个寄存器例外)

fork返回值

- 子进程fork返回9
- 父进程fork返回子进程PID
- fork返回值可方便后续使用，子进程可使用getpid获得PID

fork地址空间复制

fork()执行过程对于子进程而言，是调用时间对父进程地址空间的一次复制

- 父进程fork,返回childPID,子进程返回0



shell调用fork

fork使用实例

空闲进程的创建

空闲进程的创建

idleproc

分配资源

初始化进程控制块

完成初始化

创建一个内核线程

initproc 

初始化trapframe

初始化内核堆栈

内存共享





fork开销

- 子进程分配内存
- 复制父进程的内存和cpu寄存器到子进程
- 开销昂贵

99情况下，调用fork调用exec

- fork内存复制没用
- 子进程可能关闭打开的文件和连接
- 为什么不结合他们在一块

vfork

- 创建进程时候，不再创建一个同样的内存映像
- 一些被称为轻量级fork
- 子进程用过立刻调用exec
- 现在使用写时复制技术

## 12.3进程加载

程序加载和执行系统调用exec

- 允许进程加载一个完全不同的进程，从main开始执行
- 运行进程加载指定启动参数
- exec调用成功
  - 它是相同的进程
  - 执行了不停的程序
- 代码段，堆栈，堆重写

sys exec

do execve

load iode

 ucore第一个进程

proc_init

init_main

## 12.4进程等待与退出

父子进程交互

wait 系统调用，父进程等待子进程结束

- 子进程结束通过exit向父进程返回一个值
- 父进程通过wait接受并处理返回值

wait系统调用功能

- 有子进程存活，父进程进入等待，等待子进程返回结果

  - 子进程调用exit唤醒父进程，将exit返回值作为父进程wait返回值
  - 有僵尸子进程等待，wait 立即返回一个值
  - 无子进程，wait直接返回

  进程有序终止exit

  进程执行exit，完成堆资源的回收

  exit系统调用功能

  ​	调用参数作为返回结果

  ​	关闭打开的文件等资源

  ​	释放内存

  ​	释放大部分进程相关的内核数据结构

  ​	检查是否父进程存活

  ​		如果存活，进入僵尸状态

  ​		如果没有，释放数据结构，进程结束

  ​	清理所有僵尸进程

- 进程终止是最终的垃圾收集

其他进程控制系统调用

优先级控制

- nice指定进程初始优先级
- unix系统进程优先级会随时间而衰减

进程调度支持

- ptrace允许一个进程控制另一个进程的执行
- 设置断点和查看寄存器

定时

- sleep让进程在定时器等待队列中等待



进程控制与进程状态

创建 就绪 运行 等待 退出

fork 创建进程

wait 运行到等待

exit 运行到退出

子进程exit 等待到就绪



# **第十五讲 处理机调度**

## 15.1 处理机调度概念

cpu资源的时分复用

- 保存当前进程在pcb中执行上下文cpu状态
- 恢复下一个进程的执行上下文

处理机调度

- 从就绪队列中挑选一个占用cpu运行的进程
- 从多个cpu中挑选就绪ijnc可使用cpu资源

调度程序：挑选就绪进程的内核函数

调度策略

- 依据什么原则

调度时机

- 什么时候调度

第哦啊度时机

在进程的生命周期什么时候进行调度

- 内核运行调度条件

  - 进程从运行到的等待
  - 进程退出

- 非抢占

- 可抢占系统

  - 中断请求被服务例程完成

  - 当前进程被抢占

    - 进程时间片用完
    - 进程从等待切换到就绪

    

## 15.2 调度准则

调度策略

- 确定如何从就绪队列选择下一个执行进程

调度策略要解决的问题

- 挑选就绪队列的哪一个进程
- 通过什么样的准则来选择

调度算法

- 在调度程序中实现的调度策略

比较调度算法准则

处理机资源使用模式

进程在cpu和io之间切换





比较准则

cpu使用率

- cpu处于忙状态百分比

吞吐量

- 单位是假案进程数目

周转时间

- 进程初始化到结束的总时间

等待时间

- 进程在就绪队列的总时间

吞吐量与延迟



调度算法希望块

什么是块？

传文件高带宽，调度算法是高吞吐量

玩游戏时候低延迟，调度算法低响应延时

相互独立

水管

- 低延时，喝水时候有水
- 高带宽，给游泳池灌满水

减少响应时间

- 纪实处理用户输入请求，尽快输出反馈用户

减少平均响应时间的波动

- 交互系统，可预测性比高差异低平均更重要

低延迟改善了用户交互体验

响应时间是操作系统的计算延迟



吞吐量

- 减少开销（操作系统开销，上下文切换）
- 系统资源的高校利用cpi io

减少等待时间

- 减少每个进程的等待使劲按

操作系统需要保证吞吐量不影响用户交互

- 操作系统必须不时调度，即使存在许多交互任务

吞吐量是操作系统的计算带宽



公平

保证每个进程占用相同cpu时间

保证每个进程等待时间相同

平均响应时间

## 15.3 调度算法

先来先服务

短进程优先

高响应比优先

时间片轮转

多级反馈队列

公平共享调度

先来先服务算法FIFS

- 依据进程进入就绪状态的先后顺序排序
  - 进程进入等待或结束状态时，就绪队列下一个进程占用cpu
- fcfs周转时间

短进程优先算法

选择继续队列执行时间最短进程占用cpu进入状态

- 就绪队列按预期执行时间排序

短剩余时间优先算法

- 最优平均周转时间

缺点：

- 可能产生饥饿
  - 连续短进程导致长进程无法获得cpu
- 需要预知未来
  - 如何预估下一个cpu计算持续时间
  - 简单的办法：询问用户
    - 用户欺骗
    - 用户不知道

短作业优先算法预计时间预估

历史执行时间来预估未来的执行时间

最高响应比优先算法

按照响应比r排序

R=(w+s)/s

w 等待时间

s 执行时间

短进程优先算法基础改进

不可抢占

关注进程的等待时间

防止无限期等待

## 15.4 时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架

时间片轮转 rr

时间片

- 分配给处理机资源的基本时间单元
- 算法思路
  - 时间片结束，按fcfs算法切换到下一个就绪队列
  - 每隔n-1时间片进程执行下一个时间片p

RR算法开销

- 额外的上下文开销

时间片太大

- 等待时间长
- 极端情况fifs

太短

- 反应讯下，上下文开销不行
- 大量上下文切换开销影响到系统吞吐量
- 上下文占比率1%

多级队列调度算法mq

就绪队列划分为独立子队列

- 前台交互
- 后台批处理

每隔队列有自己调度策略

队列的调度

- 固定优先级
- 可能导致饥饿

时间片轮转

- 每个队列一个都得到一个确定的能调度其进程cpu总时间

多级反馈队列

进程可以在不同进程移动

- 时间片随优先级改变
- 进程当前时间片没看完，降级

公平共享调度算法

ffss对用户资源的访问

- 一些用户组比其他用户组更重要
- 保证不重要的组无法垄断时间
- 没用按比例分
- 没有到达资源使用率目标的组获得更高优先级



ucore调度队列

run sleep状态

进程切换

保存中断

中断处理

ucore调度算法接口

schedule 

wait

sleep

exit

wake

next

dequeueu

emqueue

proc_tick

## 15.5 实时调度和多处理器调度

实时掉地 对时间哟球高

- 正确性要求时间和功能

实时操作系统性能指标

- 时间约束及时性
- 速度和平均性能不重要

实时操作系统特性

- 时间约束的可预测性

实时任务

任务

- 一次计算，文件读取

任务属性

- 完成任务所需要资源
- 定时参数

周期实时任务：一系列相似任务

- 任务有规律的重复
- 周期p= 任务请求间隔
- 执行时间=最大执行时间
- 使用率=e/p

硬实时和软实时

硬

- 错就是会灾难
- 必须验证，最坏时间保证

软实时

- 尽力而为

可调度性

可调度表示一个实时操作系统可满足任务的要求

- 需要任务执行顺序
- 动态优先级
- 静态优先级



实时调度

速率单调算法

- 通过周期安排优先级
- 周期短优先级高
- 周期短任务

最早截至时间优先

- 截止时间越早
- 执行截至时间最早的任务



多处理器调度

- 多个处理机，多个物理cpu
- 处理器负载共享
- smp对称多处理机系统
  - 每隔处理器自己的调度程序
  - 调度程序共享资源需要同步

多处理机的进程分配

静态进程分配

- 执行开始到结束固定处理机
- 每隔有自己的就绪队列
- 调度容易
- 处理机不均衡

动态进程分配

- 进程执行可被分任意空闲处理机
- 所有处理机共享一个公共队列
- 调度开销大
- 处理器负载均衡



15.6  优先级反置

操作系统中出现高优先级进程长时间等待低优先级进程所占用资源的现象

优先级继承

占用资源的低优先级进程继承申请资源的高优先级进程的优先级

优先级天花板协议

占用资源进程优先级和所有可能申请该资源短进程的最高级优先级相同

- 不管是否发生等待，都提升占用资源进程的优先级



第十六讲 实验六 调度器

16.1 总体介绍和调度过程

处理器调度

目标

连续

概述

分析ucore调度器算法

分析rr调度算法

分析实现stride调度算法

流程回顾

lab5 进程管理

加载 复制 生命周期 系统调用

idle

- 不断遍历进程池
- 知道找到runable状态进程
- 调度并通过过进程切换执行新进程

实现调度算法的调度类

LAB6调度框架



实现调度算法类——绑定调度类——设定调度点

除法调度事件

- 调整调度参数
- 调用调度算法
  - 选择新进程
  - 进程切换
    - 新进程运行
    - idle线程运行



调度过程

1. 触发
2. 入队
3. 选取
4. 出队
5. 切换

等待/睡眠队列

就绪队列

调度算法

就绪与运行的切换

16.2 调度算法支撑框架

调度点 触发做调度相关的工作

do_exit 进程结束 ，放弃cpu

do_wait 等待子进程结束，主动放弃cpu

main 等待用户进程结束

	所有用户进程结束，回收系统资源

调度算法如何知道进程事件

进入离开就绪队列——机制

- 抽象数据结构，可以不是队列
- 根据调度算法采用具体的数据结构

进程切换 

fifs

rr

stride

16.3 时间片轮转调度算法

时钟--

时钟到0

放弃cpu

换进程

16.4 Stride调度算法

步长最小

基于优先级

调度选择是一致的

实现步骤

选择合适的数据结构

list

priority queue 

处理时钟

第十七讲 同步互斥

17.1 背景

独立进程

- 不和其它今年初共享资源或状态
- 确定性——输入状态决定后果
- 可重现——能够重现起始条件
- 调度顺序不重要

并发进程

- 进程资源共享
- 不确定性
- 不可重现

并发进程的正确性

- 执行过程是不确定的和不可重现的
- 程序错误间歇性的

并发好处

1：共享资源

- 多账户公用一个计算机
- 银行存款可以多atm机操作
- 机器人上嵌入式系统协调手臂

2：加速

- io cpu并行
- 程序划分多个模块分在多个处理器上并行执行

3. 模块化

- 大程序到小程序

编译为例子，gcc调用cpp cc1 cc2 as ld

- 便于扩展与复用

并发创建新进程时候的标识分配

程序可以调用函数fork来创建一个新的进程

- 操作系统需要分配一个新的并且唯一的进程id
- 内核中，系统第哦啊用会执行nextpid++

两个进程并发执行预期结果

- 一个进程得到id 100
- 另一个进程101
- nextpid为102

原子操作

- 原子操作是指一次不存在任何中断或失败的操作
  - 要么成功
  - 要么不执行
  - 不会部分执行
- 操作系统提供同步机制，保证一些原子操作

17.2 现实生活中的同步问题

家里冰箱买东西

会买重复

如何协调

- 没东西有人买
- 最多一个人买

解决办法

- 冰箱加锁
- 放回来开锁

加锁导致

- 别人拿别的东西也拿不到

方案1

贴便签

买完去掉便签

别人看见就不买了

分析

- 偶尔会购买太多
- 检查面包和便签后 贴便签前，有人检查面包和便签

解决方案间歇性失败

- 难以调试
- 考虑调度器

方案2

先贴便签，再检查面包和便签

可能情况 都贴了条字，谁也不买面包

方案3 

为便签增加标记，区分不同人的便签

- 检查前留便签

和方案2一样，谁也不去买面包

方案4 

两人不同流程

a 不停检查知道没有便签

b 留便签，买面包

有效的，进程代码不相同

有效，但是复杂

- 有效性难以验证

ab代码不同

- 每个进程的代码不同
- 进程多了很难

a忙等待，

方案5

利用2个原子操作实现一个锁

lock.acquire

lock.release

- 解锁唤醒任何等待进程
- 基于原子锁的解决方案

进入临界区

临界区

退出临界区

进程交互：相互感知程度

- 独立
- 共享进行协作 共享资源
- 通信进行协调 其他进程的信息

互斥

- 一个进程占用，其他不能占用

死锁

- 多个进程占用一部分资源，循环等待

饥饿

- 其他人轮流占用资源，一个进程得不到资源



17.3 临界区和禁用硬件中断同步方法

临界区

- 进程访问临界资源的一段互斥执行的代码

临界区访问规则

- 空闲则入
  - 没有进程在临界区其他都能进去
- 忙则等待
  - 有进程在临界区，其他进程均不能进入
- 有限等待
  - 等待进入临界区进程不能无限等待
- 让权等待
  - 不能进入进入临界区进程，应释放cpu（如转换到阻塞状态）

临界区实现方法

- 禁止中断
- 软件方法
- 高级抽象方法

比较

- 性能
- 并发级别



1 禁用中断

没有中断，没有上下文切换，没有并发

- 硬件将中断处理延迟到中断启动后
- 现代计算机体系结构都是提供指令来禁用中断

进入临界区、

- 关中断，保存标志

离开临界区

- 退出中断



缺点

- 禁用中断，进程无法停止
- 可能导致其他进程饥饿

临界区很长

- 无法去欸的那个响应中断时间

要小心使用

17.4 基于软件的同步方法

软件解决

共享变量



满足忙则等待，不能空闲则入



第二次

两个变量，描述线程是否在临界区

不满足空闲则入

peterson

dekkers算法

n线程

flag标志

复杂

- 需要进程共享数据项

忙等待

- 浪费cpu时间

17.5 高级抽象的同步方法

硬件同步原语

- 中断禁用，原子操作指令

操作系统提供更高级的编程抽象来简化进程同步

- 锁，信号量
- 硬件原语

锁

锁是抽象数据结构

- 二进制变量
- acquire
- release

锁来控制临界区访问

原子操作

cpu提供特殊原子操作指令

测试与置位指令

- 内存读值
- 测试是否1
- 写1

交换指令

- 交换内存两个值

ts指令自旋锁

线程等待时间消耗cpu

无忙等待锁

原子操作指令锁

优点：

- 单处理机或多处理机的任意进程同步
- 简单容易证明
- 支持多临界区

缺点：

- 忙等待消耗处理器
- 可能饥饿
  - 离开有多个等待进程
- 死锁
  - 拥有临界区低优先级
  - 要求访问临界区进程获得处理器并等待临界区

同步总结

锁是一种高级的抽象

- 互斥使用锁
- 硬件支持



三种办法

- 关中断 单处理器
- 软件 复杂
- 原子操作指令 单处理机 多处理机



第十八讲 信号量与管程

18.1 信号量

并发行

- 多线程并发导致资源竞争

同步

- 协调多个进程对共享数据的访问
- 任何适合只能一个线程执行临界区代码



并发编程

高层抽象

硬件支持



信号量与锁



信号量是操作系统提供的一种协调共享资源访问的方法

- 软件同步是平等线程间一种同步协商机制
- os是管理者，第位高于进程
- 用信号量表示系统资源的数量

迪杰斯特拉

信号量

- 抽象数据类型
- 整型1个和原子操作2个
- p
  - sem-1
  - sem<0,等待，否则继续
- v
  - sem++
  - sen<=0,唤醒一个等待进程

信号量与铁路

- 2站台车站
- 两个资源的信号量

信号量 被保护的整形

- 初始化后只能pv
- 操作系统保证，pv原子操作

假定信号量公平

- 线程不会无限阻塞
- 信号量先进先出排队

信号量实现

18.2 信号量使用



信号量

- 二进制信号量 资源0 1
- 资源信号量 任意非负整数

信号量的使用

- 互斥访问
  - 临界区的互斥访问控制
- 条件同步
  - 线程间的事件等待

信号量实现互斥访问

每个资源一个信号量 处置1

p

v

信号量实现同步

同步初值 0

生产者消费者问题

生产者 缓冲区 消费者

有界缓冲区生产者消费者问题

- 一个多个生产者生成数据放一个缓存区
- 缓冲区单个人读取
- 任何时刻一个生产者或消费者访问缓冲区

信号量解决生产者——消费者问题

问题分析

- 任何时刻一个线程操作缓冲区 互斥访问
- 缓冲区空的，消费者必须等生产者 条件同步
- 缓冲区满了，生产者必须等消费者

信号量约束

- 二进制信号量
- 资源信号量full
- 资源信号量empty

pv调整死锁

信号量困难

- 读写代码困难
  - 需要理解信号量
  - 容易出错
  - 忘记释放
- 不能处理死锁

18.3 管程

管城 多线程互斥访问共享资源的程序结构

- 面向对象的方法，简化了线程同步控制
- 任一时刻最多一个线程执行管城代码
- 正在管城的线程可以临时放弃管城互斥访问，等待事件出现恢复

管程的使用

- 对象中收集相关共享数据

管程组成

一个锁

- 控制管城互斥访问

0个多个条件变量

- 管理共享数据的并发访问

条件变量

管程内部的等待机制

- 进入管城的线程因资源被占用而进入等待状态
- 每个条件变量表示一种等待原因，对应一个等待队列

wait操作

- 将自己阻塞在等待队列
- 唤醒一个等待或者释放管程的互斥访问

signal操作

- 等待队列一个线程唤醒
- 等待队列为空，等同空操作
## 15.6  优先级反置

操作系统中出现高优先级进程长时间等待低优先级进程所占用资源的现象

优先级继承

占用资源的低优先级进程继承申请资源的高优先级进程的优先级

优先级天花板协议

占用资源进程优先级和所有可能申请该资源短进程的最高级优先级相同

- 不管是否发生等待，都提升占用资源进程的优先级



# **第十六讲 实验六 调度器**

## 16.1 总体介绍和调度过程

处理器调度

目标

连续

概述

分析ucore调度器算法

分析rr调度算法

分析实现stride调度算法

流程回顾

lab5 进程管理

加载 复制 生命周期 系统调用

idle

- 不断遍历进程池
- 知道找到runable状态进程
- 调度并通过过进程切换执行新进程

实现调度算法的调度类

LAB6调度框架



实现调度算法类——绑定调度类——设定调度点

除法调度事件

- 调整调度参数
- 调用调度算法
  - 选择新进程
  - 进程切换
    - 新进程运行
    - idle线程运行



调度过程

1. 触发
2. 入队
3. 选取
4. 出队
5. 切换

等待/睡眠队列

就绪队列

调度算法

就绪与运行的切换

## 16.2 调度算法支撑框架

调度点 触发做调度相关的工作

do_exit 进程结束 ，放弃cpu

do_wait 等待子进程结束，主动放弃cpu

main 等待用户进程结束

​	所有用户进程结束，回收系统资源

调度算法如何知道进程事件

进入离开就绪队列——机制

- 抽象数据结构，可以不是队列
- 根据调度算法采用具体的数据结构

进程切换 

fifs

rr

stride

## 16.3 时间片轮转调度算法

时钟--

时钟到0

放弃cpu

换进程

## 16.4 Stride调度算法

步长最小

基于优先级

调度选择是一致的

实现步骤

选择合适的数据结构

list

priority queue 

处理时钟

# **第十七讲 同步互斥**

## 17.1 背景

独立进程

- 不和其它今年初共享资源或状态
- 确定性——输入状态决定后果
- 可重现——能够重现起始条件
- 调度顺序不重要

并发进程

- 进程资源共享
- 不确定性
- 不可重现

并发进程的正确性

- 执行过程是不确定的和不可重现的
- 程序错误间歇性的

并发好处

1：共享资源

- 多账户公用一个计算机
- 银行存款可以多atm机操作
- 机器人上嵌入式系统协调手臂

2：加速

- io cpu并行
- 程序划分多个模块分在多个处理器上并行执行

3. 模块化

- 大程序到小程序

编译为例子，gcc调用cpp cc1 cc2 as ld

- 便于扩展与复用

并发创建新进程时候的标识分配

程序可以调用函数fork来创建一个新的进程

- 操作系统需要分配一个新的并且唯一的进程id
- 内核中，系统第哦啊用会执行nextpid++

两个进程并发执行预期结果

- 一个进程得到id 100
- 另一个进程101
- nextpid为102

原子操作

- 原子操作是指一次不存在任何中断或失败的操作
  - 要么成功
  - 要么不执行
  - 不会部分执行
- 操作系统提供同步机制，保证一些原子操作

## 17.2 现实生活中的同步问题

家里冰箱买东西

会买重复

如何协调

- 没东西有人买
- 最多一个人买

解决办法

- 冰箱加锁
- 放回来开锁

加锁导致

- 别人拿别的东西也拿不到

方案1

贴便签

买完去掉便签

别人看见就不买了

分析

- 偶尔会购买太多
- 检查面包和便签后 贴便签前，有人检查面包和便签

解决方案间歇性失败

- 难以调试
- 考虑调度器

方案2

先贴便签，再检查面包和便签

可能情况 都贴了条字，谁也不买面包

方案3 

为便签增加标记，区分不同人的便签

- 检查前留便签

和方案2一样，谁也不去买面包

方案4 

两人不同流程

a 不停检查知道没有便签

b 留便签，买面包

有效的，进程代码不相同

有效，但是复杂

- 有效性难以验证

ab代码不同

- 每个进程的代码不同
- 进程多了很难

a忙等待，

方案5

利用2个原子操作实现一个锁

lock.acquire

lock.release

- 解锁唤醒任何等待进程
- 基于原子锁的解决方案

进入临界区

临界区

退出临界区

进程交互：相互感知程度

- 独立
- 共享进行协作 共享资源
- 通信进行协调 其他进程的信息

互斥

- 一个进程占用，其他不能占用

死锁

- 多个进程占用一部分资源，循环等待

饥饿

- 其他人轮流占用资源，一个进程得不到资源



## 17.3 临界区和禁用硬件中断同步方法

临界区

- 进程访问临界资源的一段互斥执行的代码

临界区访问规则

- 空闲则入
  - 没有进程在临界区其他都能进去
- 忙则等待
  - 有进程在临界区，其他进程均不能进入
- 有限等待
  - 等待进入临界区进程不能无限等待
- 让权等待
  - 不能进入进入临界区进程，应释放cpu（如转换到阻塞状态）

临界区实现方法

- 禁止中断
- 软件方法
- 高级抽象方法

比较

- 性能
- 并发级别



1 禁用中断

没有中断，没有上下文切换，没有并发

- 硬件将中断处理延迟到中断启动后
- 现代计算机体系结构都是提供指令来禁用中断

进入临界区、

- 关中断，保存标志

离开临界区

- 退出中断



缺点

- 禁用中断，进程无法停止
- 可能导致其他进程饥饿

临界区很长

- 无法去欸的那个响应中断时间

要小心使用

## 17.4 基于软件的同步方法

软件解决

共享变量



满足忙则等待，不能空闲则入



第二次

两个变量，描述线程是否在临界区

不满足空闲则入

peterson

dekkers算法

n线程

flag标志

复杂

- 需要进程共享数据项

忙等待

- 浪费cpu时间

## 17.5 高级抽象的同步方法

硬件同步原语

- 中断禁用，原子操作指令

操作系统提供更高级的编程抽象来简化进程同步

- 锁，信号量
- 硬件原语

锁

锁是抽象数据结构

- 二进制变量
- acquire
- release

锁来控制临界区访问

原子操作

cpu提供特殊原子操作指令

测试与置位指令

- 内存读值
- 测试是否1
- 写1

交换指令

- 交换内存两个值

ts指令自旋锁

线程等待时间消耗cpu

**无忙等待锁**

原子操作指令锁

优点：

- 单处理机或多处理机的任意进程同步
- 简单容易证明
- 支持多临界区

缺点：

- 忙等待消耗处理器
- 可能饥饿
  - 离开有多个等待进程
- 死锁
  - 拥有临界区低优先级
  - 要求访问临界区进程获得处理器并等待临界区

同步总结

锁是一种高级的抽象

- 互斥使用锁
- 硬件支持



三种办法

- 关中断 单处理器
- 软件 复杂
- 原子操作指令 单处理机 多处理机



# **第十八讲 信号量与管程**

## 18.1 信号量

并发行

- 多线程并发导致资源竞争

同步

- 协调多个进程对共享数据的访问
- 任何适合只能一个线程执行临界区代码



并发编程

高层抽象

硬件支持



信号量与锁



信号量是操作系统提供的一种协调共享资源访问的方法

- 软件同步是平等线程间一种同步协商机制
- os是管理者，第位高于进程
- 用信号量表示系统资源的数量

迪杰斯特拉

信号量

- 抽象数据类型
- 整型1个和原子操作2个
- p
  - sem-1
  - sem<0,等待，否则继续
- v
  - sem++
  - sen<=0,唤醒一个等待进程

信号量与铁路

- 2站台车站
- 两个资源的信号量

信号量 被保护的整形

- 初始化后只能pv
- 操作系统保证，pv原子操作

假定信号量公平

- 线程不会无限阻塞
- 信号量先进先出排队

信号量实现

## 18.2 信号量使用



信号量

- 二进制信号量 资源0 1
- 资源信号量 任意非负整数

信号量的使用

- 互斥访问
  - 临界区的互斥访问控制
- 条件同步
  - 线程间的事件等待

信号量实现互斥访问

每个资源一个信号量 处置1

p

v

信号量实现同步

同步初值 0

生产者消费者问题

生产者 缓冲区 消费者

有界缓冲区生产者消费者问题

- 一个多个生产者生成数据放一个缓存区
- 缓冲区单个人读取
- 任何时刻一个生产者或消费者访问缓冲区

信号量解决生产者——消费者问题

问题分析

- 任何时刻一个线程操作缓冲区 互斥访问
- 缓冲区空的，消费者必须等生产者 条件同步
- 缓冲区满了，生产者必须等消费者

信号量约束

- 二进制信号量
- 资源信号量full
- 资源信号量empty

pv调整死锁

信号量困难

- 读写代码困难
  - 需要理解信号量
  - 容易出错
  - 忘记释放
- 不能处理死锁

## 18.3 管程

管城 多线程互斥访问共享资源的程序结构

- 面向对象的方法，简化了线程同步控制
- 任一时刻最多一个线程执行管城代码
- 正在管城的线程可以临时放弃管城互斥访问，等待事件出现恢复

管程的使用

- 对象中收集相关共享数据

管程组成

一个锁

- 控制管城互斥访问

0个多个条件变量

- 管理共享数据的并发访问

条件变量

管程内部的等待机制

- 进入管城的线程因资源被占用而进入等待状态
- 每个条件变量表示一种等待原因，对应一个等待队列

wait操作

- 将自己阻塞在等待队列
- 唤醒一个等待或者释放管程的互斥访问

signal操作

- 等待队列一个线程唤醒
- 等待队列为空，等同空操作

管程条件变量释放处理方式

hansen 

条件变量释放仅仅一个提示

需要检查条件

hoare

## 18.4 哲学家就餐问题

5个哲学家一个桌子

5支筷子

2个之间一支

思考就餐

两个筷子才能用

方案1

```
思考
p
左边
右边
v
释放
左边
右边
吃饭
```

死锁

都拿左边

方案2

```
一次一个哲学家拿刀叉
```



一次一个人吃

正确，低效



方案3

避免成环

```

i%2==0
偶数左右
奇数右左

```
