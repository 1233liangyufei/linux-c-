





































北大[《操作系统原理》](https://link.jianshu.com?t=https://www.coursera.org/learn/os-pku)课堂笔记，原文首发于[个人博客](https://link.jianshu.com?t=http://jennica.space/2017/03/21/os-principle/)，大纲如下：

1. 操作系统概述
2. 操作系统运行环境
3. 进程线程模型
4. 处理器调度
5. 同步机制
6. 存储模型
7. 文件系统
8. I/O系统
9. 死锁

# 操作系统概述

1. 执行程序：通过调度选中程序开始执行，在执行过程中，不断陷入操作系统提供各种服务支持，再调度选中程序，直到完成
2. 功能：有效（充分利用CPU、内存、磁盘等资源）、合理（公平的资源管理策略）、易用（用户界面和编程接口）
3. 作用：管理资源（硬件、软件）、向用户提供服务（创建、执行、IO、统计）、对硬件机器扩展（屏蔽硬件细节、提供虚拟机器界面）
4. 特征：并发（处理多个同时性活动）、共享（非同时互斥共享、同时共享有限系统资源）、虚拟（映射为若干逻辑实体）、随机（不可预知运行次序）
5. 典型架构（用户态、内核态）：Windows（硬件抽象、设备驱动、内核、图形窗口、执行体、内核态可调用接口、服务分发器、DLL）、Unix（硬件控制层、调度、进程间通信、存储管理、内存管理、文件系统、设备驱动、系统调用接口）、Linux（进程、调度、虚拟内存、物理内存管理、各种设备驱动、网络模块、陷入异常模块、中断处理模块、系统调用接口） 、Android（Linux内核、系统库和Android运行时系统、应用程序框架、应用程序）
6. 分类：批处理（Spooling缓存I/O到磁盘）、分时（时间片、追求响应时间、交互式）、实时（严格时间、高可靠）、个人计算机（使用方便）、网络（通信、资源共享）、分布式（多机协同完成一项任务）、嵌入式（特定装置中的软硬件系统）

# 操作系统运行环境

1. CPU：运算器、控制器、通用寄存器、控制和状态寄存器（PC、IR、PSW）、高速缓存
2. CPU状态：内核态（特权指令R0）、用户态（用户R3）
3. 中断／异常机制：CPU暂停当前执行程序，保留现场，硬件自动转去处理程序，处理完后回到断点，继续被打断的程序
4. 事件：中断响应外部事件，异步处理，总是返回下一条指令，如I/O、时钟、硬件故障；异常源于内部正在执行的程序，同步处理，分为陷入、故障、终止，如系统调用、页故障、断点、权限保护、程序
5. 中断响应（硬件）：指令周期末扫描中断寄存器，CPU切换到内核态，保存现场（PSW+PC），通过中断码查中断向量表（中断处理程序入口+处理机状态字），推送中断处理程序入口到寄存器
6. 中断处理程序（软件）：保存相关寄存器信息，分析发生原因。执行处理功能，恢复现场
7. 系统调用：用户在编程时可以调用的操作系统功能，如进程控制、通信、文件使用、目录操作、设备管理、信息维护
8. 程序调用：应用程序可以通过库函数和API进入系统调用，也可直接引发系统调用，系统调用再调用对应内核函数
9. 系统调用设计：中断／异常机制（支持系统调用服务的实现），陷入指令（引发异常，用户态切换到内核态），系统调用号和参数（不同系统调用的编号），系统调用表（服务程序的入口地址），参数传递（陷入指令自带、通用寄存器、内存中专用堆栈区）
10. 系统调用过程：CPU执行到特殊的陷入指令；中断硬件保护现场，通过门描述符（段选择符+偏移量）查系统调用表；转入查到的系统调用总入口程序，保护现场，保存参数到内核堆栈，通过系统调用号查系统调用表；执行查到的系统调用例程；恢复现场，返回用户程序

# 进程线程模型

1. 并发程序：一段时间内，单处理器上多个程序同时处于开始运行但未结束状态，且次序不是事先确定的
2. 进程：程序的一次执行，正在运行程序的抽象、将CPU虚拟为多个，系统资源分配单位，每个具有独立地址空间，操作系统将CPU调度给进程
3. 进程控制块PCB：进程描述（PID、用户标识、进程组关系）、进程控制（状态、优先级、入口地址、队列指针）、资源和使用状况（存储空间、文件）、CPU现场（进程不执行时保存寄存器值、指向页表的指针）
4. 进程状态：运行（占用CPU）、就绪（CPU不空闲）、等待／阻塞（等待某事）；创建（信息设置完但资源有限）、终止（统计信息、回收资源）；挂起（分就绪挂起和阻塞挂起，回收内存存磁盘，条件允许后可激活）
5. 进程队列：每类进程状态有一个或多个队列，元素为PCB，进程状态改变就是换队
6. 进程控制：利用完成某种功能的不允许中断的控制原语，转换进程状态
7. Unix进程控制操作：fork（复制调用进程创建）、exec（新代码覆盖原地址空间创建）、wait（主动阻塞）、exit（撤销，回收资源和PCB）
8. 进程层次结构：进程由其他进程创建，Unix进程家族树以init为根，Windows中各进程的地位相同
9. 进程地址空间：内核地址空间、用户地址空间（代码段、数据段、堆、共享库、栈）
10. 进程映像：进程地址空间、硬件寄存器、PCB及各种数据结构、进入进程时所需的内核栈
11. 上下文context切换：CPU硬件状态从一个进程换到另一个，运行的进程硬件状态保存在CPU寄存器上，不运行时保存在PCB中，之后可推送至CPU寄存器
12. 引入线程：应用需要（如Web服务器）、减少开销（创建和切换花费时间少，通信无需内核）、提升性能（多处理器）
13. 线程与进程：线程是进程中的运行实体，CPU的调度单位，增加了多个执行序列
14. 线程属性：ID、状态、上下文、栈指针；共享进程的地址空间和其他资源；程序以单线程进程开始，线程由线程创建和撤销
15. 线程的实现：Unix是用户级线程，内核无法感知线程存在，切换较快，但同进程的线程不能分到多CPU上，阻塞会阻塞整个进程；Windows是内核级线程，内核中包含线程表，调度以线程为单位；Solaris为混合模型，线程创建在用户空间，调度在内核
16. Pthread：POSIX多线程编程接口，线程协商谁上CPU；如yield函数主动让出CPU
17. 进程特性：并发（任何进程都可和其他同时推进）、动态（生命周期中切换状态）、独立（资源）、交互（进程间产生关系）、异步（进程独立不可预知的推进）、进程映像（程序+数据+栈+PCB）
18. 可重入程序：纯代码，执行不改变，调用它的进程提供数据区；大部分进程和线程只有可重入程序才可以运行

# 处理器调度

1. CPU调度：在合适的调度时机，按调度算法，调度就绪队列中的进程进CPU
2. 调度时机：内核对中断／异常／系统调用处理后，就绪队列改变引发重新调度，如进程终止、创建、运行转入阻塞、运行转入就绪
3. 进程切换：切换全局页目录加载新的地址空间，切换内核栈和硬件上下文；进程A切换到B，保存A上下文环境，更新A的PCB，A移至合适队列，B设为运行态，从B的PCB恢复上下文
4. 调度算法考虑：优先级与优先数？多级就绪队列如何组织？是否抢占？I/O密集或CPU密集友好？时间片长度？
5. 不同系统的调度算法：批处理处理看重吞吐量、周转时间、CPU利用率、平衡（先来先服务FCFS、最短作业优先SJF、最短剩余时间优先SRTN、最高响应比优先HRRN）；交互式系统看重响应时间、平衡（轮转Round-Robin、最高优先级HPF、多级反馈队列Feedback、类似SJF的最短进程优先SPN）
6. 优先级反转：抢占式最高优先级调度时，高优先级受制于低优先级（如临界区等待），而低优先级被运行时间较长的中优先级进程抢占，导致高优先级无法上CPU
7. 多级反馈队列：多个就绪队列，顺次优先级递减，时间片递增，每个队列内部按时间片轮转；新建进程进一级队列，用完时间片进下一级就绪队列；因阻塞进入等待队列的进程在等待完毕后，回到原级别的就绪队列，但可设置时间片是否重新分配，加入队首或队尾
8. 系统调度算法：Unix动态优先数，5.3BSD多级反馈队列，Linux抢占式调度，Windows基于优先级的抢占式多任务调度
9. Windows线程调度：调度单位是线程，基于动态优先级的抢占式调度，结合时间配额的调整；引发调度的条件除线程终止、创建、运行转入阻塞、运行转入就绪外，还有线程优先级改变和亲和处理机集合改变
10. 线程优先级提升：I/O完成、信号量或事件等待结束、前台进程的线程完成等待、窗口被唤醒、饥饿超时
11. 调度算法对比：

| 调度算法    | 是否抢占CPU | 吞吐量       | 响应时间 | 开销 | 对进程的影响      | 饥饿问题 |
| ----------- | ----------- | ------------ | -------- | ---- | ----------------- | -------- |
| FCFS        | N           | 不强调       | 可能很长 | 小   | 对短进程和I/O不利 | 无       |
| SJF         | N           | 高           | 短       | 大   | 对长进程不利      | 有       |
| SRTN        | Y           | 高           | 短       | 大   | 对长进程不利      | 有       |
| HRRN        | N           | 高           | 短       | 大   | 很好的平衡        | 无       |
| Round-Robin | Y           | 时间片小则低 | 短       | 小   | 公平              | 无       |
| Feedback    | Y           | 高           | 不强调   | 大   | 对I/O型有利       | 有       |

# 同步机制

1. 并发：进程的执行是间断的，相对运行速度不可预测，共享资源带来制约性
2. 竞争条件：多个进程读写共享数据时，结果取决于进程的精确时序
3. 进程互斥：多个进程的临界区代码对临界资源的使用需要排他性，各进程间竞争使用这些共享资源
4. 临界区：临界区空则可进入，但临界区中至多一个进程，临界区外的进程不能阻塞其他进程进临界区，不能让想进临界区的进程无限等待
5. 软件解决互斥：临界区空闲标志（free）、进区的用户（turn）、各自进区标志（pturn+qturn）、dekker算法（turn+pturn+qturn）、peterson（enter_region+leave_region/turn+interest[]）、
6. 硬件解决互斥：开关中断指令（特权指令、中断屏蔽限制CPU并发、不适合多CPU）、测试并加锁指令（对总线加锁）、交换指令（交换寄存器与锁变量）
7. 忙等待：进程在得到临界区访问权前，在CPU持续测试而不做别的事；多处理器中使用自旋锁测试，让其他CPU改锁状态，切换代价反而比持续测试大
8. 进程同步：多进程中发生的事件存在时序关系，需要协作完成任务
9. 生产者/消费者问题：生产者写入缓冲区，消费者从缓冲区取数据，不能同时消费和生产，缓冲区空不能消费，缓冲区满不能生产
10. 信号量：用于进程间传递信息的整数值，包含队列；操作包括初始化（非负数），原语操作P（减）V（增）；二元信号量解决互斥，多值信号量解决同步
11. PV解决互斥：划定临界区，初始化mutex为1，进临界区前执行P申请资源，出临界区后执行V唤醒等待
12. PV解决生产者/消费者：初始化mutex为1，empty为空位，full为0；用mutex对缓冲区进行PV解决互斥，用empty和full进行PV解决同步
13. PV解决读者/写者问题：允许多个读者同时读，不允许同时读写；针对w信号，第一个读前P，最后一个读完V，写前后PV；针对读者序列rc，也需要在修改或判断前后用PV保护
14. Linux读写锁：每个执行实体对临界区的访问或读或写，不会同时读写，此时可应用读者/写者模型；如路由表中的读写锁
15. 管程：有自己名字的特殊模块，由关于共享资源的数据结构和在其上的操作过程组成，进程可调用管程的过程以操作管程中的数据结构；编译器复杂管程的互斥，设置条件变量及等待唤醒操作解决同步问题
16. 管程内多进程：若P唤醒Q，则管程中同时存在活跃状态的P和Q两个进程；处理方法有Hoare（P等待Q）、Mesa（Q等待P），Hansen并发pascal（让唤醒是管程中最后可执行操作）
17. 管程应用：直接构造条件变量恰当的管程，用已有的同步机制间接构造；C++不支持管程，Java支持类似管程
18. Hoare管程：管程入口设置入口等待队列，内部设置紧急等待队列放置唤醒进程，P唤醒Q则P等待Q；wait(c)优先唤醒紧急队列队首，再将进程加入c链尾，signal(c)优先唤醒c链首进入紧急等待队列
19. Mesa管程：P唤醒Q则Q等待P，避免额外进程切换开销；signal衍化到notify，进程调度执行前再次检查条件，每个条件原语关联监视计时器超时即就绪，再衍化到broadcast使所有该条件队列上等待的进程进入就绪队列；Mesa优于Hoare
20. Pthread中的同步机制：互斥变量保护临界区`Pthread_mutex_[init/destroy/lock/unlock/trylock]`；条件变量解决同步`Pthread_cond_[init/destroy/wait/signal/broadcast]` 
21. 进程间通信：消息传递、共享内存、管道、用于网络分布式系统的套接字和远程过程调用
22. 消息传递：send原语，陷入内核，操作系统复制到消息缓冲区，并挂接消息到接受进程的消息队列指针；receive原语，操作系统将消息复制到接收进程的地址空间
23. 共享内存：物理内存中建立一块能够共享的内存空间，将物理内存空间映射到两个进程的地址空间；利用读者/写者问题解决互斥
24. 管道：利用缓冲传输介质内存或文件连接两个进程；按字符流读写，先进先出，解决互斥同步
25. Linux内核同步机制：原子操作（不可分割）、屏障（一组线程都到达汇合点后再一起推进）、自旋锁、信号量、完成变量、互斥体等

# 存储模型

1. 地址重定位：将逻辑／相对／虚拟地址，映射到物理／绝对／实地址；程序加载时用软件静态重定位，执行每条指令时用内存管理单元MMU动态重定位
2. 物理内存管理：数据结构（位图、空闲+已分配区表、空闲块链表）；分配算法（首次适配、下次适配、最佳适配、最差适配）
3. 伙伴系统：Linux底层内存分配算法，内存按2的整数次幂划分，组成空闲块链表，在链表中查找长度大于等于申请空间且不大于其一半的空闲块，内存回收时递归合并空闲伙伴
4. 基本内存管理方案：占据内存连续空间（单一连续区、固定分区、可变分区），分布在内存中不连续区域（页式、段式、段页式）
5. 单一连续区：单一程序独占内存，总是被加载到同一内存地址
6. 固定分区：将内存分割为若干连续分区，大小可不同但必须固定不变，每个分区装载一个进程
7. 可变分区：根据进程需要，动态分割出分区分配给进程
8. 页式：用户地址空间划分为大小相等的页，内存空间按页大小划分为多个页框，分配单位是页
9. 段式：用户地址空间按自身逻辑划分为若干段，内存空间划分为若干个长度不同的区域（可变分区），分配单位是段
10. 段页式：用户程序地址空间是段式，每段内含有多页，内存空间是页式，分配单位是页
11. 紧缩技术：在内存中移动程序，将所有小的碎片合并为较大的空闲区，不能解决页式管理造成的内碎片
12. 覆盖技术：将不会同时执行的程序段共享同一块内存，需要程序员显式编程，现在很少用
13. 交换技术：将程序内存中的堆栈（静态数据一直在磁盘），在很少使用或内存不够时，暂时移动到磁盘上的交换区（swap／pagefile），让外存中的程序占据其原有内存
14. 空间增长：进程的数据段和栈段会持续增长（堆向上，栈向下），可预留一些空间供给它们同向或反向增长
15. 虚拟存储：进程运行时先将部分装入内存，另一部分暂留在磁盘，执行指令或访问数据时按需从磁盘调入内存；虚存构建在存储体系上，由操作系统调度各存储器的使用；虚存大小与机器位数和磁盘大小有关
16. 存储保护：每个进程有独立地址空间，访问合法地址范围，权限合法
17. 虚拟页式：虚拟存储技术结合页式存储管理；方式有请求调页和预先调页
18. 页式映射：递归查找多级页表起始地址，与页内偏移拼接为物理地址；页表项中有效位代表是否已存入内存
19. 反转页表：以物理内存大小建立页表，将虚拟地址的页号部分哈希，指向反转页表的某个位置，借助链表解决冲突
20. 内存管理单元MMU：查页表和页表项的功能位，将虚拟地址转换为物理地址
21. 块表TLB：由cache组成，是按内容并行查找的相联存储器，保存部分页表项；MMU先查快表，没命中再查页表
22. 页错误：地址转换过程中硬件产生异常，包括缺页、违反权限、地址指向未定义
23. 驻留集：给每个进程分配的页框数；可根据进程类型和需要的固定分配，或依据缺页率评估的动态分配
24. 置换策略：置换范围为当前进程的驻留集叫局部置换，内存中所有未锁定页面都为候选叫全局置换；局部、全局置换结合固定、动态分配策略，共产生三种方案，局部固定、全局固定、全局动态
25. 清除策略：从进程驻留集中收回页框；分页守护程序，保证系统中总有一定数量的空页框；页缓冲技术，不丢弃置换页而是加入修改页链表中，定期批量写回磁盘
26. 页面置换算法：OPT（未来最远使用）、NRU（LRU的粗略近似）、FIFO（先进先出）、第二次机会（第一次先放队尾）、时钟（在环上移动指针）、LRU（优秀开销大）、老化（左置右移）、工作集（保持活跃页面的集合）
27. 影响缺页次数：置换（磁盘调度页面比运行时间多产生颠簸），页面大小（最优值为2倍的程序规模乘页表项再开根），程序编制方法（多维数组），驻留集（平衡点）
28. Belady现象：FIFO算法，驻留集增大，缺页率可能反而增加
29. 内存映射文件：用系统调用将文件映射到虚拟地址空间，访问文件就像访问大数组
30. 写时复制：父进程创建子进程后共享一块标记为写时复制的虚拟空间，当子进程执行自己代码数据时，操作系统为其分配新的空间

# 文件系统

1. 文件：标识为文件名，对用户而言有完整的逻辑含义，对操作系统而言是信息项的序列
2. 文件系统：管理磁盘空间，实现按名存取（名字空间到磁盘空间的转换），共享及保护，向用户和I/O提供接口
3. 文件分类：普通文件（包含用户信息的ASCII或二进制文件）、目录文件（管理文件系统的系统文件）、特殊文件（字符／块设备）、管道文件、套接字
4. 逻辑结构：流式文件（字符）、记录式文件（记录）
5. 蔟：信息存储、分配、传输的独立物理块单元
6. 磁盘结构：物理地址由磁头／盘面号、磁道／柱面号、扇区号构成；扇区包括10B标题、512B数据、12~16B的ECC纠错信息
7. 磁盘中文件相关数据结构：位图（设置0/1）、空闲块表（起始块号和空闲长度）、空闲块链表（每个节点含下一个指针）、成组链接法（从专用块出发，每组首个空闲块记录下组的空闲块号和块数）
8. 文件控制块FCB：包含管理文件所需的文件属性或元数据，包括名字、时间、地址、标志等
9. 文件目录：统一管理每个文件的元数据，完成名字到地址转换；文件目录以目录文件的形式存储在磁盘；目录项是FCB
10. 物理结构：顺序结构、链接结构、索引结构（存放索引表的索引块地址放在FBC中）
11. 索引表的组织：索引表很大，需要多个物理快存储时，可采用链接方式链接多个块、上级索引表每个表项放置下级索引表地址的多级索引、或两者结合的综合模式
12. 文件卷：磁盘逻辑分区，由一个或多个蔟组成，包含2的整数次幂个扇区；格式化就是在文件卷上初始化元数据，建立文件系统
13. 分区内容：引导区（引导操作系统所需信息，第一扇区）、卷信息（总蔟数、空闲蔟数和指针、空闲FCP数量和指针等）、目录文件（根目录及其他目录文件）、用户文件
14. Unix文件系统布局：引导区、超级数据块（文件系统结构信息）、空闲区管理（空闲表或相关结构）、i节点区、根目录区
15. Windows中FAT系统布局：引导区（文件系统数据记录）、文件分配表1（蔟的分配状态、标注下一簇）、文件分配表2（1的镜像）、根目录、其他目录和文件
16. 内存中文件相关数据结构：系统打开文件表，整个系统一张，包括FCB（i节点）信息、引用计数、修改标记；用户打开文件表，保存在每个进程的PCB中，包括文件描述符、打开方式、读写指针、系统打开文件表索引
17. 目录项分解：把FCB分为2部分，符号目录项（文件名、文件号）和基本目录项（除文件名外所有字段，描述文件相关信息）；Unix中FCB=目录项+i节点，每个文件由目录项、i节点、若干磁盘块构成
18. Unix文件查找/a/b/c：超级数据块中得到根目录文件地址，根目录文件中得到a的i节点地址，a的i节点中得到a目录文件地址，a目录文件中得到b的i节点地址，b的i节点中得到b目录文件地址，b目录文件中得到c的i节点地址，c的i节点中得到文件物理地址
19. FAT文件系统：按FAT表项字节数分为FAT12、FAT16、FAT32；FAT16根目录大小固定，不支持Unicode；目录项都为32B，包含文件属性和起始蔟号
20. 文件分配表FAT：可看作整数数组，每个整数代表磁盘分区的一个蔟号，记录状态和下一组蔟号
21. 解决长文件名：使用不固定长度的目录项，添加长度和结束标志；名字统一在堆存放，目录项中包含指向堆内的指针；FAT32的每个长目录项可保存13字符，长目录项前必须有一个普通的短目录项
22. 文件操作：创建（建FCB，分配存储空间）；打开（找目录项，更新共享计数，获取文件描述符）；指针定位（fd查用户打开文件表找表项，设置读写指针）；读文件（由文件描述符找FCB，转换为物理块，申请缓冲区，进行I/O）；重命名（修改FCB中的名字）
23. 一致性：磁盘块写回内存前出现故障，元数据一致性被破坏；Unix中用两个表记录使用中的块和空闲块，对比修复一致性
24. 写入策略：同时考虑速度和一致性；通写、延迟写、可恢复写（日志，如NTFS、ext3）
25. 访问控制：访问控制表（每个文件能被哪些用户操作），能力表（每个用户能操作哪些文件）；用户（owner、group、other），操作（r、w、x、-）
26. 提高性能：目录项分解、当前目录、磁盘碎片整理、块高速缓存（一式三份存在于磁盘、内存、缓存）、提前读取、合理分配磁盘空间（FCB与蔟同组）、磁盘调度、信息的优化分布（磁道排列方式）、记录的成组与分解（若干逻辑记录组成一块）、RAID等
27. 磁盘调度算法：FCFS、最短寻道时间优先、SCAN（电梯）、C-SCAN（总是从0号向内）、N-step-SCAN（每次服务n长子队列）、FSCAN（两个队列，新请求入另一个队列）、旋转调度（旋转延迟）
28. RAID：独立磁盘冗余矩阵，文件卷跨盘，用数据分条（如RAID0）并行I/O提高性能、用镜像（如RAID1）和校验（如RAID4）提供容错

# I/O系统

1. I/O管理：建立设备和内存间的数据通道，从应用程序或文件系统获得请求，交由设备硬件响应，过程由CPU控制
2. 设备分类：块设备（以块寻址）、字符设备（速率低）；独享设备（单进程使用，可静态或动态分配）、共享设备（多进程排队分时共享）、虚设备（共享设备模拟的独占设备，如Spooling技术）
3. 管理目标：按照用户请求，控制设备完成与内存间的数据交换；建立方便、统一的独立于设备的接口；提高CPU与设备、设备与设备的并行工作能力；保护数据的安全性、完整性、保密性
4. 硬件组成：机械部分是设备本身，物理装置；电子部分是设备控制器，完成端口编址、信号处理、缓冲
5. I/O地址：独立编址，端口与内存地址空间完全独立，分配给I/O地址空间很少，操作不灵活；内存映像编址，将I/O端口看作存储单元，与内存空间统一编址，不能对控制寄存器高速缓存
6. 控制方式：可编程（轮询，CPU忙等待）、中断驱动（操作结束后用中断主动通知驱动）、DMA（直接存储器访问，不通过CPU）
7. I/O演化：CPU控制->轮询->中断->DMA->单独的处理器->拥有局部存储器（本身已是计算机）
8. 软件层次：用户进程I/O（用户层执行输入输出系统调用，准备假脱机）、逻辑I/O（驱动程序的统一接口，错误报告，缓冲，分配和释放设备）、设备驱动程序（设置寄存器，检查执行状态）、中断处理程序（完成后唤醒设备驱动）
9. 设备独立性：用户编写程序时使用逻辑设备名，由系统实现逻辑设备到物理设备的映射；操作系统设计I/O软件时，除直接与设备打交道的底层软件外不依赖于硬件；设备分配灵活，易于实现I/O重定向
10. 缓冲技术：解决到达与离开速度不匹配的问题，提高CPU与I/O设备的并行性；按缓冲区位置有硬缓冲、软缓冲，按缓冲池个数有单缓冲、双缓冲、缓冲池
11. 缓冲区：由缓冲控制块和缓冲数据区组成，相关数据结构有空闲缓冲区队列av链和设备缓冲队列b链；开始时在av链，开始I/O请求时在I/O请求队列和b链，完成I/O后在av链和b链
12. 设备管理数据结构：描述设备的表格、建立同类资源的队列、面向I/O进程的动态数据结构、建立I/O的队列
13. 驱动程序：每个设备驱动程序管理一类设备，从上层接受并释放命令，监督执行时可让进程等待也可以不等待；与操作系统、用于初始化的系统引导、设备都有接口
14. I/O进程：系统级进程，优先级高；对于I/O请求，用户通过send发送给I/O进程，阻塞自己直到I/O完成并被唤醒，操作系统通过wakeup唤醒I/O进程，完成时用户要求的任务；对于I/O中断，操作系统判断为正常中断则交给I/O进程，异常则交给错误处理程序
15. 提高性能：缓冲（减少CPU和I/O的速度差距）、异步I/O（等待I/O期间CPU可进行其他操作）、DMA（CPU摆脱I/O）

# 死锁

1. 死锁：每个进程无限等待被该组进程中另一进程占有的资源；与之对比，活锁为先加锁再轮询不阻塞不推进，饥饿是由于资源分配策略如优先级导致得不到资源
2. 死锁条件：互斥使用（资源独占），占有且等待（部分分配），不可抢占（不可剥夺），循环等待（进程等待环路）
3. 资源分配图：进程是圆，资源类是方，资源实例是方框中黑点；申请边（进程，资源类）表示进程请求某类资源，分配边（资源实例，进程）表示资源分配给某进程
4. 死锁定理：在资源分配图中，无环路必无死锁，有环路可能有死锁，有环且资源类只包含一个实例必有死锁
5. 资源分配图简化：找只有分配边的资源，去掉边分配给需要的进程，自己变成孤点；重复上述步骤，若最后所有都是孤点则无死锁，否则有死锁
6. 解决死锁：鸵鸟算法（不考虑死锁）、死锁预防（静态分配）、死锁避免（动态评估）、死锁检测和解除
7. 死锁预防：破坏死锁必要条件；独占转为共享资源，一次性申请和分配、主动释放部分分配，操作系统帮助抢占，资源有序分配法（资源按热度编号，进程按资源号增序请求）
8. 死锁避免：对进程发出的每一个能满足的资源申请进行动态检查，根据分配后系统是否为不安全状态（死锁）决定是否分配
9. 安全序列：进程序列中任意进程，它还需要的资源不超过当前系统剩余资源与它之前的所有进程占有资源的和；此时系统为安全状态，一定无死锁，若不存在任何安全序列则为不安全状态，一定导致死锁
10. 银行家算法：五类数组available, max[i], allocation[i], need[i], request[i]；当进程i提出request[i]时，若不大于available则将allocation[i]加request[i]、available和need[i]减request[i]，此时判断新状态是否安全，安全则分配否则等待
11. 死锁检测：允许死锁发生，在资源不足、利用率下降时或周期性检测系统进展判断是否真的有死锁发生；死锁后解除死锁并以最小的代价恢复系统运行，可通过撤销死锁进程组、回退再启动、按某种原则逐一撤销进程或剥夺资源
12. 哲学家就餐：同步互斥问题，五个哲学家日常行为是思考，两两间放一只筷子，饥饿时要从左右取两只筷子才可吃饭，都先拿右边筷子时出现死锁；解决方法包括最多允许四个哲学家、利用管程一次性拿两只筷子、设置哲学家的三种状态结合检测和PV操作、每个哲学家按筷子增序拿、由银行家算法将最后的筷子分配给已拿到一只的人





这里是学习了北大的操作系统原理课程做的笔记，这门课有一个好处就是基本上按照《现代操作系统》这本书来讲的，可以对照着看，入门之后最好还是看看`MIT`的`6.824`，实际操作一下。

# 一、操作系统做了什么

通过一个例子进行说明：给出一个`c`程序`helloworld`

```c
#include<stdio.h>
  int main(int argc, char *argv[]){
    puts(“hello world”);
    return 0;
  }
```

**说明：**其功能就是在标准的显示器上显示一个字符串。下面看此程序的执行过程。

- 首先用户要告诉操作系统执行此程序：
  如何告知？比如我们可以在命令行输入相应的命令或者双击此程序的图标。
- 操作系统接到用户的请求之后就会到磁盘上找到此程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。
- 为了要执行此程序，操作系统首先要创建一个新的进程，并将此程序的可执行文件映射到该进程结构，表示由该进行执行此程序。之后操作系统为此程序设置`CPU`上下文环境，并跳到程序开始处（假设调度程序选中了此程序）。
- 当在执行程序的第一条指令的时候会发生缺页异常：因为程序在执行的时候，先要将程序的代码和数据装入内存，`CPU`才能够去执行。但是此时还没有读入内存，于是硬件机制就会捕获此异常，并且把控制权交给操作系统。
- 操作系统管理了系统中的内存，当然内存有很多中，比如这里我们拿页式管理方案的话，内存就会有很多的物理页面，操作系统的内存管理模块就会分配一页空闲物理内存，并且根据前面计算出的磁盘块地址把程序代码读到内存中，然后继续执行程序。有时候程序可能很大，所以一次分配可能不够，于是在执行过程中可能产生多次缺页异常。
- 然后程序执行`puts`函数（系统调用）。而puts函数是一个系统调用，于是控制权又交给了操作系统。
- 操作系统找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程。
- 控制设备的进程告诉设备的窗口系统它要显示的字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区。
- 然后视频硬件将像素转换成显示器可以接收的一组控制/数据信号。显示器然后解释此信号，激发液晶屏。

**总结**：

- 从用户的角度看上述执行过程

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-2c39278a4954f03b.png?imageMogr2/auto-orient/strip|imageView2/2/w/631/format/webp)

  1

  这是从用户角度来看的程序运行过程。

- 从操作系统的角度来看就是，如果操作系统选中了一个程序，那么就去调度此程序执行，程序执行过程中会不断的陷入操作系统，由操作系统去提供一些服务，当服务完成之后操作系统又会去调用程序去执行。

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-cc834536f9af8cd6.png?imageMogr2/auto-orient/strip|imageView2/2/w/638/format/webp)

  2

# 二、操作系统的定义和作用

## 2.1 定义

操作系统是计算机系统中的一个系统软件，是一些程序模块的集合：

- 它们能以尽量有效、合理的方式组织和管理计算机的软硬件资源
- 合理地组织计算机的工作流程，控制程序的执行并向用户提供各种服务功能
- 使得用户能够灵活、方便地使用计算机，使整个计算机系统高效运行。

## 2.2 操作系统管的作用

### 2.2.1 资源的管理者：有效

这是从自底向上看的，即从操作系统内部来看。

- 硬件资源：`CPU`、内存、设备等
- 软件资源：磁盘上的文件、各类管理信息等。

**1、怎样管理资源？**

- 跟踪记录资源的使用状况：这是使用各类数据结构来跟踪的，跟踪的信息有如哪些资源空闲，分配给谁使用，允许使用多长时间等。
- 确定资源分配侧露：即需要相关的算法。如静态分配策略（进程需要的资源一开始就分配好，会导致浪费），动态分配策略（在一个进程的执行过程中什么时候需要什么时候分配）
- 实施资源的分配和回收
- 提供资源利用率
- 保护资源的使用
- 协调多个进程对资源请求的冲突

**2、从资源管理的角度：五大基本功能**

- **进程/线程管理（CPU管理）**：进程线程状态、控制、同步互斥、通信、调度、…
- **存储管理**：分配/回收、地址转换、存储保护、内存扩充、…
- **文件管理**：文件目录、文件操作、磁盘空间、文件存取控制、…
- **设备管理**：设备驱动、分配回收、缓冲技术、…
- **用户接口**：系统命令、编程接口

### 2.2.2 向用户提供各种服务：方便使用

操作系统是各种系统服务的提供者

- 在操作系统之上，从用户角度来看：
  操作系统为用户提供了一组功能强大。方便易用的命令或系统调用
- 典型服务：
  进程的创建、执行；文件和目录操作；`IO`设备的使用；各类统计信息；…

### 2.2.3 对硬件机器的扩展：扩展能力

操作系统是硬件之上的第一层软件，我们使用操作系统将硬件屏蔽，而让操作系统给我们提供操作各类硬件的接口。因为与硬件相关的工作是很复杂和繁琐的。于是操作系统就是对硬件机器的扩展：

- 操作系统在应用程序与硬件之间建立了一个等价的扩展机器（虚拟机器）
- 对硬件抽象，提高可移植性；比底层硬件更容易编程

# 三、操作系统的主要特征

主要特征：并发、共享、虚拟、随机

## 3.1 并发

指处理多个同时性活动的能力。

- 由于并发将可能引起很多问题：活动切换、保护、相互依赖的活动间的同步
- 在计算机系统中同时存在多个程序运行，但`cpu`上：
  - 宏观上：这些程序同时在执行
  - 微观上：任何时刻只有一个程序真正在执行，即这些程序在cpu上是轮流执行的
- 并行：与并发类似，但多指不同程序同时在多个硬件部件上执行，比如多`cpu`系统。

## 3.2 共享

操作系统与多个用户的程序共同使用计算机系统中的资源。
操作系统要对系统资源进行合理的分配和使用，资源在一个时间段内交替被多个进程使用。

- 互斥共享（如打印机）
- 同时共享（如可重入代码、磁盘文件）
- 问题：资源分配难以达到最优化，如何保护资源？

## 3.3 虚拟

- 一个物理实体（如`cpu`）映射为若干个对应的逻辑实体：分时或分空间
- 虚拟是操作系统管理系统资源的重要手段，可提高资源利用率

## 3.4 随机

操作系统必须随时对以不可预测的次序发生的事件进行响应并处理

- 进程的运行速度不可预知
- 难以重现系统在某个时刻的状态（包括运行中的错误）

# 四、典型的操作系统架构

## 4.1 Windows架构





![img](https://upload-images.jianshu.io/upload_images/1925650-38f1544e46aca9ea.png?imageMogr2/auto-orient/strip|imageView2/2/w/1007/format/webp)

3



![img](https://upload-images.jianshu.io/upload_images/1925650-e29631996797eb1d.png?imageMogr2/auto-orient/strip|imageView2/2/w/992/format/webp)

4



![img](https://upload-images.jianshu.io/upload_images/1925650-dcb05d24fea6b6b6.png?imageMogr2/auto-orient/strip|imageView2/2/w/254/format/webp)

5

说明：

以上是

```
Windows
```

架构中一步步抽象的结果。这里不细说。



## 4.2 UNIX架构



![img](https://upload-images.jianshu.io/upload_images/1925650-9b54d80c3cca4037.png?imageMogr2/auto-orient/strip|imageView2/2/w/983/format/webp)

6

## 4.3 Linux架构





![img](https://upload-images.jianshu.io/upload_images/1925650-fa4eb72ce61a566c.png?imageMogr2/auto-orient/strip|imageView2/2/w/868/format/webp)

7

说明：

这里只给出了内核组件。



## 4.4 Android架构



![img](https://upload-images.jianshu.io/upload_images/1925650-1f92a40db82374c1.png?imageMogr2/auto-orient/strip|imageView2/2/w/980/format/webp)

8

# 五、操作系统分类

## 5.1 传统分类

### 5.1.1 操作系统的发展历程

- 操作系统发展是随着计算机硬件技术、应用需求的发展、软件新技术的出现而发展。
  目标：充分利用硬件和提供更好的服务
  发展进程：大型机--->个人计算机--->网络--->移动计算机--->云计算--->泛在计算（物联网）--->机器人
- 分类
  批处理操作系统
  分时系统
  实时操作系统
  个人计算机操作系统
  网络操作系统
  分布式操作系统
  嵌入式操作系统

### 5.1.2 批处理操作系统

- 工作方式
  1、 用户将作业交给系统操作员
  2、 系统操作员将许多用户的作业组成一批作业，输入到计算机系统中，在系统中形成一个自动转接的连续的作业流
  3、 启动操作系统
  4、 系统自动、依次执行每个作业
  5、 由操作员将作业结果交给用户
- 目标
  提高资源利用率，增加作业处理吞吐量
- 作业包括
  用户程序
  数据
  作业说明书（用作业控制语言编写）
- 成批
  通常由若干作业组成，用户提交作业后只能等待处理结果，不能干预作业的执行
- 处理
  对一批作业中的每个作业进行相同的处理：从磁带读入用户作业和编译连接程序，编译连接用户作业以生成可执行程序；启动执行；输出结果
- 问题
  慢速的输入输出处理直接由主机来完成，输入输出时，`cpu`处于等待状态
- 解决方案
  卫星机：完成面向用户的输入输出，中间结果暂存在磁盘上

### 5.1.3 分时操作系统

- 时间片
  操作系统将`cpu`的时间划分为若干个片段，成为时间片。
  - 操作系统以时间片为单位，轮流为每个终端用户服务，每次服务一个时间片
  - 其特点是利用人的错觉，使用户感觉不到计算机在服务其他人
- 目标
  及时响应（依据是响应时间）
- 响应时间
  从终端发出命令到系统给予回答所经历的时间

### 5.1.4 通用操作系统

- 分时系统与批处理系统结合
- 原则：分时优先，批处理在后
  - “前台”：需要频繁交互的作业
  - “后台”：时间性要求不强的作业

### 5.1.5 实时操作系统

- 是指使计算机能及时响应外部事件的请求，在规定的严格时间内完成对该事件的处理，并控制所有实时设备和实时任务协调一致地工作
- 分类
  第一类：实时过程控制（工业控制、航空、军事控制等）
  第二类：实时通信处理（电讯、银行等）
- 目标
  对外部请求在严格时间范围内做出响应
  高可靠性

### 5.1.6 个人计算机操作系统

- 计算机在某一时间内为单用户服务
- 目标
  界面友好，使用方便，丰富的应用软件

### 5.1.7 网络操作系统

- 基于计算机网络：在各种计算机操作系统上按网络体系结构协议标准开发的软件
- 功能
  网络管理，通信，安全，资源共享和各类网络应用
- 目标
  相互通信，资源共享

### 5.1.8 分布式操作系统

- 分布式系统：或以计算机网络为基础，或以多处理器为基础，基本特征是处理分布在不同的计算机上
- 分布式操作系统是一个统一的操作系统，允许若干计算机可相互协作共同完成一项任务。操作系统可将各种系统任务在复试系统中任何处理机上运行，自动实现全系统范围内的任务分配、自动调度、均衡各处理机的工作负载。
- 处理能力增强、速度更快、可靠性强、具有透明性

### 5.1.9 嵌入式操作系统

完成某些特定的任务

## 5.2 另一种分类（TANENBAUM）

- 大型机操作系统
- 服务器操作系统
- 多处理机操作系统
- 个人计算机操作系统
- 掌上计算机操作系统
- 嵌入式操作系统
- 传感器节点操作系统
- 实时操作系统
- 智能卡操作系统



# 一、回顾：操作系统的主要工作

- 程序的执行
   启动程序、执行程序以及程序结束的工作
- 完成与体系结构相关的工作
- 完成应用程序所需的共性任务
   提供各种基本服务，如`IO`、网络等。
- 处理性能、安全、健壮等问题

# 二、处理器状态（模式）

## 2.1 中央处理器（CPU）

1、处理器由运算器、控制器、一些列的寄存器以及高速缓存构成

2、两类寄存器

- 用户可见寄存器
   高级语言编译器通过优化算法并使用之，以减少程序访问内存次数
- 控制和状态寄存器
   用于控制处理器的操作，通常由操作系统代码使用

## 2.2 控制和状态寄存器

- 用于控制处理器的操作
- 在某种特权级别下可以访问、修改
- 常见的控制和状态寄存器
  - 程序计数器（`PC：Program Counter`），记录将要取出的指令的地址
  - 指令寄存器（`IR：Instruction Register`），记录最近取出的指令
  - 程序状态字（`PSW：Program Status Word`），记录处理器的运行状态如条件码、模式、控制位等信息

## 2.3 操作系统的需求：保护

- 从操作系统的特征考虑：并发、共享
   操作系统可能同时运行多个用户程序，这是一个多进程并发的状态，对于用户程序之间某些不需要共享的资源我们需要对其进行保护，保证每个用户程序相对于其他程序的独立性。
- 需要硬件提供基本的运行机制
  - 处理器具有特权级别：能在不同的特权级别运行的不同指令集合
  - 硬件机制可将操作系统与用户程序隔离

## 2.4 处理器的状态

- 现代处理器通常将`CPU`状态设计划分为两种、三种和四种
- 在程序状态字寄存器`PSW`中专门设置一位，根据运行程序对资源和指令的使用权限而设置不同的`CPU`状态。

## 2.5 特权指令和非特权指令

**1、操作系统需要两种CPU状态**

- 内核态（`Kernel Mode`）：运行操作系统
- 用户态（`User Mode`）：运行用户程序

**2、特权指令**
 只能由操作系统使用、用户程序不能使用的指令。如：
 启动`I/O`、内存清零、修改程序状态字、设置时钟、允许/禁止中断、停机

**3、非特权指令**
 用户程序可以使用的指令，同时操作系统也能使用。如：
 控制转移、算术运算、取数指令、访管指令

**4、实例：X86系列处理器**

- `x86`支持四个处理器特权级别：`R0、R1、R2、R3`
   特权能力依次降低，其中`R0`相当于内核态，`R3`相当于用户态，`R1、R2`则介于两者之间。不同级别能够运行的指令集合大小不同。
- 目前大多数基于`x86`处理器的操作系统一般只是使用`R0`和`R3`这两个特权级别。

## 2.6 CPU状态之间的转换

- 用户态 ---> 内核态
   唯一途径：中断、异常、陷入机制（即系统调用）
- 内核态 ---> 用户态
   途径：设置程序状态字`PSW`
- 注意一条特殊的指令：陷入指令（又称访管指令，访问管理模式），提供给用户程序的接口，用于调用操作系统的功能（服务），例如：`int, trap(陷入), syscall, sysenter/sysexit`。

# 三、中断与异常机制

中断/异常对于操作系统的重要性就好比汽车的发动机，可以说操作系统是由“中断驱动”或“事件驱动”的。其主要作用有：

- 及时处理设备发来的中断请求
- 可使操作系统捕获用户程序提出的服务请求
- 防止用户程序执行过程中的破坏性活动等等

## 3.1 概念

-  `CPU`对系统发生的某个事件做出的一种反应，或者说事件的发生改变了处理器的控制流。
-  `CPU`暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点，继续执行被打断的程序。其特点是：随机发生、自动处理、可恢复。

## 3.2 为什么引入中断与异常

- 中断的引入：为了支持`CPU`和设备之间的并行操作
   当`CPU`启动设备进行输入/输出后，设备便可以独立工作，`CPU`转去处理与此次输入/输出无关的事情；当设备完成输入/输出后，通过向`CPU`发送中断报告此次输入/输出的结果，让`CPU`决定如何处理以后的事情。
- 异常的引入：表示`CPU`执行指令时本身出现的问题
   如算术溢出、除零、取数时的奇偶错误，访问存储地址越界或执行了“陷入指令”等，这时硬件改变了`CPU`当前的执行流程，转到相应的错误程序或异常处理程序或执行系统调用。

## 3.3 事件

事件分为两类：

- 中断（外中断），如`I/O`中断、时钟中断、硬件故障。中断表示外部事件，是正在运行的程序所不期望的。
- 异常（内中断），如系统调用、页故障/页错误、保护性异常、断点指令、其他程序性异常（如算术溢出等）。这是由正在执行的指令自己引发的。

## 3.4 小结

| 类别                | 原因                        | 异步/同步 | 返回行为             |
| ------------------- | --------------------------- | --------- | -------------------- |
| 中断（`Interrupt`） | 来自`I/O`设备、其他硬件部件 | 异步      | 总是返回到下一条指令 |
| 陷入（`Trap`）      | 有意识安排的                | 同步      | 返回到下一条指令     |
| 故障（`Fault`）     | 可恢复的错误                | 同步      | 返回到当前指令       |
| 终止（`Abort`）     | 不可恢复的错误              | 同步      | 不会返回             |

## 3.5 中断/异常机制的工作原理

- 中断/异常机制是现代计算机系统的核心机制之一
   硬件和软件相互配合而使计算机系统得以充分发挥能力
- 硬件做什么：中断/异常响应
   捕获中断源发出的中断/异常请求，以一定方式响应，将处理器控制权交给特定的处理程序。
- 软件做什么：中断/异常处理程序
   识别中断/异常类型并完成相应的处理

### 3.5.1 中断响应

中断响应中发现中断、接收中断的过程由中断硬件部件完成，在处理器控制部件中设有中断寄存器。其过程如下：




![img](https:////upload-images.jianshu.io/upload_images/1925650-c1d8d2a715239b78.png?imageMogr2/auto-orient/strip|imageView2/2/w/715/format/webp)

1

说明：

检查是否有中断信号是在每条指令之间进行的。这里的中断向量表是一个软硬件结合的数据结构。通过中断码去查中断向量表找到中断处理程序地址。



**中断向量表**

- 中断向量
   一个内存单元，存放中断处理程序入口地址和程序运行时所需的处理机状态字。中断向量表由若干中断向量组成。

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-731ce1170fc7efbb.png?imageMogr2/auto-orient/strip|imageView2/2/w/434/format/webp)

  2

  事先编写好中断处理程序，然后由操作系统填写中断向量表，当中断发生时会按照执行流程按中断号/异常类型的不同，通过中断向量表转移控制权给中断处理程序。

**例：Linux中的中断向量表**




![img](https:////upload-images.jianshu.io/upload_images/1925650-cee53c59dbc5e1f6.png?imageMogr2/auto-orient/strip|imageView2/2/w/618/format/webp)

3



### 3.5.2 中断响应过程





![img](https:////upload-images.jianshu.io/upload_images/1925650-f9aecf7bf3c9071e.png?imageMogr2/auto-orient/strip|imageView2/2/w/696/format/webp)

4

说明：

从最右边可以看到一个最简略的中断响应过程。



## 3.6 中断处理程序

以上都是中断处理的硬件部分内容，下面看软件部分内容。

- 在设计操作系统时，为每一类中断/异常事件编好相应的处理程序，并设置好中断向量表。
- 系统运行时若响应中断，中断硬件部件将`CPU`控制权交给了中断处理程序：
  - 保护相关寄存器信息：在刚才的图中硬件部件会保存一些关键信息，而其他的一些信息则是由软件进行保护的。
  - 分析中断/异常的具体原因
  - 执行对应的处理功能
  - 恢复现场，返回被事件打断的程序。

## 3.7 小结

软件提前设置好，硬件部件来执行。以设备输入输出为例来回顾一下中断运行机制：

- 打印机给`CPU`发中断信号
- **CPU**处理完当前指令后检测到中断，判断出中断来源并向相关设备发出确认信号，这是由硬件部件来完成的。
- **CPU**开始为软件处理中断做准备：
  - 处理器状态切换到内核天
  - 在系统栈中保存被中断程序的重要上下文环境，主要是程序计数器`PC`、程序状态字`PSW` 
- **CPU**根据中断码查询中断向量表，获得与该中断相关的处理程序的入口地址，并将`PC`设置成地址，新的指令周期开始时，`CPU`控制转移到中断处理程序。这是由硬件来完成的。
- 中断处理程序开始工作
  - 在系统栈中保存现场信息
  - 检查`I/O`设备的状态信息，操作`I/O`设备或者在设备和内存之间传送数据等等。这是由软件来完成的。
- 中断处理结束时，`CPU`检测到中断返回指令，从系统栈中恢复被中断程序的上下文环境，`CPU`状态恢复成原来的状态，`PSW`和`PC`恢复成中断前的值，`CPU`开始一个新的指令周期。这是由硬件来完成的。

**例：I/O中断处理程序**
 中断处理程序都做了什么：

- **I/O**操作正常结束
  - 若有程序正等待此次**I/O**的结果，则应将其唤醒
  - 若要继续**I/O**操作，需要准备好数据重新启动**I/O** 
- **I/O**出现错误
  - 需要重新执行失败的**I/O**操作
  - 重试次数有上限，达到时系统将判定硬件故障

**例：x86对中断/异常的支持**
 1、中断
 由硬件信号引发的，分为可屏蔽和不可屏蔽中断

2、异常

- 由指令执行引发的，比如除零异常
-  **80x86**处理器发布了大约`20`中不同的异常
- 对于某些异常，`CPU`会在执行异常处理程序之前产生硬件出错码，并压入内核态堆栈

3、系统调用
 异常的一种，用户态到内核态的唯一入口

4、中断控制器（`PIC`或`APIC`）
 负责将硬件的中断信号转换为中断向量，并引发`CPU`中断

5、实模式：中断向量表（`Interrupt Vector`）
 存放中断服务程序的入口地址：

- 入口地址=段地址左移四位+偏移地址
- 不支持`CPU`运行状态切换
- 中断处理与一般的过程调用相似

6、保护模式：中断描述符表（`Interrupt Descriptor Table`）
 现在一般都是工作在保护模式下，此中模式下采用门（`gate`）描述符数据结构表示中断向量，同时中断描述符表和中断向量表其实本质上是一样的。

7、中断向量表/中断描述符表

- 四种类型门描述符 
  - 任务门（`Task Gate`）
  - 中断门（`Interrupt Gate`）：1、给出段选择符（`Segment Selector`）、中断/异常程序的段内偏移量（`Offset`）；2、通过中断门后系统自动禁止中断
  - 陷阱门（`Trap Gate`）
     与中断门类似，但通过陷阱门后系统不会自动禁止中断
  - 调用门（`Call Gate`）

一般我们只用中断门和陷阱门。

- 一些具体的数据结构和响应过程

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-3b3d16b049bbad75.png?imageMogr2/auto-orient/strip|imageView2/2/w/748/format/webp)

  5

  说明：

  通过中断描述符表寄存器

  ```
  IDTR
  ```

  找到中断描述符表

  ```
  IDT
  ```

  地址，中断描述符表的每一个数据为中断描述符或将中断向量，其格式如图。通过中断描述符可以得到一个段选择符，可以看到有一个索引、特权级和

  ```
  GDT/LDT
  ```

  ，其中

  ```
  GDT
  ```

  表示全局描述符表，

  ```
  LDT
  ```

  表示局部描述符表。通过全局描述符表寄存器

  ```
  GDTR
  ```

  在

  ```
  GDT
  ```

  表中查找得到一个段描述符，重要的是得到了一个段基址，然后加上中断描述符中的段偏移就得到了中断服务程序的入口地址。其具体过程如下： 

  - 确定与中断或异常关联的向量`i` 

  - 通过`IDTR`寄存器找到`IDT`表，获得中断描述符（表中的第`i`项）

  - 从`GDTR`寄存器获得`GDT`的地址；结合中断描述符中的段选择符，在`GDT`表获取对应的段描述符；从该段描述符中得到中断或异常处理程序所在的段基址

  - 特权级检查

  - 检查是否发生了特权级的变化，如果是，则进行堆栈切换（必须使用与新的特权级相关的栈）

  - 硬件压栈，保存上下文环境；如果异常产生了硬件出错码，也将它保存在栈中

  - 如果是中断，清掉`IF`位

  - 通过中断描述符中的段内偏移和段描述符中的基地址，找到中断/异常处理程序的入口地址，执行其第一条指令。

    

    ![img](https:////upload-images.jianshu.io/upload_images/1925650-fcc7212bf54eb12c.png?imageMogr2/auto-orient/strip|imageView2/2/w/732/format/webp)

# 4、进程/线程模型1（操作系统笔记）

![img](https://upload.jianshu.io/users/upload_avatars/1925650/7a95dfb3c842.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[yjaal](https://www.jianshu.com/u/9231f33f0db3)关注

0.1962016.12.15 10:57:40字数 1,950阅读 428

# 一、进程的基本概念

## 1.1 多道程序设计

基本思想是允许多个程序同时进入内存并运行，提高`CPU`的利用率，其目的是为了提高系统效率。



![img](https://upload-images.jianshu.io/upload_images/1925650-632d0d5d47e4209f.png?imageMogr2/auto-orient/strip|imageView2/2/w/881/format/webp)

1

说明：

在第一幅图中在内存中有四个程序，这四个程序是串行执行的，因为这里只有一个程序计数器。当有了多道程序技术之后就得到了第二幅图中所示的场景，每个程序各自独立的占用一个逻辑程序计数器，这样就达到了一种并发执行的效果，我们从第三幅图中可以看到多个程序是轮流执行的。



## 1.2 并发环境与并发程序

并发环境就是指一段时间间隔内，单处理器上有两个或两个以上的程序同时处于开始运行但尚未结束的状态，并且次序不是事先确定的。而在并发环境下执行的程序就是并发程序。

## 1.3 进程的定义

定义：进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位。

- 进程是程序的一次执行过程，一个程序执行多次那是不同的进程
- 是正在运行的程序的抽象，或者说是对`CPU`的一个抽象。
- 将一个`CPU`变换成多个虚拟的`CPU`
- 系统资源以进程为单位分配，如内存、文件等，操作系统为每个独立的进程分配了独立的地址空间。
- 操作系统将`CPU`调度给需要的进程，即将`CPU`的控制权交给某个进程就称为调度。

## 1.4 进程控制块PCB

- 进程控制块又称进程描述符或进程属性
- 操作用于管理控制进程的一个专门的数据结构
- 记录进程的各种属性，描述进程的动态变化过程
- **PCB**是系统感知进程存在的唯一标志：进程与`PCB`是一一对应的
- 进程表：所有进程的`PCB`集合。进程表的大小往往是固定的，这也就决定了一个操作系统最多支持多少个进程，有时我们称为系统支持的并发度。

### 1.4.1 PCB中需要保存的信息

- 1、进程描述信息
  - 进程标识符（`process id`），这个标识是唯一的，通常是一个整数
  - 进程名，通常基于可执行文件名，这是不唯一的
  - 用户标识符（`user id`）
  - 进程组关系
- 2、进程控制信息
  - 当前状态
  - 优先级
  - 代码执行入口地址
  - 程序的磁盘地址
  - 运行统计信息（执行时间、页面调度）
  - 进程间同步和通信
  - 进程的队列指针
  - 进程的消息队列指针
- 3、所拥有的资源和使用情况
  - 虚拟地址空间的使用状况
  - 打开的文件列表
- 4、CPU线程信息
  这是当`CPU`不运行的时候操作系统需要把一些重要的信息记录下来
  - 寄存器值（通用寄存器、程序计数器`PC`、程序状态字`PSW`、栈指针）
  - 指向该进程页表的指针

### 1.4.2 换个角度看PCB的内容





![img](https://upload-images.jianshu.io/upload_images/1925650-26a941892c363654.png?imageMogr2/auto-orient/strip|imageView2/2/w/445/format/webp)

2

说明：

从上图中可以看到第一列是和进程管理相关的字段，第二列是存储管理的字段，第三列是文件管理的字段。



# 二、进程状态及状态转换

## 2.1 进程的三种基本状态

即运行态、就绪态、等待态。

- 运行态：占用`CPU`，并在`CPU`上运行

- 就绪态：已经具备运行条件，但由于没有空闲`CPU`，而暂时不能运行

- 等待态：因等待某一事件而暂时不能运行，如等待读盘结果。又称为阻塞态、封锁态、睡眠态。其转换过程如下：

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-1a083eb326a7f1b3.png?imageMogr2/auto-orient/strip|imageView2/2/w/892/format/webp)

  3

## 2.2 进程的其他状态

- 创建态
  - 已完成创建一个进程所必要的工作，如`PID、PCB`
  - 但尚未同意执行该进程，因为资源有限
- 终止态
  - 终止执行后，进程进入该状态
  - 可完成一些数据统计工作
  - 资源回收
- 挂起态
  - 用于调节负载
  - 进程不占用内存空间，其进程映像交换到磁盘上

## 2.3 五状态模型



![img](https://upload-images.jianshu.io/upload_images/1925650-587ef42fc2950193.png?imageMogr2/auto-orient/strip|imageView2/2/w/840/format/webp)

4

## 2.4 七状态模型



![img](https://upload-images.jianshu.io/upload_images/1925650-0c3172fd8b1a3825.png?imageMogr2/auto-orient/strip|imageView2/2/w/752/format/webp)

5

## 2.5 Linux状态转换示意图





![img](https://upload-images.jianshu.io/upload_images/1925650-2db4f47c4baabfa5.png?imageMogr2/auto-orient/strip|imageView2/2/w/655/format/webp)

6

说明：

这里使用

```
fork()
```

创建一个进程。浅度睡眠和深度睡眠不同在于前者在睡眠时会接收信号，而后者则不会。正在运行的程序可能因为调试断点可能出现一个暂停的状态。



# 三、进程队列

- 操作系统为每一类进程建立一个或多个队列

- 队列元素为`PCB`

- 伴随进程状态的改变，其

  ```
  PCB
  ```

  从一个队列进入另一个队列

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-569a0bfd8c73d4fd.png?imageMogr2/auto-orient/strip|imageView2/2/w/697/format/webp)

  7

  说明：

  真实情况下，就绪态也是排多个队列。而等待态由于各自产生的原因（事件）不同而排不同的队列。

## 3.1 五状态进程模型的队列模型



![img](https://upload-images.jianshu.io/upload_images/1925650-ccc6fd177f467cee.png?imageMogr2/auto-orient/strip|imageView2/2/w/542/format/webp)

8

# 四、进程控制

进程控制操作完成进程各状态之间的转换，由具有特定功能的原语（其实就是程序，只是这些程序不许与被中断）完成。关于进程控制的原语如下：

- 进程创建原语
- 进程撤销原语
- 阻塞原语
- 唤醒原语
- 激活原语
- 改变进程优先级

**原语：**完成某种特定功能的一段程序，具有不可分割性或不可中断性，即原语的执行必须是连续的，在执行过程中不允许被中断。又称原子操作。

## 4.1 进程的创建

- 给新进程分配一个唯一标识以及进程控制块（没有被使用的）
- 为进程分配独立地址空间
- 初始化进程控制块：设置默认值（如状态为`New`...）
- 设置相应地队列指针。如：把新进程加到就绪队列链表中
- 主要操作是`UNIX`中：`fork/exec`，`Windows`中：`CreateProcess`

## 4.2 进程的撤销

也就是结束进程，主要完成的工作：

- 回收进程所占用的资源，如关闭打开的文件、断开网络连接、回收分配的内存等
- 撤销该进程的`PCB`
- 在`UNIX`中使用：`exit`，`Windows`中：`TerminateProcess`

## 4.3 进程阻塞

处于运行状态的进程，在其运行过程中期待某一事件发生，如等待键盘输入、等待磁盘数据传输完成、等待其他进程发送消息。当被等待的事件未发生时，由进程自己执行阻塞原语，使自己由运行态变为阻塞态。在`UNIX`中我们使用`wait`，在`Windows`中使用`WaitForSingleObject`。

## 4.4 UNIX的几个进程控制操作

- **fork()** 通过复制调用进程来建立新的进程，是最基本的进程建立过程。也就是通过复制父进程来创建子进程。
- **exec()** 包括一些列系统调用，它们都是通过用一段新的程序代码覆盖原来的地址空间，实现进程代码的转换
- **wait()** 提供初级进程同步操作，能使一个进程等待另一个进程的结束
- **exit()** 用来终止一个进程的运行

**UNIX中fork()实现：**

- 为子进程分配一个空闲的进程描述符，即`PCB`，在`UNIX`中又叫`proc`结构

- 分配给子进程唯一标识`pid`

- 以一次一页的方式复制父进程的地址空间，这是一个无用功，因为创建子进程就是为了让子进程完成与父进程不同的工作，所以父进程的很多内容其实子进程是不需要的。于是在`Linux`中采用了写复制技术`COW`加快创建进程。

- 从父进程处共享资源，如打开的文件和当前工作目录等

- 将子进程的状态设置为就绪，插入到就绪队列

- 对子进程返回标识符`0`

- 向父进程返回子进程的

  ```
  pid
  ```

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-79900989cfdc25c9.png?imageMogr2/auto-orient/strip|imageView2/2/w/717/format/webp)


    5、进程/线程模型2（操作系统笔记）

  ![img](https://upload.jianshu.io/users/upload_avatars/1925650/7a95dfb3c842.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

  [yjaal](https://www.jianshu.com/u/9231f33f0db3)关注

  0.1762016.12.15 11:52:41字数 1,407阅读 204

  # 五、深入理解进程概念

  ## 5.1 进程的分类

  - 1、系统进程/用户进程
    这里系统进程的优先级要高
  - 2、前台进程/后台进程
    用户一般只和前台进程交互。
  - 3、`CPU`密集型进程/`IO`密集型进程

  ## 5.2 进程层次结构

  - **UNIX**中是一个进程家族树的概念：`init`为根进程。于是如果某一个进程结束了，那么其子孙进程都必须结束。
  - **Windows**中的所有进程的地位都是相同的。

  ## 5.3 进程和程序的区别

  - 进程更能准确刻画并发，而程序不能
  - 程序是静态的，进程是动态的
  - 进程有生命周期的，有诞生有消亡，是短暂的；而程序是相对长久的
  - 一个程序可对应多个进程
  - 进程具有创建其他进程的功能

  ## 5.4 进程的地址空间

  操作系统为每个进程分配了一个地址空间。这里我们看一个例子：

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-a56bfb3130ea240e.png?imageMogr2/auto-orient/strip|imageView2/2/w/484/format/webp)

  1

  这个程序我们从命令行中输入数据，比如：

  ```undefined
  myval 7
  myval 8
  ```

  此时我们会发现虽然进程不同，但是打印出来的地址确实一样的。这里我们从进程地址空间来分析：

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-d39dcdb74ac07572.png?imageMogr2/auto-orient/strip|imageView2/2/w/687/format/webp)

  2

  说明：

  上面的两个进程都有这样一个地址空间，也就是说这两个进程是在不同的地址空间上的相同的位置，所以虽然地址是一样的，但是实际上在实际内存中的地址是不一样的。

  

  ## 5.5 进程映像

  对进程执行活动全过程的静态描述（快照）。由进程地址空间内容、硬件寄存器内容及与该进程相关的内核数据结构、内核栈组成

  - 与用户相关：进程地址空间（代码段、数据段、堆和栈、共享栈等）
  - 与寄存器相关：程序计数器、指令寄存器、程序状态寄存器、栈指针、通用寄存器等的值
  - 与内核相关：
    - 静态部分：`PCB`及各种资源数据结构
    - 动态部分：内核栈（不同进程在进入内核后使用不同的内核栈）

  ## 5.6 上下文切换

  - 将`CPU`硬件状态从一个进程换到另一个进程的过程称为上下文切换，其实就是运行环境的切换。
  - 进程运行时，其硬件状态保存在`CPU`上的寄存器中。寄存器有：程序计数器、程序状态寄存器、栈指针、通用寄存器、其他控制寄存器的值
  - 进程不运行时，这些寄存器的值保存在进程控制块中；当操作系统要运行一个新的进程时，将进程控制块中相关值送到对应的寄存器中。

  # 六、线程

  ## 6.1 线程的引入

  引入线程有三个理由：

  - 应用的需要
  - 开销的考虑
  - 性能的考虑

  ### 6.1.1 应用的需要

  我们看一个例子，一个`web`服务器的工作方式：

  - 从客户端接收网页请求
  - 从磁盘上检索相关的网页，读入内存（此时进程是停止的，直到读取完毕）
  - 将网页返回给对应的客户端

  可以看到每次从磁盘读取的时候进程都是暂停的，这样会导致性能低下。那如何提高服务器的工作效率？通常情况下是使用网页缓存的方式解决。如果没有线程的情况下的两种解决方案：

  - 一个服务进程
    这种情况下也是一种顺序编程，虽然采用了缓存机制，但是性能同样不高。而如果设置多个进程，这多个进程之间又是相互独立的，有独立的地址空间，所以不能共享信息。
  - 有限状态机
    这种方式编程模型复杂，采用非阻塞的`I/O`。

  **多线程的解决方式**

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-e5abce99fb79a3da.png?imageMogr2/auto-orient/strip|imageView2/2/w/634/format/webp)

  1

  说明：

  这是一个多线程的

  ```
  web
  ```

  服务器的工作方式，首先读取客户端的请求，之后由分派线程将各个任务分派给工作线程，同样这里还是采用了网页缓存。于是我们可以看到一个

  ```
  web
  ```

  服务器的实现有三种方式：

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-c7e797d23b952a9d.png?imageMogr2/auto-orient/strip|imageView2/2/w/601/format/webp)

  2

  

  ### 6.1.2 开销的考虑

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-af85b40325655f2e.png?imageMogr2/auto-orient/strip|imageView2/2/w/695/format/webp)

  3

  ### 6.1.3 性能的考虑

  如果有多个处理器的话，一个进程就会有多个线程同时在执行了，这样可以极大的提高运行 性能。

  ## 6.2 线程的基本概念

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-687ed9bd8bdfa940.png?imageMogr2/auto-orient/strip|imageView2/2/w/684/format/webp)

  4

  **线程的属性**

  - 有标识符`ID`
  - 有状态及状态转换`-->`需要提供一些操作
  - 不运行时需要保存的上下文（程序计数器等寄存器）
  - 有自己的栈和栈指针
  - 共享所在进程的地址空间和其他资源
  - 创建、撤销另一个线程（程序开始是以一个单线程方式运行的）

  ## 6.3 线程机制的实现

  一般有三种实现机制：

  - 用户级线程
  - 核心级线程
  - 混合（两者结合）方法

  ### 6.3.1 用户级线程

  

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-082935818d310505.png?imageMogr2/auto-orient/strip|imageView2/2/w/695/format/webp)

  5

  说明：

  可以看到线程是有运行时系统管理的，在内核中只有进程表。典型例子就是

  ```
  UNIX：
  ```

  POSIX线程库--PTHREAD

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-8269d39385854c28.png?imageMogr2/auto-orient/strip|imageView2/2/w/622/format/webp)

  6

  

  **小结：**
  有点：

  - 线程切换快
  - 调度算法是应用程序特定的
  - 用户级线程可运行在任何操作系统上（只需要实现线程库）

  缺点：

  - 内核只将处理器分配给进程，同一进程中的两个线程不能同时运行于两个处理器上
  - 大多数系统调用是阻塞的，因此，由于内核阻塞进程，故进程中所有线程也被阻塞。（可以在调用之前判断进行解决，如果是阻塞线程，那么就换其他线程）

  ### 6.3.2 核心级线程

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-013e6632c96b148c.png?imageMogr2/auto-orient/strip|imageView2/2/w/683/format/webp)

  7

  ### 6.3.3 混合模型

  - 线程创建在用户空间完成
  - 线程调度等在核心态完成
  - 例子如`Solaris`操作系统

# 一、CPU调度的相关概念

## 1.1 cpu调度

其任务是控制、协调进程对`cpu`的竞争，即按一定的调度算法从就绪队列中选择一个进程，把`cpu`的使用权交给被选中的进程。如果没有就绪进程，系统会安排一个系统空闲进程或`idle`进程进入`cpu`运行。

## 1.2 系统场景

-  `N`个进程就绪、等待上`cpu`运行
-  `M`个`cpu`， `M>=1` 
- 需要决策：给哪个进程分配哪一个`cpu`？

## 1.3 cpu调度要解决的三个问题

- 1、按什么原则选择下一个要执行的进程：调度算法
- 2、何时进行选择：调度时机
- 3、如何让被选中的进程上`cpu`中运行：调度过程（进程的上下文切换）

### 1.3.1 调度的时机

**cpu**在运行时会发生很多事件：

- 创建、唤醒、推出等进程控制操作
- 进程等待`I/O`、`I/O`中断
- 时钟中断，如：时间片用完、计时器到时
- 进程执行过程中出现`abort`异常

这些事件发生后-->当前运行的进程暂停执行-->硬件机制响应后-->进入操作系统，处理相应的事件-->结束处理后：某些进程的状态会发生变化，也可能又创建了一些新的进程-->就绪队列改变了-->需要进程调度根据预设的调度算法从就绪队列选择一个进程

**进程调度的时机有四个：**

- 进程正常终止或由于某种错误终止
- 新进程创建或一个等待进程变成就绪
- 当一个进程从运行态进入阻塞态
- 当一个进程从运行态变为就绪态

总的来说调度的时机一般就是内核对中断、异常、系统调用处理后返回到用户态时。

### 1.3.2 调度过程（进程切换）

- 进程调度程序从就绪队列选择了要运行的进程：这个进程可以是刚刚被暂停执行的进程，也可能是另一个新的进程。
- 进程切换：是指一个进程让出处理器，由另一个进程占用处理器的过程

**进程切换一般有两部分工作：**

- 切换全局页目录以加载一个新的地址空间
- 切换内核栈和硬件上下文，其中硬件上下文包括了内核执行新进程需要的全部信息，如`cpu`相关寄存器。

总的来说，切换进程包括了对原来运行进程各种状态的保存和对新的进程各种状态的恢复。

**上下文切换具体步骤：**
 场景：进程`A`下`cpu`，进程`B`上`cpu`。

- 保存进程`A`的上下文环境（程序计数器、程序状态字、其他寄存器......）
- 用新状态和其他相关信息更新进程`A`的`PCB` 
- 把进程`A`移至合适的队列（就绪、阻塞......）
- 将进程`B`的状态设置为运行态
- 从进程`B`的`PCB`中恢复上下文（程序计数器、程序状态字、其他寄存器......）

**上下文切换的开销：**

- 直接开销：内核完成切换所用的`cpu`时间
  - 保存和恢复寄存器....
  - 切换地址空间（相关指令开销较大）
- 间接开销
  - 高速缓存（`Cache`）、缓冲区缓存（`Buffer Cache`）和`TLB`（`Translation Lookup Buffer`）失效。

### 1.3.3 cpu调度算法的设计

**什么情况下需要仔细斟酌调度算法？**

- 批处理系统-->多道程序设计系统-->批处理与分时的混合系统-->个人计算机-->网路服务器。
   从用户角度和系统角度对调度算法的要求是不一样的：

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-e20c4d771935b917.png?imageMogr2/auto-orient/strip|imageView2/2/w/647/format/webp)

  1

**调度算法的衡量指标**

- 吞吐量：每单位时间完成的进程数目
- 周转时间：每个进程提出请求到运行完成的时间
- 响应时间：从提出请求到第一次回应的时间
- 其他 
  -  `cpu`利用率：`cpu`做有效工作的时间比例
  - 等待时间：每个进程在就绪队列中等待的时间

# 二、设计调度算法前的要点

- 进程控制块中需要记录哪些与`cpu`调度有关的信息
- 进程优先级就绪队列的组织
- 抢占式调度与非抢占式调度
-  `I/O`密集型与`cpu`密集型进程
- 时间片

## 2.1 进程优先级（数）

优先级和优先数是不同的，优先级表现了进程的重要性和紧迫性，优先数实际上是一个数值，反映了某个优先级。

- 静态优先级
   进程创建时指定，运行过程中不再改变
- 动态优先级
   进程创建时指定了一个优先级，运行过程中可以动态变化。如：等待时间较长的进程可提升其优先级。

## 2.2 进程就绪队列组织

- 按优先级排队方式
  

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-6c4440865de36c83.png?imageMogr2/auto-orient/strip|imageView2/2/w/678/format/webp)

  2

  说明：

  创建多个进程后按照不同的优先级进行排列，

  ```
  cpu
  ```

  调度优先级较高的进程进行执行。

  

- 另一种排队方式
  

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-3a9e653cfceb5d46.png?imageMogr2/auto-orient/strip|imageView2/2/w/692/format/webp)

  3

  说明：

  所有进程创建之后都进入到第一级就绪队列，随着进程的运行，可能会降低某些进程的优先级，如某些进程的时间片用完了，那么就会将其降级。

  

## 2.3 占用cpu的方式

通常有两种方式，即抢占式和非抢占式。

- 抢占式（可剥夺式）
   当有比正在运行的进程优先级更高的进程就绪时，系统可强行剥夺正在运行进程的`cpu`，提供给具有更高优先级的进程使用。
- 不可抢占式
   某一进程被调度运行后，除非由于它自身的原因不能运行，否则一直运行下去。

## 2.4 I/O密集型与cpu密集型进程

按进程执行过程中的行为划分：

- `I/O`密集型或`I/O`型（`I/O-bound`）
   频繁的进程`I/O`，通常会花费很多时间等待`I/O`操作的完成。
- `cpu`密集型或`cpu`型或计算密集型（`cpu-bound`）
   需要大量的`cpu`时间进行计算

## 2.5 时间片（Time slice或quantum）

一个时间段，分配给调度上`cpu`的进程，确定了允许该进程运行的时间长度。那么如何选择时间片？有一下需要考虑的因素：

- 进程切换的开销
- 对响应时间的要求
- 就绪进程个数
-  `cpu`能力
- 进程的行为

# 三、批处理系统中常用的调度算法

- 先来先服务（`FCFS-First Come First Serve`）
- 最短作业优先（`SJF-Shortest Job First`）
- 最短剩余时间优先（`FRTN-Shortest Remaining Time Next`）
- 最高响应比优先（`HRRN-Highest Response Ratio Next`）

在批处理系统中调度算法主要考虑的是吞吐量、周转时间、`cpu`、公平/平衡。

## 3.1 先来先服务算法

- 按照进程就绪的先后顺序使用`cpu` 
- 非抢占式
- 优点 
  - 公平
  - 实现简单
- 缺点
   长进程后面的短进程需要等很长时间，不利于用户体验



![img](https:////upload-images.jianshu.io/upload_images/1925650-f4ac8b29cf27a215.png?imageMogr2/auto-orient/strip|imageView2/2/w/730/format/webp)

4

那能否改变调度顺序来提供效率呢？



![img](https:////upload-images.jianshu.io/upload_images/1925650-3df992a299f22572.png?imageMogr2/auto-orient/strip|imageView2/2/w/730/format/webp)

5

## 3.2 短作业优先SJF和最短剩余时间优先

- 具有最短完成时间的进程优先执行
- 非抢占式

如果我们将短作业优先进行改进，改进为抢占式，这就是最短剩余时间优先算法了，即一个新就绪的进程比当前运行进程具有更短的完成时间，系统抢占当前进程，选择新就绪的进程执行。例如：



![img](https:////upload-images.jianshu.io/upload_images/1925650-00a17dd424c81f83.png?imageMogr2/auto-orient/strip|imageView2/2/w/605/format/webp)

6

**优缺点：**

- 最短的平均周转时间
   在所有进程同时可运行时，采用`SJF`调度算法可以得到最短的平均周转时间。
- 不公平
   源源不断的短任务到来，可能使长的任务长时间得不到运行，导致产生“饥饿”现象。

## 3.3 最高响应比优先

- 是一个综合的算法
- 调度时，首先计算每个进程的响应比`R`（一个参数）；之后，总是选择`R`最高的进程执行。
- 响应比 = 周转时间/处理时间 = （处理时间+等待时间）/处理时间 = 1+（等待时间/处理时间）

# 四、交互式系统的调度算法

- 轮转调度（`RR-Round Robin`）
- 最高优先级调度（`HPF-Highest Priority First`）
- 多级反馈队列（`Multiple feedback queue`）
- 最短进程优先（`Shortest Process Next`）

## 4.1 时间片轮转调度算法





![img](https:////upload-images.jianshu.io/upload_images/1925650-29350e5e27b48be5.png?imageMogr2/auto-orient/strip|imageView2/2/w/572/format/webp)

7

说明：

首先当前进程是

```
B
```

，当

```
B
```

的时间片用完后就被放在队列的尾部，此时当前进程就是

```
F
```

。



- 目标
   为短任务改善平均响应时间
- 解决问题的思路 
  - 周期性的切换
  - 每个进程分配一个时间片
  - 时钟中断-->轮转

**如何选择合适的时间片？**

- 太长：大于典型的交互时间

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-7c06ca1ef383d463.png?imageMogr2/auto-orient/strip|imageView2/2/w/279/format/webp)

  8

  就是进程所需时间小于时间片，那么就会剩余一段时间。如果大部分进程都像这样，那么此算法就退化成了先来先服务算法。同时会延长段进程的响应时间。

- 太短：小于典型的交互时间

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-3364dd633c1d0e8b.png?imageMogr2/auto-orient/strip|imageView2/2/w/489/format/webp)

  9

  这种情况下进程的响应时间也会延长。同时不断的切换也会浪费时间。

**优缺点：**

- 公平

- 有利于交互式计算，响应时间快

- 由于进程切换，时间片轮转算法要花费较高的开销

- 对不同大小的进程是有利的，但是对相同大小的进程呢？例子如下：

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-322cf825e30d8358.png?imageMogr2/auto-orient/strip|imageView2/2/w/512/format/webp)

  10

小结：此算法往往不区分是`I/O`密集型还是`cpu`密集型，所以会给I/O```密集型进程带来一下不公平，下面看虚拟轮转算法。

**虚拟轮转法：**




![img](https:////upload-images.jianshu.io/upload_images/1925650-3fe445b3af130b9c.png?imageMogr2/auto-orient/strip|imageView2/2/w/588/format/webp)

11

说明：

按照之前的时间片算法，对于

```
I/O
```

型进程时是不公平的，因为它总是用不完时间片，但是调度之后都要重新进入就绪队列进行排队，这样显然不公平。于是就设计了上图的调度算法。为

```
I/O
```

型进程专门设计了一个辅助队列，当一个

```
I/O
```

进程运行完之后不进入就绪队列，而是进入辅助队列，同时

```
cpu
```

也优先去调度辅助队列中的进程，知道辅助队列中为空，才去就绪队列中选择进程。



## 4.2 最高优先级调度算法

- 选择优先级最高的进程投入运行
- 通常：系统进程优先级高于用户进程；前台进程优先级高于后台进程；操作系统更偏好`I/O`型进程。
- 优先级可以是静态的，也可以动态调整，优先数可以决定优先级
- 就绪队列可以按照优先级组织
- 实现简单，但是不公平

**优先级反转问题：**
 主要出现在基于优先级的抢占式调度算法中。表现为，一个低优先级进程持有一个高优先级进程所需要的资源，使得高优先级进程等待低优先级进程运行。例如：




![img](https:////upload-images.jianshu.io/upload_images/1925650-5a4eb15ab07646c4.png?imageMogr2/auto-orient/strip|imageView2/2/w/538/format/webp)

12



- 影响
   是一个系统错误；高优先级进程停滞不前，导致系统性能降低。
- 解决方案
   设置优先级上限：凡是进入临界区的进程的优先级都是最高的
   优先级继承：低优先级继承高优先级进程的优先级
   使用中断禁止：凡是进入临界区的进程都不再响应中断，直到出了临界区

# 五、多级反馈队列调度算法

- 是`UNIX`的一个分支`BSD5.3`版所采用的调度算法
- 是一个综合调度算法（折中权衡）
- 设置多个就绪队列，第一级队列优先级最高
- 给不同就绪队列的进程分配长度不同的时间片，第一级队列时间片最小；随着队列优先级别的降低，时间片增大。
- 当第一级队列为空时，就在第二级队列调度，以此类推
- 各级队列按照时间片轮转方式进行调度
- 当一个新创建进程就绪后，进入第一级队列
- 进程用完时间片而放弃`cpu`，进入下一级就绪队列
- 由于阻塞而放弃`cpu`的进程进入相应的等待队列，一旦等待的事件发生，该进程回到原来一级就绪队列

以上所说都是属于非抢占式的，如果允许抢占，则当有一个优先级更高的进程就绪时，可以抢占`cpu`，被抢占的进程回到原来一级就绪队列的末尾。




![img](https:////upload-images.jianshu.io/upload_images/1925650-7f7d96ecdeccd39b.png?imageMogr2/auto-orient/strip|imageView2/2/w/372/format/webp)

1

说明：

当一个进程总是用完时间片，那么其就会一直降级，这样我们就可以知道这是一个

```
cpu
```

型进程，于是就区分出了

```
cpu
```

型和

```
I/O
```

型进程，同时可以知道这种调度算法偏好

```
I/O
```

型进程。当然也做了一些弥补，即优先级低的进程时间片较大。



# 六、各种调度算法的比较



![img](https:////upload-images.jianshu.io/upload_images/1925650-3d420f7c1ad35825.png?imageMogr2/auto-orient/strip|imageView2/2/w/599/format/webp)

2

# 七、多处理器调度算法设计

- 不仅要决定选择哪一个进程执行，还需要决定在哪一个`cpu`上执行

- 要考虑进程在多个

  ```
  cpu之
  ```

  间迁移时的开销

   1、高速缓存失效、

  ```
  TLB
  ```

  失效

   2、尽可能使进程总是在同一个

  ```
  cpu
  ```

  上执行 

  - 如果每个进程可以调度到所有`cpu`上，假如进程上次在`cpu1`上执行，本次被调度到`cpu2`，则会增加高速缓存失效、`TLB`失效；如果每个进程尽量调度到指定的`cpu`上，各种失效就会减少。

- 考虑负载均衡问题

## 7.1 典型系统所采用的调度算法

- UNIX： 动态优先数法
- BSD5.3：多级反馈队列法
- Linux：抢占式调度
- Windows：基于优先级的抢占式多任务调度
- Solaris：综合调度算法

## 7.2 Windows线程调度

- 调度单位是线程
- 采用基于动态优先级的、抢占式调度，结合时间配额的调整

**基本思想：**

- 就绪线程按优先级进入相应的队列
- 系统总是选择优先级最高的就绪线程运行
- 同一优先级的各线程按时间片轮转进行调度
- 多`cpu`系统中允许多个线程并行运行

**引发线程调度的条件：**
 之前我们提到了四个条件：

- 线程正常终止或由于某种错误而终止
- 新线程创建或一个等待的线程变成就绪
- 当一个线程从运行态进入阻塞态
- 当一个线程从运行态变为就绪态

这里还有两个条件：

- 一个线程的优先级改变
- 一个线程改变了它的亲和（`Affinity`）处理机集合（比如允许一个线程在多个处理机上执行，但是如果其他的处理机空闲，则此线程也不能在其上进行执行）

**Windows线程优先级：**

- 分成了三类：

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-68374a2b10301ee0.png?imageMogr2/auto-orient/strip|imageView2/2/w/586/format/webp)

  3

**线程的时间配额：**

- 时间配额不是一个时间长度值，而一个称为配额单位的整数
- 一个线程用完了自己的时间配额时，如果没有其他相同优先级的线程，`Windows`将重新给该线程分配一个新的时间配额，让它继续执行。实质就是不会一定让一个线程一直运行直到其结束，首先给其分配一个时间配额，运行完之后再次检查，如果没有运行完则再次分配时间配额，让其运行，这个过程不是连续的，是有间断的。

**时间配额的一种特殊作用：**

- 假设用户首先启动了一个运行时间很长的电子表格计算程序，然后切换到一个游戏程序（需要复杂图形计算并显示，是`CPU`型）
- 如果前台的游戏进程提高它的优先级，则后台的电子表格计算进程就几乎得不到`CPU`时间了
- 但增加游戏进程的时间配额，则不会停止执行电子表格计算，只是给游戏进程的`CPU`时间多一些而已。

**调度策略：**

- 主动切换
   某个线程可能在运行过程中需要输入输出，此时进入阻塞态，此时`cpu`会选择新的线程进行执行。

- 抢占

   如果上面所说的阻塞线程被唤醒，同时其优先级又更高，那么就会去抢占执行。当线程被抢占时，它被放回相应优先级的就绪队列的队首 

  - 处于实时优先级的线程在被抢占时，时间配额被重置为一个完整的时间配额
  - 处于可变优先级的线程在被抢占时，时间配额不变，重新得到`cpu`后将运行剩余的时间配额
     这里的实时优先级和可变优先级有什么区别？？？？难道实时优先级就是按创建顺序产生的优先级，而可变优先级就是优先级可变的？

- 时间配额用完

   假设线程

  ```
  A
  ```

  的时间配额用完 

  -  `A`的优先级没有降低
     1、如果队列中有其他就绪线程，选择下一个线程执行，`A`回到原来的就绪队列末尾
     2、如果队列中没有其他就绪线程，系统会给A重新分配时间配额，让其继续执行
  -  `A`的优先级降低，此时`Windows`将选择一个更高优先级的线程执行

**线程优先级提升与时间配额调整：**
 为什么一个线程的时间配额用完后其优先级会被降低，这是因为之前此线程的优先级被提升过。

- ```
  Windows
  ```

  的调度策略 

  - 如果体现对某类线程具有倾向性？
  - 如何解决由于调度策略中潜在的不公平性而带来的饥饿现象？
  - 如何改善系统吞吐量、响应时间等整体特征？

- 解决方案 

  - 提升线程的优先级
     下列五种情况，`Windows`会提升线程的当前优先级：
     1、`I/O`操作完成
     2、信号量或事件等待结束
     3、前台进程中的线程完成了一个等待操作
     4、由于窗口活动而唤醒窗口线程
     5、线程处于就绪态超过了一定的时间还没有运行（即“饥饿”现象）
     在`Windows`中线程优先级的提升只是针对可变优先级范围内（1-15）的线程优先级
  - 给线程分配一个很大的时间配额

**几个线程优先级提升的例子：**
 1、`I/O`操作完成后的线程优先级提升

- 在完成`I/O`操作后，`Windows`将临时提升等待该操作线程的优先级，保证该线程能更快上`CPU`运行进行数据处理
- 优先级的提升值由设备驱动程序决定，提升建议值保存在系统文件“`Wdm.h`”或“`Ntddk.h`”中
- 优先级的提升幅度与对`I/O`请求的响应时间要求是一致的，响应时间要求越高，优先级提升幅度越大
- 设备驱动程序在完成`I/O`请求时通过内核函数`IoCompleteRequest`来指定优先级提升的幅度
- 为避免不公平，在`I/O`操作完成唤醒等待线程时会将该线程的时间配额减一
- 2、饥饿线程的优先级提升
- 系统线程“平衡集管理器”每秒钟扫描一次就绪队列，发现是否存在等待时间超过300个时钟中断间隔的线程
- 平衡集管理器将这些线程的优先级提升到15，并分配给它一个长度为正常值的4倍的时间配额
- 当被提升的线程用完它的时间配额后，立即衰减到原来的基本优先级

# 一、进程并发执行

## 1.1问题的提出

并发是所有问题产生的基础，也是操作系统设计的基础。

## 1.2从进程的特征看待并发问题

- 并发
   进程的执行是间断性
   进程的相对执行速度是不可预测的
- 共享
   进程/线程之间的制约性
- 不确定性
   进程执行的结果与其执行的相对速度有关，是不确定的。

# 二、进程互斥

## 2.1 竞争条件

下面看一个打印机的例子：




![img](https:////upload-images.jianshu.io/upload_images/1925650-34f7704b0aa0d05a.png?imageMogr2/auto-orient/strip|imageView2/2/w/538/format/webp)

1

说明：

在打印的时候需要维护上面这样一个打印的目录，有一个打印机的守护进程管理此目录，其中存放了所有要打印文件的信息，当缓冲区中有某个文件的文件名时，打印机就工作。这里我们需要使用in来表示缓冲区中哪个槽是空的。加入进程

```
A、B
```

都需要打印了，进程

```
A
```

首先独到了

```
in=7
```

，之后应该把in的值更新为

```
8
```

才对，但是在更新之前进程

```
A
```

被切换下

```
cpu
```

，同时进程

```
B
```

上了

```
cpu
```

，也要读取

```
in=7
```

，于是两个进程都将要打印的文件信息送到了

```
7
```

这个单元槽，于是就将进程

```
A
```

的文件信息给覆盖掉了，于是进程A就再也得不到自己所要的结果了。



**竞争条件：**两个或多个进程读写某些共享数据，而最后的结果取决于进程的运行的精确时序。

## 2.2 进程互斥

- 由于各进程要求使用共享资源（变量、文件等），而这些资源需要排他性使用。个进程之间竞争使用这些资源，这一关系称为进程互斥。
- 临界资源：系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或互斥资源或共享变量。
- 临界区（互斥区）：各个进程中对某个临界资源实施操作的程序片段。

## 2.3 临界区（互斥区）的使用原则



![img](https:////upload-images.jianshu.io/upload_images/1925650-7090e96c84cfd332.png?imageMogr2/auto-orient/strip|imageView2/2/w/537/format/webp)

2

- 没有进程在临界区时，想进入临界区的进程可进入
- 不允许两个进程同时处于其临界区中
- 临界区外运行的进程不得阻塞其他进程进入临界区
- 不得使进程无限期等待进入临界区

## 2.4 实现进程互斥的方案

- 软件方案
   `Dekker`解法、`Peterson`解法
- 硬件方案
   屏蔽中断、`TSL（XCHG）`指令

### 2.4.1 软件解法1





![img](https:////upload-images.jianshu.io/upload_images/1925650-5c578519b5b29d53.png?imageMogr2/auto-orient/strip|imageView2/2/w/575/format/webp)

3

说明：

如果

```
free
```

为

```
true
```

表示有进程在临界区，否则就没有进程在临界区，初值是

```
false
```

。假设进程

```
P
```

先上

```
cpu
```

，此时

```
free
```

初值为

```
false
```

，于是循环就结束了，此时如果

```
P
```

被切换下

```
cpu
```

，而进程

```
Q
```

上了

```
cpu
```

，判断之后

```
free
```

还是

```
false
```

，然后将

```
free
```

设置为

```
true
```

进入临界区；而此时如果

```
Q
```

被切换下

```
cpu
```

，

```
P
```

上了

```
cpu
```

，此时

```
P
```

将

```
free
```

还是设置为

```
true
```

后也进入临界区，于是在同一时刻这两个进程都在临界区中，就没有满足临界区的使用原则，是一个错误的解法。

解决：

 如果我们将最开始的两条语句加锁，不允许在其中间中断。于是我们看到如果

```
P
```

将

```
free
```

设置为

```
true
```

之后，

```
Q
```

是不能进入到临界区的，其一直处于

```
while
```

循环中。



### 2.4.2 软件解法2





![img](https:////upload-images.jianshu.io/upload_images/1925650-cbe2d9510910e97a.png?imageMogr2/auto-orient/strip|imageView2/2/w/573/format/webp)

4

说明：

如果

```
turn
```

为

```
false
```

，则

```
P
```

是不能进入临界区的，而

```
Q
```

恰恰相反，如果

```
turn
```

为

```
true
```

，则其也是不能进入临界区的。



### 2.4.3 软件解法3





![img](https:////upload-images.jianshu.io/upload_images/1925650-cd482591db7c9726.png?imageMogr2/auto-orient/strip|imageView2/2/w/534/format/webp)

5

说明：

这里设置了两个标志位。当两个标志位的值是一样的时候就会让两个进程都不能进入临界区，这就会导致

```
after you
```

问题。



### 2.4.4 DEKKER算法





![img](https:////upload-images.jianshu.io/upload_images/1925650-718a73297dd47a70.png?imageMogr2/auto-orient/strip|imageView2/2/w/580/format/webp)

6

说明：

在上个解法基础上增加了一个

```
turn
```

标志，用来解决

```
after you
```

问题。但是在最外层

```
while
```

内部还有一个

```
while
```

进行判断，用来判断是不是轮到自己执行了，一直循环直到其时间片被用完下

```
cpu
```

，这里有浪费的。如果都想进临界区，当

```
turn
```

为

```
1
```

时，

```
Q
```

就让出

```
cpu
```

，否则进入临界区。如果一直为

```
1
```

，则

```
Q
```

就一直在内部循环，即一直不能进入临界区。



### 2.4.5 PETERSON算法





![img](https:////upload-images.jianshu.io/upload_images/1925650-ed3683405672f8c2.png?imageMogr2/auto-orient/strip|imageView2/2/w/608/format/webp)

7

说明：

在上面的算法中由于内部循环会导致浪费。任何一个进程要想进入临界区，首先执行函数

```
enter_region(i)
```

，其中参数是进程号，如果运行完这个函数，则进入临界区，否则在函数内部等待。

```
turn
```

是一个共享的变量，如果两个进程都想进临界区，那么

```
turn
```

的值是后面进程的，于是

```
while
```

循环条件不成立，则先给

```
turn
```

赋值的进程先进临界区。



### 2.4.6 进程互斥的硬件解决方案1（中断屏蔽方法）

利用开关中断指令。即在进入临界区之前我们先把中断屏蔽掉，然后进入临界区进行相应的操作，出临界区时就开启中断（允许中断）。

- 简单、高效
- 代价高，限制cpu并发能力（临界区大小）
- 不适用于多处理器
- 适用与操作系统本身，不适于用户进程

### 2.4.7 进程互斥的硬件解决方案2（“测试加锁”指令）





![img](https:////upload-images.jianshu.io/upload_images/1925650-001bb5267dd20c01.png?imageMogr2/auto-orient/strip|imageView2/2/w/537/format/webp)

8

说明：

在这个指令中

```
lock
```

变量是一个共享变量，如果

```
lock=0
```

，则任何进程都可以将其置

```
1
```

，并进入临界区。如果

```
lock=1
```

，标明有其他进程在临界区中，不能进入临界区。如图所示，如果一个进程想进入临界区，则先复制

```
lock
```

的值并将其置为

```
1
```

，如果其为非零，则进入临界区，出临界区的时候将

```
lock
```

置为

```
0
```

。其本质是将总线锁住。而其中也有一个循环检测的过程，也是有点浪费时间的。



### 2.4.8 进程互斥的硬件解决方案3（“交换”指令）





![img](https:////upload-images.jianshu.io/upload_images/1925650-1c5bd4c816929dac.png?imageMogr2/auto-orient/strip|imageView2/2/w/536/format/webp)

9

说明：

首先给寄存器中置

```
1
```

，然后交换锁变量和寄存器中的值，之后再判断寄存器中的值是否为零，如果是零，标明临界区中没有进程，可以进入。

# 9、同步互斥机制2（进程并发执行）（操作系统笔记）

![img](https://upload.jianshu.io/users/upload_avatars/1925650/7a95dfb3c842.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[yjaal](https://www.jianshu.com/u/9231f33f0db3)关注

2017.01.02 11:24:15字数 1,011阅读 237

# 三、进程同步

是指系统中多个进程发生的事件存在某种时序关系，需要相互合作，共同完成一项任务。具体地说，一个进程运行到某一点时，要求另一伙伴进程为它提供消息，在未获得消息之前，该进程进入阻塞态，获得消息后被唤醒进入就绪状态。

## 3.1 生产者/消费者问题





![img](https://upload-images.jianshu.io/upload_images/1925650-19399c3a9d69f342.png?imageMogr2/auto-orient/strip|imageView2/2/w/611/format/webp)

1



![img](https://upload-images.jianshu.io/upload_images/1925650-a047f728afc91c29.png?imageMogr2/auto-orient/strip|imageView2/2/w/642/format/webp)

2

说明：

使用这种方式可以很好解决进程间协作的问题。但是在判断

```
count
```

和后面的执行语句之前，虽然我们看到只有两行代码，但是这涉及到很多指令，有可能在指令之间发生切换，所以并没有完全解决生产者/消费者问题。



## 3.2 其他同步例子





![img](https://upload-images.jianshu.io/upload_images/1925650-24043844c6be7b7b.png?imageMogr2/auto-orient/strip|imageView2/2/w/656/format/webp)

3

说明：

在这里的输入井和输出井两端都是一个生产者/消费者的问题。



## 3.3 信号量及PV操作

- 一个特殊的变量
- 用于进程间传递信息的一个整数值
- 定义如下

```c
struct semaphore
{
    int count ;//信号量的值
    queueType queue;//队列
}
```

- 信号量说明：`semaphore s;`

- 对信号量可以实施的操作：初始化、

  ```
  P
  ```

  和

  ```
  V
  ```

  （

  ```
  P、V
  ```

  分别是荷兰语的

  ```
  test(proberen)
  ```

  和

  ```
  increment(verhogen)
  ```

  ）

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-a9e7c7694acda58d.png?imageMogr2/auto-orient/strip|imageView2/2/w/635/format/webp)

  4

  说明：

  调用

  ```
  P
  ```

  操作，则首先将信号量减一，如果其值小于零，则标明该进程为阻塞态，放到队列末尾，即让出

  ```
  cpu
  ```

  。

- `P、V`操作为原子操作

- 在信号量上定义了三个操作
  初始化（非负数）、`P`操作、`V`操作

- 最初提出的是二元信号量（解决互斥）。之后，推广到一般信号量（多指）或计数信号量（解决同步）。

## 3.4 用PV操作解决进程间互斥问题

- 分析并发进程的关键活动，划定临界区
- 设置信号量`mutex`，初值为`1`
- 在临界区前实施`P(mutex)`
- 在临界区之后实施`V(mutex)`

## 3.5 用信号量解决生产者/消费者问题





![img](https://upload-images.jianshu.io/upload_images/1925650-6d53ba5df84e121b.png?imageMogr2/auto-orient/strip|imageView2/2/w/585/format/webp)

5

说明：

这里

```
empty
```

变量表示缓冲区还有多少个位置是空的，

```
full
```

表示缓冲区中被占用的个数。在生产和消费之前都需要进行判断。讨论：



![img](https://upload-images.jianshu.io/upload_images/1925650-37c8e4e544e4ca2f.png?imageMogr2/auto-orient/strip|imageView2/2/w/600/format/webp)

6

这里如果我们将消费者中的两个

```
P
```

操作颠倒顺序，如果消费者首先上

```
cpu
```

，于是首先将

```
mutex
```

减一变为零，然后执行

```
P(&full)
```

，而此时队列中是没有内容（产品）的，于是进入等待（阻塞），而此时如果被切换下

```
cpu
```

，而生产者上

```
cpu
```

，于是进行生产，但是在执行

```
P(&mutex)
```

后

```
mutex
```

值小于零了，于是也进入阻塞，这时出现了死锁问题。但是后面的两个

```
V
```

操作是可以颠倒的，但是这种情况下是临界区最小的情况。



## 3.6 用信号量解决读者/写者问题

**问题描述**
多个进程共享一个数据区，这些进程分成两组：

- 读者进程：只读数据区中的数据
- 写者进程：只往数据区写数据

**要求满足条件**

- 允许多个读者同时执行读操作
- 不允许多个写者同时操作
- 不允许读者、写者同时操作

## 3.6.1 第一类读者写者问题：读者优先

- 如果读者执行

  - 无其他读者、写者，该读者可以读
  - 若已有写者等，但有其他读者正在读，则该读者也可以读
  - 若有写者正在写，该读者必须等

- 如果写者执行

  - 无其他读者、写者，该写者可以写
  - 若有读者正在读，该写者等待
  - 若有其他写者正在写，该写者等待

- 解法

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-3fb2df3be790cf68.png?imageMogr2/auto-orient/strip|imageView2/2/w/491/format/webp)

  7

  说明：

  这个问题其实我们需要的是多个读者可以同时读的问题，所有对于读者，是不需要每个读者都做

  ```
  P(w)
  ```

  的，而只需要第一个读者来做，而后续的读者只要发现前面有读者在读，则就可以读。同时最后一个读者做

  ```
  V(w)
  ```

  。代码改为：

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-19988fb093d26095.png?imageMogr2/auto-orient/strip|imageView2/2/w/548/format/webp)

  8

  这里我们对读者计数。这虽然解决了多个读者同时读的问题，但是引出了另一个问题，就是

  ```
  rc
  ```

  变成了一个共享资源，所以我们还需要对

  ```
  rc
  ```

  进行保护，于是针对

  ```
  rc
  ```

  增加了

  ```
  P、V
  ```

  操作。

  

### 3.6.2 Linux提供的读写锁

- 应用场景
  如果每个执行实体对临界区的访问或者是读或者是写共享变量，但是它们都不会既读又写，读写锁是最好的选择。
- 实例：`Linux`的`IPX`路由代码中使用了读写锁，用`ipx_routes_lock`的读写锁保护`IPX`路由表的并发访问。要通过查找路由表实现包转发的程序需要请求读写锁；需要添加和删除路由表中入口的程序必须获得读写锁（由于通过读路由表的情况比更新的情况多得多，使用读写锁极大的提高了性能）。

# 一、管程

一种新的同步机制

## 1.1 为什么会出现管程

- 问题
   信号量机制的不足：程序编写困难、易出错
- 解决
   在程序设计语言中引入管程成分，这是一种高级同步机制

## 1.2 定义

- 是一种特殊的模块
- 有一个名字
- 由关于共享资源的数据结构及在其上操作的一组过程组成
- 进程与管程：进程只能通过调用管程中的过程来间接的访问管程中的数据结构

## 1.3 管程要保证什么

作为一种同步机制，管程要解决两个问题：

- 互斥
   管程是互斥进入的，主要是为了保证管程中数据结构的数据完整性。管程的互斥性是由编译器负责保证的。
- 同步
   管程中设置条件变量及等待/唤醒操作以解决同步问题。这两个操作可以让一个进程或线程在条件变量上等待（此时，应先释放管程的使用权），也可以通过发送信号将等待在条件变量上的进程或线程唤醒。

## 1.4 应用管程时遇到的问题

**设问：**是否会出现这样一种场景，与多个进程同时在管程中出现？
 **场景：**当一个进入管程的进程执行等待操作时，它应当释放管程的互斥权。当后面进入管程的进程执行唤醒操作时（例如`P`唤醒`Q`，即将前面的进程唤醒了），管程中便存在两个同时处于活动状态的进程。
 **如何解决：**有三种处理方法

-  `P`等待`Q`执行（`Hoare`管程）
-  `Q`等待`P`继续执行（`MESA`管程）
- 规定唤醒操作为管程中最后一个可执行的操作（`Hansen`管程）

### 1.4.1 Hoare管程





![img](https:////upload-images.jianshu.io/upload_images/1925650-74c0ba0af4f04af5.png?imageMogr2/auto-orient/strip|imageView2/2/w/559/format/webp)

1

说明：

上图中的资源为共享资源，而对资源的操作我们使用多个过程表示。有些进程在进入管程时可能条件不成熟，需要等待，这里为不同的等待进程设置了不同的条件变量，这通过

```
wait
```

操作完成，当然，在后面可能条件成熟了，需要唤醒，这里使用

```
signal
```

操作完成。在这种管程中，前面的进程进入等待，后面被唤醒的进程执行，此时前面的进程是管程内的进程，于是进入的是紧急等待队列。



- 因为管程是互斥进入的，所以当一个进程试图进入一个已被占用的管程时，应当在管程的入口处等待。为此，管程的入口处设置一个进程等待队列，称为入口等待队列。
- 如果进程`P`唤醒进程`Q`，则`P`等待`Q`执行；如果进程`Q`执行中又唤醒进程`R`，则`Q`等待`R`执行；....,如此，在管程内部可能会出现多个等待进程。于是在管程内需要设置一个进程等待队列，称为紧急等待队列，紧急等待队列的优先级高于入口等待队列。

**条件变量的实现**

- 条件变量：在管程内部说明和使用的一种特殊类型的变量。如`var c : condition` 
- 对于条件变量，可以执行`wait`和`singal`操作
-  `wait(c)`操作：如果等待紧急队列非空，则唤醒第一个等待者；否则释放管程的互斥权，执行此操作的进程进入`c`链的末尾。
-  `singal(c)`操作：如果`c`链为空，则相当于空操作，执行此操作的进程继续执行；否则唤醒第一个等待者，执行此操作的进程进入紧急等待队列的末尾。

# 二、管程的应用

## 2.1 管程的实现

管程的实现有两种途径：

- 直接构造：效率高
- 间接构造：用某种已经实现的同步机制去构造，例如信号量和`PV`操作。

## 2.2 用管程解决生产者消费者问题





![img](https:////upload-images.jianshu.io/upload_images/1925650-5dfba755668cdbd4.png?imageMogr2/auto-orient/strip|imageView2/2/w/625/format/webp)

2

说明：

左边的代码是管程的代码，右边是生产者消费者代码。生产者生产一个进程或线程后只需要调用管程，将其添加进去即可。而消费者只需要从管程中取即可。因为管程每次只允许一个进程或线程执行，所以可以保证同步问题。在

```
Java
```

中有类似的机制，但是

```
C/C++
```

中没有。



# 三、MESA管程

-  `Hoare`管程的一个缺点
   两次额外的进程切换
- 解决
   将`Hoare`管程中的`signal`改成了`notify`，就是当一个正在管程中的进程执行`notify(x)`时，它使得`x`条件队列得到一个通知，发信号的进程继续执行。
-  `notify`的结果：位于条件队列的进程在将来合适的视乎且当处理器可用时恢复执行
- 由于不能保证在它之前没有其他进程进入管程，因而这个进程必须重新检查条件（`while`循环取代`if`语句）
- 导致对条件变量至少一次额外的检测（但不再有额外的进程切换），并且对等待进程在`notify`之后何时运行没有任何限制，这是其缺点，但是确实比`Hoare`管程的效率要高。

## 3.1 生产者/消费者问题





![img](https:////upload-images.jianshu.io/upload_images/1925650-ca0923e1da01faa5.png?imageMogr2/auto-orient/strip|imageView2/2/w/617/format/webp)

3

说明：

从上图可以看到只是判断有所区别，其他的和之前的都差不多。



## 3.2 改进notify

- 对`notify`的一个很有用的改进
   1、给每个条件原语关联一个监视计时器，不论是否被通知，一个等待的时间超时的进程将被设为就绪态。
   2、当该进程被调度时，会再次检查相关条件，如果条件满足则继续执行。
- 超时可以防止如下情况的发生
   当某些进程产生相关条件的信号之前失败时，等待该条件的进程就会被限制地推迟执行而处于饥饿状态。
- 引入`BROADCAST`
   使所有在该条件上等待的进程都被释放并进入就绪队列
  - 当一个进程不知道有多少个进程被激活时，这种方式是非常方便的。
     例子：生产者/消费者问题中，假设`insert`和`remove`函数都适用于可变长度的字符块，此时，如果一个生产者往缓冲区中添加了一批字符，它不需要知道每个正在等待的消费者准备消耗多少字符，而仅仅执行一个`broadcast`，所有正在等待的进程都得到通知并再次尝试运行。
  - 当一个进程难以判断将激活哪个进程时，也可以使用这种广播机制

## 3.3 Hoare管程与MESA管程的比较

-  `Mesa`管程优于`Hoare`管程之处在于`Mesa`管程错误比较少
- 在`Mesa`管程，由于每个过程在收到信号后都重新检查管程变量，并且由于使用了`while`结构，一个进程不正确的`broadcast`广播或发信号`notify`不会导致收到信号的程序出错。收到信号的程序将检查相关的变量，如果期望的条件没有满足，它会重新继续等待

# 四、PTHREAD中的同步机制

这种同步机制其实就是`POSIX Threads`同步机制，是一个线程函数库。




![img](https:////upload-images.jianshu.io/upload_images/1925650-c50d091e982dfdaa.png?imageMogr2/auto-orient/strip|imageView2/2/w/626/format/webp)

4

说明：

在这种机制中对于互斥的保证是使用一个互斥量

```
mutex
```

。我们可以可能可以创建

```
init
```

和销毁

```
destroy
```

。可以加锁

```
lock
```

和解锁

```
unlock
```

，还有尝试加锁

```
trylock
```

。在解决同步问题的时候使用的是条件变量。同时是可以进行创建和销毁等操作。



## 4.1 讨论PTHREAD_COND_WAIT

这个函数执行可以分解为三个主要动作：

- 1、解锁（释放锁）
- 2、等待
   当收到一个解除等待的信号（`pthread_cond_sinal`或者`pthread_cond_broad_cast`）之后，`pthread_cond_wait`马上需要做的动作是：
- 3、上锁

# 五、进程间通信IPC

## 5.1 为什么需要通信机制

- 信号量和管程的不足：不能传递大量的信息
- 不适用多处理器的情况
- 进程间通信机制
   消息传递：`send & receive`原语。适用于分布式系统、基于共享内存的多处理器系统、单处理器系统，可以解决进程间的同步问题、通信问题。

## 5.2 基本通信方式

- 消息传递
- 共享内存
- 管道
- 套接字
- 远程过程调用

## 5.3 消息传递





![img](https:////upload-images.jianshu.io/upload_images/1925650-b93b635806027c47.png?imageMogr2/auto-orient/strip|imageView2/2/w/677/format/webp)

5

说明：

当发送进程将相关的消息准备好之后，由于其不能直接操作接收进程，所有相关的发送工作需要操作系统来完成，发送进程将消息发送给操作系统之后就不需要管理了。这里执行了陷入内核和复制消息两部操作。而操作系统在接收到消息之后，是将消息队列的指针挂到接收进程的

```
PCB
```

末尾，当接收进程被调度上

```
cpu
```

之后，此进程才会去内核中复制相关的消息。



## 5.3.1 用PV操作实现send原语





![img](https:////upload-images.jianshu.io/upload_images/1925650-69f1a0cd6e14de5c.png?imageMogr2/auto-orient/strip|imageView2/2/w/641/format/webp)

6

说明：

对于

```
receive
```

的原语实现这里就多说了。



## 5.4 共享内存





![img](https:////upload-images.jianshu.io/upload_images/1925650-6027418e395c5533.png?imageMogr2/auto-orient/strip|imageView2/2/w/643/format/webp)

7

说明：

这里有两个问题需要解决



- 1、两个进程之间如何共享内存，我们可以将两个进程的地址空间映射到同一块物理地址空间上，于是其操作的资源是相同的。
- 2、读者写者问题。共享的内存不能同时写，但是可以同时读。我们可以使用读者写者方法解决互斥问题。

# 5.5 管道通信方式PIPE



![img](https:////upload-images.jianshu.io/upload_images/1925650-d21c9ab6e6ae6acd.png?imageMogr2/auto-orient/strip|imageView2/2/w/526/format/webp)

8

利用一个缓冲传输介质（内存或文件）连接两个相互通信的进程

- 按字符流的方式写入读出
- 先进先出顺序
- 管道通信机制必须提供的协调能力
   互斥、同步、判断对方进程是否存在

# 六、典型操作系统中的IPC机制

## 6.1 进程同步/通信实例



![img](https:////upload-images.jianshu.io/upload_images/1925650-f745d83b3072dd0e.png?imageMogr2/auto-orient/strip|imageView2/2/w/616/format/webp)

9

## 6.2 Linux的进程通信机制





![img](https:////upload-images.jianshu.io/upload_images/1925650-6181ca6f836eb62e.png?imageMogr2/auto-orient/strip|imageView2/2/w/573/format/webp)

10

说明：

从图中可以看到

```
Linux
```

继承了多个操作系统的

```
IPC
```

机制。同时也是基于

```
POSIX
```

机制。



### 6.2.1 Linux内核同步机制



![img](https:////upload-images.jianshu.io/upload_images/1925650-1e6950abbe62e5f8.png?imageMogr2/auto-orient/strip|imageView2/2/w/552/format/webp)

11

**原子操作**

- 不可分割，在执行之前不会被其他任务或事件中断

- 常用于实现资源的引用计数

- ```
  atomic_t
  ```

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-2f855ede7cb0e378.png?imageMogr2/auto-orient/strip|imageView2/2/w/427/format/webp)

  12

**屏障**

- 一种同步机制（又称栅栏、关卡）
- 用于对一组线程进行协调
- 应用场景
   一组线程协同完成一项任务，需要所有线程都到达一个汇合点后再一起向前推进，比如矩阵运算。



# 一、基本概念：地址重定位

## 1.1 需要了解的内容

- 程序装载到内存才可以运行
   通常，程序可以执行文件格式保存在磁盘上
- 多道程序设计模型
   允许多个程序同时进入内存
- 每个进程有自己的地址空间
   一个进程执行时不能访问另一个进程的地址空间
   进程不能执行不合适的操作

## 1.2 要解决的问题





![img](https:////upload-images.jianshu.io/upload_images/1925650-b5f74a1fd452ea48.png?imageMogr2/auto-orient/strip|imageView2/2/w/647/format/webp)

1

说明：

在左边的单处理器系统中，如果一个进程想要运行，那么必须将进程地址空间装载到物理内存中才可以运行。而右边的是多处理器系统中有多个进程需要进入物理内存执行，这里要解决的问题就是，如何将进程地址空间合理的装载到物理内存中，如何合理的分配使用内存，使得每个进程能正确执行。



## 1.3 复习：进程地址空间



![img](https:////upload-images.jianshu.io/upload_images/1925650-8a18c748dfd80d9e.png?imageMogr2/auto-orient/strip|imageView2/2/w/635/format/webp)

2

## 1.4 注意

- 进程中的地址不是最终的物理地址
- 在进程运行前无法计算出物理地址

这就需要地址重定位来解决这些问题。

# 二、地址重定位

- 逻辑地址（相对地址、虚拟地址）
   用户程序经过编译、汇编后形成目标代码，目标代码通常采用相对地址的形式，其首地址为0，其余地址都相对于首地址而编址。不能用逻辑地址在内存中读取信息。
- 物理地址（绝对地址、实地址）
   内存中存储单元的地址，可直接寻址

为了保证`cpu`执行指令时可以正确访问内存单元，需要将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址，这一过程称为地址冲地位。

## 2.1 静态重定位与动态重定位

- 静态重定位
   当用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换。一般可由软件完成。
- 动态重定位
   在进程执行过程中进行地址变换，即逐条指令执行时完成地址转换。需要硬件部件支持，较为常用。

## 2.2 动态重定位实现



![img](https:////upload-images.jianshu.io/upload_images/1925650-8278d3738928620e.png?imageMogr2/auto-orient/strip|imageView2/2/w/576/format/webp)

3

# 三、物理内存管理

## 3.1 空闲内存管理





![img](https:////upload-images.jianshu.io/upload_images/1925650-5f79432c588f4755.png?imageMogr2/auto-orient/strip|imageView2/2/w/285/format/webp)

4

说明：

我们对物理内存有不同的划分，一种是等长的划分，一种是不等长的划分。



- 数据结构
   1、位图
   对于等长划分这种我们可以使用位图的方式。每个分配单元对应于位图中的一位，`0`表示空闲，`1`表示占用（或者相反）。对于不等长的划分可以使用下面两种分配结构。
   2、空闲区表、已分配区表
   表中每一项记录了空闲区（或已分配区）的起始地址、长度、标志
   3、空闲块链表

## 3.2 内存分配算法

这里我们使用空闲区表、已分配区表为例来说明内存分配算法。

- 首次适配`first fit`
   在空闲区表中找到第一个满足进程要求的空闲区
- 下次适配`next fit`
   从上次找到的空闲区处接着查找
- 最佳适配`best fit`
   查找整个空闲区表，找到能够满足进程要求的最小空闲区
- 最差适配`worst fit`
   总是分配满足进程要求的最大空闲区

当找到满足进程需求的空闲区表后，需要将空闲区分为两部分，一部分供进程使用，另一部分形成新的空闲区。

## 3.3 回收问题

- 内存回收算法 
  - 当某一块归还后，前后空闲空间合并，修改内存空闲区表。
  - 四种情况
     上相邻、下相邻、上下都相邻、上下都不相邻

## 3.4 伙伴系统

这是`Linux`底层内存管理采用的一种方法

- 一种经典的内存分配方案，是一种特殊的分离适配算法
- 主要思想：将内存按`2`的整数次幂进行划分，组成若干空闲块表；查找该链表找到能满足进程需求的最佳匹配块。
- 算法 
  - 首先将整个可用空间看作一块：`2^U` 
  - 假设进程申请的空间大小为`s`，如果满足`2^(U-1)<s<=2^U`，则分配整个块，否则，将块划分为两个大小相等的伙伴，大小为`2^(U-1)`。
  - 一直划分下去直到产生大于或等于`s`的最小块。

## 3.5 伙伴系统例子





![img](https:////upload-images.jianshu.io/upload_images/1925650-80d1726929a7c03e.png?imageMogr2/auto-orient/strip|imageView2/2/w/656/format/webp)

5

说明：

从上图中可以看到上面的算法是如何工作的。



# 四、基本的内存管理方案1

即整个进程进入内存一片连续的区域，有多种解决方案：单一连续区、固定分区、可变分区、页式、段式、段页式等方案。

## 4.1 单一连续区

特点：一段时间内只有一个进程在内存中，有简单、内存利用率低的特点。这种方案是在早期系统中使用的，有三种不同的布局：



![img](https:////upload-images.jianshu.io/upload_images/1925650-7b6cefd80769c3e6.png?imageMogr2/auto-orient/strip|imageView2/2/w/666/format/webp)

6

## 4.2 固定分区

- 把内存空间分割成若干个区域，称为分区
- 每个分区的大小可以相同也可以不同
- 分区大小固定不变
- 每个分区装一个且只能装载一个进程





![img](https:////upload-images.jianshu.io/upload_images/1925650-01700d944ca4b0a0.png?imageMogr2/auto-orient/strip|imageView2/2/w/652/format/webp)

7

说明：

可以看到不同的进程链分别排在不同的分区位置。这样有个缺点是有的进程链很长，一时半会得不到分区，但是此时可能有些空闲分区根本没有被使用。于是还有右边这种排队方案，就是只有一个进程链，然后哪个分区空闲了，排在首位的进程就进入执行。早期手机中就是采用这种方法。



## 4.3 可变分区

- 根据进程的需要，把内存空闲空间分割出一个分区，分配给该进程
- 剩余部分称为新的空闲区
- 会导致一些问题：导致一些外碎片（很小的空闲内存无法利用），这样会导致内存利用率下降。

**碎片问题解决**

- 碎片：很小的、不易利用的空闲区，导致内存利用率下降
- 解决方案：紧缩技术
   在内存中移动程序，将所有小的空闲区合并为较大的空闲区。又称为压缩技术，紧致技术，搬家技术
- 紧缩时要考虑的问题
   系统开销、移动时机

# 五、基本内存管理方案2

即一个进程进入内存中若干个不连续的区域

## 5.1 页式存储管理方案

- 设计思想

  -  **用户进程地址空间被划分为大小相等的部分**，称为页（`page`）或页面，从零开始编号。**这是逻辑地址空间上的称谓**。
  - 内存空间按同样大小划分为大小相等的区域，称为页框（`page frame`），从零开始编号；也称为**物理页面**，页帧，内存块
  - 内存分配（规则）
     以页为单位进行分配，并按进程需要的页数来分配；逻辑上相邻的页，物理上不一定相邻。
  - 典型的页面尺寸：`4K`或`4M` 

- 逻辑地址
  

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-fe0a34d548610ebc.png?imageMogr2/auto-orient/strip|imageView2/2/w/477/format/webp)

  8

  说明：

  逻辑地址分为页号和页内地址（页内偏移），这种划分是系统自动完成的，对用户是透明的。

  

- 内存分配
  

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-d27e9b7067c59da7.png?imageMogr2/auto-orient/strip|imageView2/2/w/575/format/webp)

  9

  说明：

  可以看到连续的进程地址空间映射到页帧中的物理内存是杂乱的。

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-5622e5f0f635f388.png?imageMogr2/auto-orient/strip|imageView2/2/w/662/format/webp)

  10

  说明：

  对于逻辑地址空间和物理内存空间的杂乱的映射，如何进行映射呢？这里我们需要使用页表来记录这种映射。

  

**相关数据结构及地址转换**

- 页表
  - 由若干页表项（记录了逻辑页号与页框号对应关系）构成
  - 每个进程一个页表，存放在内存
  - 页表起始地址保存在何处？
- 空闲内存管理
   其实我们可以使用位图就可以管理物理内存了
- 地址转换（硬件支持）
   **cpu**取到逻辑地址，自动划分为页号和页内地址；用页号查页表，得到页框号，再与页内偏移拼接成物理地址。在这种方案中我们也会遇到碎片问题，但是这里的碎片是内碎片。比如某个进程需要`5`页加一条指令，于是这里我们需要分配`6`页给这个进程。

## 5.2 段式存储管理方案

- 设计思想

  - 用户进程地址空间：**按程序自身的逻辑关系划分为若干个程序段**，每个段都有一个段名
  - 内存空间被动态划分为若干长度不相同的区域，称为物理段，每个物理段由起始地址 和长度确定。
  - 内存分配（规则）：以段为单位进行分配，每段在内存中占据连续空间，但各段之间可以不相邻。其实就是将程序分为若干段，每段占用一块内存空间。

- 逻辑地址
  

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-5fecb60814cec01c.png?imageMogr2/auto-orient/strip|imageView2/2/w/270/format/webp)

  11

  说明：

  和页式类似，逻辑地址分为段号和段内地址。不同的是段号和段内地址不是自动划分的。我们看一个例子：

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-e858d87ca7a05251.png?imageMogr2/auto-orient/strip|imageView2/2/w/523/format/webp)

  12

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-0ddcd08f29793a7e.png?imageMogr2/auto-orient/strip|imageView2/2/w/686/format/webp)

  13

  说明：

  同样的，和页式类似，每个段的位置都不一样或不连续。而我们这里使用段表来将逻辑段号和物理内存映射起来。其中段表包含长度和段起始地址。

  

**相关数据结构及地址转换**

- 段表
   每项记录了段号，段首地址和段长度之间的关系
   每个进程一个段表，存放在内存
   段表起始地址保存在何处？
- 物理内存管理
   我们可以使用不等长的分配方案进行管理
- 地址转换（硬件）
   **cpu**取到逻辑地址，用段号查段表，得到该段在内存的起始地址，与段内偏移地址计算出物理地址

## 5.3 段页式存储管理方案

- 产生背景
   综合页式、段式方案的优点，克服二者的缺点

- 设计思想
   用户进程划分：先按段划分，每一段按页面划分
   逻辑地址：

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-763cbdfa70eb9755.png?imageMogr2/auto-orient/strip|imageView2/2/w/447/format/webp)

  11

  内存划分：同页式存储管理方案
   内存分配：以页为单位进行分配

- 数据结构及有关操作
   段表：记录了每一段的页表起始地址和页表长度
   页表：记录了逻辑页号与页框号对应关系，每一段有一张页表，一个进程有多个页表
   空闲区管理：同页式管理
   内存分配、回收：同页式管理

- 地址转换
   由硬件支持

## 5.4 小结



![img](https:////upload-images.jianshu.io/upload_images/1925650-c876fc726f16178c.png?imageMogr2/auto-orient/strip|imageView2/2/w/636/format/webp)

12

# 六、交换技术

## 6.1 内存不足时如何管理

即如何在一个较小的物理内存空间中运行一个会占用较大地址空间的进程？

## 6.2 内存“扩充”技术

- 内存紧缩技术（例如：可变分区。即有时候可以使用内存紧缩技术来满足进程所需内存），但是这种技术一般不能解决问题
- 覆盖技术（`overlaying`）
- 交换技术（`swapping`）
- 虚拟存储技术（`virtual memory`）

## 6.3 覆盖技术

- 解决问题：程序大小超过物理内存总和
- 程序执行过程中，程序的不同部分在内存中相互替代。 
  - 按照其自身的逻辑结构，将那些不会同时执行的程序段共享同一块内存区域
  - 要求程序各模块之间有明确的调用结构
- 程序员声明覆盖结构，操作系统完成自动覆盖

这种技术主要用于早期的操作系统，现在使用不多。

## 6.4 交换技术

- 设计思想
   内存空间紧张时，系统将内存中某些进程暂时移动到外存，把外存中某些进程交换进内存，占据前者所占用的区域（进程在内存与磁盘之间的动态调用）。

- 讨论：实现时遇到的问题
   进程的哪些内容要交换到磁盘？会遇到什么困难？
   在磁盘的什么位置保存被换出的进程？
   交换时机？
   如何选择被换出的进程？
   如何处理进程空间增长？

- 哪些内容要交换到磁盘？会遇到什么困难？
   1、运行时创建或修改的内容：栈和堆
   2、交换区：一般系统会指定一块特殊的磁盘区域作为交换空间，包含连续的磁道，操作系统可以使用底层的磁盘读写操作对其高效访问。
   3、何时需要发生交换？只要不用就换出；内存空间不够或有不够的危险时换出，一般与调度器结合使用
   4、考虑进程的各种属性；不应换出处于等待`I/O`状态的进程

- 进程空间增长的困难及解决
  

  

  ![img](https:////upload-images.jianshu.io/upload_images/1925650-035cb42d2831887d.png?imageMogr2/auto-orient/strip|imageView2/2/w/553/format/webp)

  13

  说明：

  这里给出了两种解决方案，一种是左边的为栈预留一部分空间；一种是右边的让数据区和栈去同向增长，即在一个预留区中增长。

# 12、存储模型2（操作系统笔记）

![img](https://upload.jianshu.io/users/upload_avatars/1925650/7a95dfb3c842.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[yjaal](https://www.jianshu.com/u/9231f33f0db3)关注

0.0872017.01.06 14:54:41字数 5,257阅读 1,570

# 一、虚拟存储技术

- 所谓虚拟存储技术是指：当进程运行时，先将其一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存的工作
- 虚拟地址空间即为分配给进程的虚拟内存
- 虚拟地址是在虚拟内存中指令或数据的位置，该位置可以被访问，仿佛它是内存的一部分

## 1.1 存储器的层次结构



![img](https://upload-images.jianshu.io/upload_images/1925650-23b0122043d4a792.png?imageMogr2/auto-orient/strip|imageView2/2/w/570/format/webp)

1

## 1.2 虚拟内存与存储体系



![img](https://upload-images.jianshu.io/upload_images/1925650-9bd611a356b53e81.png?imageMogr2/auto-orient/strip|imageView2/2/w/518/format/webp)

2

- 把内存与磁盘有机地结合起来使用，从而得到一个容量很大的“内存”，即虚拟内存
- 虚存是对内存的抽象，构建在存储体系之上，由操作系统协调各存储器的使用
- 虚存提供了一个比物理内存空间大得多的地址空间

## 1.3地址保护

- 确保每个进程有独立的地址空间
- 确保进程访问合法的地址范围，即我们需要访问地址越界
- 确保进程的操作是合法的

## 1.4 虚拟页式

我们将虚拟存储技术和页式存储管理方案结合起来得到了虚拟页式存储管理系统。具体有两种方式，一是请求调页，二是预先调页。以`cpu`时间和磁盘换取昂贵内存空间，这是操作系统中的资源转换技术。

- 基本思想
  - 进程开始运行之前，不是装入全部页面，而是装入一个或零个页面
  - 之后，根据进程运行的需要，动态装入其他页面
  - 当内存空间已满，而又需要装入新的页面时，则根据某种算法置换内存中的某个页面，以便装入新的页面

# 二、页表及页表项的设计



![img](https://upload-images.jianshu.io/upload_images/1925650-655646502f5093c7.png?imageMogr2/auto-orient/strip|imageView2/2/w/535/format/webp)

3

## 2.1 页表项设计

- 页表由页表项组成
- 页框号、有效位、访问位、修改位、保护位
  页框号（内存块号、物理页面号、页帧号）：通过页框号给出具体对应的物理页面
  有效位（驻留位、中断位）：表示该页是在内存还是在磁盘
  访问位：引用位。当要使用某个页面时，需要访问位作出相应的记录，表示此页面被访问过
  修改位：此页在内存中是否被修改过
  保护位：读/可读写

通常，页表项是硬件设计的。

## 2.2 页表

- `32`位虚拟地址空间的页表规模？
  页面大小为`4k`，页表项大小为`4`字节，则一个进程地址空间有`2^20`页。这里首先是虚拟地址空间可以达到`2^32`字节，这里注意：在二级页表中才可以表示`2^32`的地址空间，除以页面大小可以得到有多少个页面。而一个页表项可以表示`1k`的页面，于是页表项就要占用`1024`页（页表页，就是页表项占用的空间）。
- **64**位虚拟地址空间
  页面大小为`4k`，页表项大小为`8`字节，则页表规模为`32000TB`。这里没说清楚，到底是几级页表中的结果？
- 页表页在内存中若不连续存放，则需要引用页表的地址索引表，即页目录。即一个多级页表结构。

## 2.3 二级页表结构及地址映射





![img](https://upload-images.jianshu.io/upload_images/1925650-9b2411426fd651e4.png?imageMogr2/auto-orient/strip|imageView2/2/w/651/format/webp)

4

说明：

这里还是

```
32
```

位的虚拟地址空间。每个进程有一个页目录，根据页目录得到页表地址，然后从页表中的页表项的页框号找到真正的物理内存地址。

```
32
```

位的虚拟地址分为页目录偏移、页表偏移和页内偏移。页目录地址保存在一个寄存器中，根据此地址找到页目录起始地址，然后根据月页目录偏移找到对应的页表地址，根据页表偏移找到页表项，从页表项中取得页框号，然后结合页内偏移找到对应的物理内存。对于二级页表，在

```
32
```

位系统中可以表示

```
4G
```

的虚拟地址空间。如果需要超过

```
4G
```

的虚拟地址空间，则二级页表满足不了。



![img](https://upload-images.jianshu.io/upload_images/1925650-48df5a3e91d12ae1.png?imageMogr2/auto-orient/strip|imageView2/2/w/635/format/webp)

5



## 2.4 I386页目录和页表项





![img](https://upload-images.jianshu.io/upload_images/1925650-fe37312448f851d3.png?imageMogr2/auto-orient/strip|imageView2/2/w/639/format/webp)

5

说明：

总共有

```
32
```

位地址。



## 2.5 反转（倒排）页表

- 地址转换
  从虚拟地址空间出发：虚拟地址-->查页表-->得到页框号-->形成物理地址，其中每个进程一张表，这样页表会占用很大的空间。注意：反转页表和实际物理地址大小是固定比例的，与进程个数无关。

- 解决思路

  - 从物理地址空间出发，系统建立一张页表

  - 页表项记录进程的某个虚拟地址（虚页号）与页框号的映射关系。

    

    ![img](https://upload-images.jianshu.io/upload_images/1925650-d35306dba1596ba7.png?imageMogr2/auto-orient/strip|imageView2/2/w/677/format/webp)

    6

    说明：

    系统建立一张页表可以节省很大的空间，这被很多

    ```
    64
    ```

    位系统采用，但是每次进行运行都需要查整张表，这样会耗费很大的资源，于是我们采用了一个哈希表，这样查找更快。

## 2.6 地址转换过程及TLB





![img](https://upload-images.jianshu.io/upload_images/1925650-93a9f4b06c995cd8.png?imageMogr2/auto-orient/strip|imageView2/2/w/634/format/webp)

7

说明：

上图是虚拟地址通过页表和物理地址映射的关系。这个过程是有内存管理单元完成的。



![img](https://upload-images.jianshu.io/upload_images/1925650-940dd1cfa8751137.png?imageMogr2/auto-orient/strip|imageView2/2/w/580/format/webp)

8



![img](https://upload-images.jianshu.io/upload_images/1925650-53b274d5444b053d.png?imageMogr2/auto-orient/strip|imageView2/2/w/669/format/webp)

9



### 2.6.1 快表（TLB）的引入

- 问题
  页表：两次或两次以上的内存访问。如果是二级页表就要访问两次，如果是四级页表就要访问四次内存。
  `cpu`的指令处理速度与内存指令的访问速度差异较大，`cpu`的速度得不到充分利用。那如何加快地址映射速度，以改善系统性能？这里我们利用程序访问的局部性原理：引入快表（`TLB`）。

### 2.6.2 快表

- `TLB`（`Translation Look-aside Buffers`）
  在`cpu`中引入的高速缓存，可以匹配`cpu`的处理速度和内存的访问速度。是一种随机存取型存储器，除连线寻址机制外，还有接线逻辑，能按特定的匹配标志在一个存储周期内对所有的字同时进行比较。
- 快表一般称为相连存储器：按内容并行查找
- 保证正在运行进程的页表的子集（部分页表项）

### 2.6.3 加入TLB后地址转换过程





![img](https://upload-images.jianshu.io/upload_images/1925650-6ffdcac20ac8a7ce.png?imageMogr2/auto-orient/strip|imageView2/2/w/627/format/webp)

10

说明：

首先根据虚拟地址去查

```
TLB
```

，如果能找到页框号，则直接和偏移结合找到对应的物理内存；如果

```
TLB
```

中没有页框号，则需要去查页表，之后在找到对应的物理内存；在页表中如果对应的页表项无效，则会出现

```
page fault
```

的异常，然后由系统处理之后再进行同样的操作。



## 2.7 页错误（page fault）

- 又称页面错误、页故障、页面失效

- 地址转换过程中硬件产生的异常

- 具体原因
  1、所访问的虚拟页面没有调入物理内存，即缺页异常
  2、页面访问违反权限（读/写、用户/内核），比如用户访问内核空间。
  3、错误的访问地址，比如

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-a980a0481692ea01.png?imageMogr2/auto-orient/strip|imageView2/2/w/194/format/webp)

  11

  图中标注的位置都是有内容的，如果访问地址指向没有标注（没有内容）的位置，则就是错误的访问地址。

## 2.8 缺页异常处理

- 是一种页错误
- 在地址映射过程中，硬件检查页表时发现所要访问的页面不在内存，则产生异常--缺页异常
- 操作系统执行缺页异常处理程序：获得磁盘地址，启动磁盘，将该页调入内存
  - 如果内存中有空闲页框，则分配一个页框，将调入页装入，并修改页表中相应页表项的有效位及相应的页框号
  - 若内存中没有空闲页框，则要置换内存中某一页框；若该页框内容被修改过，则要将其写回磁盘。

# 三、虚拟页式存储中软件相关策略

## 3.1 驻留集

- 所谓驻留集，是指在某段时间间隔内，进程要访问的页面集合
- 驻留集大小：给每个进程分配多少页框？
- 固定分配策略
  进程创建时确定。可以根据进程类型（交互、批处理、应用类）或者基于程序员或系统管理员的需要来确定
- 可变分配策略
  根据缺页率评估局部性表现
  缺页率高-->增加页框数
  缺页率低-->减少页框数
  系统开销

## 3.2 置换问题

- 置换范围
  计划置换页面的集合是局限在产生缺页中断的进程，还是所有进程的页框？

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-4c1a79a64625ccdc.png?imageMogr2/auto-orient/strip|imageView2/2/w/709/format/webp)

  12

- 置换策略

  - 在计划置换的页框集合中，选择换出哪一个页框？其目标是置换最近最不可能访问的页。
  - 根据局部性原理，最近的访问历史和最近将要访问的模式间存在线惯性，因此，大多数策略都基于过去的行为来预测将来的行为。**注意：**置换策略设计得越精致、越复杂，实现的软硬件开销就越大。当然有些被锁定的页框是不能被置换的。

## 3.3 页框锁定

为什么要锁定页面？

- 采用虚拟存储技术后，相关的开销使得进程的运行时间变得不确定
- 给每一页框增加一个锁定位
- 通过设置相应的锁定位不让操作系统将进程使用的页面换出内存，避免产生由交换过程带来的不确定的延迟
- 例如：操作系统核心代码、关键数据结构、`I/O`缓冲区。特别是正在`I/O`的内存页面。`Windows`中的`VirtualLock`和`VirtualUnLock`函数。

## 3.4 清除策略

- 清除：从进程的驻留集中收回页框
- 虚拟页式系统工作的最佳状态：发生缺页异常时，系统中有大量的空闲页框。
- 结论：在系统中保存一定数目的空闲页框供给比使用所有内存并在需要时搜索一个页框有更好的性能。所以一般清除的策略如下：
  - 设计一个分页守护进程，多数时间处于睡眠状态，可定期唤醒以检查内存的装填
  - 如果空闲页框过少，分页守护进程通过预定的页面置换算法选择页面换出内存
  - 如果页面装入内存后被修改过，则将它们写回磁盘分页守护进程可保证所有的空闲页框是“干净”的。
- 当进程需要使用一个已置换出的页框时，如果该页框还没有被新的内容覆盖，将它从空闲页框集合中移出即可恢复该页面。就是说当进程还需要使用某个页框，同时这个页框虽然被移出了，但是内容还没有被覆盖，则我们只需要将其从空闲页框集合中移出即可恢复页面。于是可以利用此技术解决已经回收的页框再利用的问题。**注意：**所有的讨论都是在进程没有结束的情况下进行的。如果进程结束了，则所有的页框都会还给系统。这种技术叫**页缓冲技术**：
  - 不丢弃置换出的页，将它们放入两个表之一：如果未被修改，则放到空闲页链表中，如果修改了，则放到修改页链表中。
  - 被修改的页定期写回磁盘（不是一次只写一个，大大减少`I/O`操作的数量，从而减少了磁盘访问的时间）
  - 被置换的页仍然保留在内存中，一旦进程又要访问该页，可以迅速将它加入该进程的驻留集合（代价很小）

## 3.5 页面置换算法

又称页面淘汰算法。最佳算法-->先进先出-->第二次机会-->时钟算法-->最近未使用-->最近最少使用-->最不经常使用-->老化算法-->工作集-->工作集时钟

### 3.5.1 最佳置换算法（OPT）

- 设计思想
  置换以后不再需要的或最远的将来才会用到的页面。
- 实现
  这种算法要基于进程的走向来实现，更多的是作为一种标准来衡量其他算法的性能。

### 3.5.2 先进先出算法（FIFO）

- 选择在内存中驻留时间最长的页并置换它
- 实现：页面链表法

### 3.5.3 第二次机会算法（SCR）

在先进先出算法的基础上进行该机而来的，此算法按照先进先出算法选择某一页面，检查其访问位`R`，如果为`0`，则置换该页；如果为`1`，则给第二次机会，并将访问位置零，并将其从链头取下放到链尾。



![img](https://upload-images.jianshu.io/upload_images/1925650-b6c941c5054b28f4.png?imageMogr2/auto-orient/strip|imageView2/2/w/636/format/webp)

13



### 3.5.4 时钟算法（CLOCK）

在第二次机会算法中当给某个页面第二次机会的时候，将其访问位置零，然后将其挂到链尾，这都是需要开销的，于是我们改进为时钟算法。



![img](https://upload-images.jianshu.io/upload_images/1925650-5855cf5d77249896.png?imageMogr2/auto-orient/strip|imageView2/2/w/669/format/webp)

14

说明：

其实就是将之前的链表改为了环形链表，当给某个页面第二次机会的时候不需要将其取下然后挂到链尾，只需要移动一下指针即可，这样可以降低开销。



### 3.5.5 最近未使用算法（NRU）

- 选择在最近一段时间内未使用过的一页并置换
- 实现：置换页表表象的两位，访问位`R`，修改位`M`。硬件会设置这些位，如果硬件没有这些位，则可用软件模拟。
- 进程启动时，`R、M`位置零，`R`位被定期清零。
- 发生缺页中断时，操作系统检查`R、M`：
  - 第一类：无访问，无修改（`00`）
  - 第二类：无访问，有修改（`01`）
  - 第三类：有访问，无修改（`10`）
  - 第四类：有访问，有修改（`11`）
- 算法思想
  随机从编号最小的非空类中选择一页置换出去。
- 时钟算法的实现
  对此算法有一个时钟算法的实现
  1、从指针的当前位置开始，扫描页框缓冲区，选择遇到的第一个页框（`r=0，m=0`）用于置换（本扫描过程中，对使用位不做任何修改）
  2、如果第一步失败，则重新扫描，选择第一个（`r=0；m=1`）的页框（本次扫描工程中，对每个跳过的页框，将其使用位置为零）
  3、如果第二部失败，指针将回到它的最初位置，并且集合中的所有页框的使用位均为零。重复第一步，并且，如果有必要，重复第二步，这样将可以找到置换的页框。

### 3.5.6 最近最少使用算法（LRU）

选择最后一次访问时间距离当前时间最长的一页并置换，即置换未使用时间最长的一页。

- 性能接近最佳页面置换算法

- 实现：时间戳或维护一个访问页的栈，导致开销较大。下面看一种硬件实现：

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-eadfb99586b13197.png?imageMogr2/auto-orient/strip|imageView2/2/w/616/format/webp)

  15

  说明：

  访问第

  ```
  0
  ```

  页时先将页的第

  ```
  0
  ```

  行置为

  ```
  1
  ```

  ，然后将第

  ```
  0
  ```

  列置为

  ```
  0
  ```

  ，以此类推，在访问完之后将行编号最小的那一页置换出去，我们看到

  ```
  j
  ```

  中最小的是第

  ```
  1
  ```

  行，于是将第

  ```
  1
  ```

  页置换出去。当然这里只有四页。

  

### 3.5.7 最不经常使用算法（NFU）

即`Not frequently Used`，选择访问次数最少的页面置换

- 一开始提出此算法是`LRU`（最近最少使用算法）的一种软件解决方案，但是实际上差距有点大。
- 实现
  - 软件计数器，一页一个，初值为零
  - 每次时钟中断时，计数器加`R`
  - 发生缺页中断时，选择计数器值最小的一页置换。

### 3.5.8 老化算法（AGING）

- 改进（模拟

  ```
  LRU
  ```

  ）：计数器在加R前先右移一位，

  ```
  R
  ```

  位加到计数器的最左端。

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-386d77e062537a7c.png?imageMogr2/auto-orient/strip|imageView2/2/w/618/format/webp)

  16

  这样如果

  ```
  R
  ```

  值为零，则计数器没有影响，如果值为

  ```
  1
  ```

  ，则会变得很大，于是如果一个页面长久不被访问，则计数器值就会越来越小。最后选择值最小的置换出去。

### 3.5.9 页面置换算法的应用

**例子：**

- 系统给某进程分配了三个页框（采用固定分配策略），初始为空
- 进程执行时，页面访问顺序为：`2 3 2 1 5 2 4 5 3 2 5 2`

**要求：**
计算应用`FIFO、LRU、OPT`算法时的缺页次数

**应用FIFO、LRU页面置换算法**



![img](https://upload-images.jianshu.io/upload_images/1925650-98a56255af42bb11.png?imageMogr2/auto-orient/strip|imageView2/2/w/514/format/webp)

17

可以看到

```
FIFO
```

发生六次缺页异常，而

```
LRU
```

发生四次缺页异常。



**应用OPT页面置换算法**



![img](https://upload-images.jianshu.io/upload_images/1925650-41e624a34bed722e.png?imageMogr2/auto-orient/strip|imageView2/2/w/514/format/webp)

18

发生三次缺页异常。



### 3.5.10 BELADY现象

例子：系统给某进程分配`m`个页框，初始为空页面访问顺序为
`1 2 3 4 1 2 5 1 2 3 4 5`，采用`FIFO`算法，计算当`m=3`和`m=4`时的缺页中断次数。
结论：`m=3`时，缺页中断九次；`m=4`时，缺页中断十次。注意：`FIFO`页面置换算法会产生异常现象（`Belady`现象），即：当分配给进程的物理页面数增加时，缺页次数反而增加。

## 3.6 页面置换算法2：工作集算法

### 3.6.1 影响缺页次数的因素

- 页面置换算法的不同
- 页面本身的大小
- 程序的编制方法
- 分配给进程的页框数量

缺页越多，系统的性能越差，这称为颠簸（抖动）：虚存中，页面在内存与磁盘之间频繁调度，使得调度页面所需的时间比进程实际运行的时间还多，这样导致系统效率急剧下降，这种现象称为颠簸或抖动。

### 3.6.2 页面尺寸问题

- 确定页面大小对分页的硬件设计非常重要，而对操作系统是个可选的参数
- 要考虑的因素
  内部碎片
  页表长度
  辅存的物理特性
- `Intel 80x86/Pentium: 4096`或`4M`
- 多种页面尺寸：为了有效使用`TLB`带来灵活性，但给操作系统带来复杂性。

### 3.6.3 程序编制方法对缺页次数的影响

例子：
分配了一个页框，页面大小为`128`个整数，矩阵`A(128 x 128)`按行存放。



![img](https://upload-images.jianshu.io/upload_images/1925650-27f92a6624e52587.png?imageMogr2/auto-orient/strip|imageView2/2/w/541/format/webp)

19

可以看到左边是按列赋值，右边是按行赋值。按列编制就是首先读入第一页（一行，因为矩阵是按行存放的），然后给第

```
0
```

个位置赋值，每次读入一行，直到将第

```
0
```

列赋值完，读完之后再给第

```
1
```

列赋值，这样会产生

```
128*128
```

次缺页异常；而按行赋值，第一次读入一页，给第

```
0
```

行的所有元素赋值，这样会产生

```
128
```

次缺页异常。于是可以看到程序的编制方法对缺页次数是有很大影响的。



### 3.6.4 分配给进程的页框数与缺页率的关系





![img](https://upload-images.jianshu.io/upload_images/1925650-86efa6eec17165c5.png?imageMogr2/auto-orient/strip|imageView2/2/w/560/format/webp)

20

说明：

可以看到页框数越多那么缺页率越低，但是我们不可能给出所有的页框，于是需要找到一个平衡点

```
W
```

，超过这个点之后页框数的增加对缺页率的降低有限，这也是工作集算法的出发点。



## 3.7 工作集模型

- 基本思想
  根据程序的局部性原理，一般情况下，进程在一段时间内总是集中访问一些页面，这些页面称为活跃页面，如果分配给一个进程的物理页面数太少了，使得该进程所需的活跃页面不能全部装入内存，则进程在运行过程中将频繁发生中断。

如果能为进程提供与活跃页面数相等的物理页面数，则可减少缺页中断次数，这是由`Denning`提出的。

- 工作集：一个进程当前正在使用的页框集合

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-feb7c87d0367026e.png?imageMogr2/auto-orient/strip|imageView2/2/w/603/format/webp)

  21

- 例子

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-8e203b51036e0b37.png?imageMogr2/auto-orient/strip|imageView2/2/w/520/format/webp)

  22

## 3.8 工作集算法

- 基本思路
  找出一个不在工作集的页面并置换它
  - 每个页表项中有一个字段：记录该页面最后一次被访问的时间
  - 设置一个时间值`T`
  - 判断
    根据一个页面的访问时间是否落在“当前时间 - `T`”之前或之中决定其在工作集之外还是之内。
- 实现：扫描所有页表项，执行操作
  1、如果一个页面的`R`位是`1`，则将该页面的最后一次访问时间设为当前时间，将`R`位清零
  2、如果一个页面的`R`位为`0`，则检查该页面的访问时间是否在“当前时间 - `T`”之前，如果是，则该页面是需要被置换的页面；否则，记录当前所有被扫描过页面的最后访问时间里面最小值。扫描下一个页面并重复上述操作。

# 四、其他与存储管理相关技术

## 4.1 内存映射文件

- 基本思想
  进程通过一个系统调用（`mmap`）将一个文件（或部分）映射到其虚拟地址空间的一部分，访问这个文件就像访问内存中的一个大数组，而不是对文件进行读写

- 在多数实现中，在映射共享的页面时不会实际读入页面的内容，而是在访问页面时，页面才会被每次一页的读入，磁盘文件则被当作后备存储。

- 当进程退出或显式地解除文件映射时，所有被修改页面会写回文件

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-336ff172ccc06e72.png?imageMogr2/auto-orient/strip|imageView2/2/w/673/format/webp)

  23

## 4.2 支持写时复制技术





![img](https://upload-images.jianshu.io/upload_images/1925650-2b675d9951b04615.png?imageMogr2/auto-orient/strip|imageView2/2/w/596/format/webp)

24

说明：

如图，两个进程共享同一块物理内存，每个页面都被标志成了写时复制。注意：共享的物理内存中每个页面都是只读的。如果每个进程想改变某个页面时，就会与只读标记冲突，而系统在检测出页面是写时复制的，则会在内存中复制一个页面，然后进行写操作。新复制的页面对执行写操作的进程是私有的，对其他共享写时复制页面的进程是不可见的。



# 13、文件系统1（操作系统笔记）

![img](https://upload.jianshu.io/users/upload_avatars/1925650/7a95dfb3c842.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[yjaal](https://www.jianshu.com/u/9231f33f0db3)关注

0.0962017.01.08 11:54:06字数 4,159阅读 730

# 一、文件与文件系统

## 1.1 文件是什么

- 文件是对磁盘的抽象

- 所谓文件是指一组带标识（标识即为文件名）的、在逻辑上有完整意义的信息项的序列。

- 信息项：构成文件内容的基本单位（单个字节，或多个字节），各信息项之间具有顺序关系

- 文件内容的意义：由文件建立者和使用者解释

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-74efeaffedc209e9.png?imageMogr2/auto-orient/strip|imageView2/2/w/805/format/webp)

  1

## 1.2 如何设计一个文件系统

这里先看文件管理的需求：

- 从用户角度
  文件系统是如何呈现在用户面前：
  - 一个文件的组织
  - 如何命名
  - 如何保护文件
  - 可以实施的操作
- 从操作系统角度：怎样组织、管理文件
  - 文件的描述、分类
  - 文件目录的实现
  - 存储空间的管理
  - 文件的物理地址
  - 磁盘实际运作方式（与设备管理的接口）
  - 文件系统的性能

## 1.3 文件系统

- 操作系统中统一管理信息资源的一种软件，管理文件的存储、检索、更新，提供安全可靠的共享和保护手段，并且方便用户使用
- 文件系统要完成哪些任务
  1、统一管理磁盘空间，实施磁盘空间的分配与回收
  2、实现文件的按名存取：名字空间--映射-->磁盘空间
  3、实现文件信息的共享，并提供文件的保护、保密手段
  4、向用户提供一个方便使用、易于维护的接口，并向用户提供有关统计信息
  5、提高文件系统的性能
  6、提供与`IO`系统的统一接口

## 1.4 文件的分类

按文件性质和用途分类（`UNIX`），一般分为普通文件、目录文件、特殊文件（设备文件）、管道文件、套接字

- 普通文件
  即用户自己建立的文件，包含了用户的信息，一般为`ASCII`或二进制文件
- 目录文件
  管理文件系统的系统文件
- 特殊文件
  字符设备文件：和输入输出有关，用户模仿串行`I/O`设备，例如终端、打印机、网卡等。
  块设备文件：磁盘

## 1.5 文件的逻辑结构





![img](https://upload-images.jianshu.io/upload_images/1925650-c8960669e64a0767.png?imageMogr2/auto-orient/strip|imageView2/2/w/848/format/webp)

2

说明：

这里是从用户角度看文件，由用户的访问方式确定，这里给出了三种逻辑结构，还可以组织成堆、顺序、索引、索引顺序、散列等结构。第一种是以字节为单位的流式结构，第二种是一种记录式文件结构，最后一种是树形结构。



## 1.6 典型的文件逻辑结构与文件存取

- 流式文件：构成文件的基本单位是字符
  文件是有逻辑意义、无结构的一串字符的集合
- 记录式文件：文件由若干记录组成，可以按记录进行读写、查找等操作。每条记录有其内部结构
- 文件的逻辑结构与文件存取之间的关系
  顺序存取（访问）
  随机存取：提供读写位置（当前位置）。如`UNIX`的`seek`操作。

## 1.7 文件的存储介质

### 1.7.1 存储介质与物理块

- 典型的存储介质
  磁盘（包括固态盘`SSD`）、磁带、光盘、`U`盘、......
- 物理块（块`block`、簇`cluster`）
  信息存储、传输、分配的独立单位
  存储设备划分为大小相等的物理块，统一编号

### 1.7.2 典型的磁盘结构



![img](https://upload-images.jianshu.io/upload_images/1925650-8cd835977b08e183.png?imageMogr2/auto-orient/strip|imageView2/2/w/634/format/webp)

3

### 1.7.3 磁盘访问

一次访问磁盘的请求：读写、磁盘地址（设备号、柱面号、磁头号、扇区号），内存地址（源/目）
完成过程由三个动作组成：

- 寻道（时间）：磁头移动定位到指定磁道
- 旋转延迟（时间）：等待指定扇区从磁头下旋转经过
- 数据传输（时间）：数据在磁盘与内存之间的实际传输

### 1.7.4 磁盘空间管理

**有关数据结构**

- 位图
  用一串二进制位反映磁盘空间中分配使用情况，每个物理块对应一位，分配的物理块为`0`，否则为`1`。
  申请物理块时，可以在位示图中查找`1`的位，返回对应的物理块号
  归还时，将对应位转置`1`。
- 空闲块表
  将所有空闲块记录在一个表中，即空闲块表
  主要两项内容：起始块号，块数
- 空闲块链表
  把所有空闲块链成一个表
  扩展：成组链接法

**磁盘地址与块号的转换**



![img](https://upload-images.jianshu.io/upload_images/1925650-7c3872cbf14392bf.png?imageMogr2/auto-orient/strip|imageView2/2/w/609/format/webp)

4



**成组链接法设计思想**



![img](https://upload-images.jianshu.io/upload_images/1925650-59304b5e3a722c2c.png?imageMogr2/auto-orient/strip|imageView2/2/w/687/format/webp)

5

说明：

左上角的是一个专用块，表示一些有用信息，而右边大括号中的都是空闲块。所有空闲块我们分成了若干组，典型的是

```
100
```

块是一组，最后一个空闲组只有

```
99
```

个空闲块。专用块中有

```
20
```

个空闲块号，分别对应右边的空闲块组。每次要使用文件的时候，就从专用块中挑选空闲块，一般从

```
801
```

开始分配。

```
820
```

中的第一块实际上是记录了后面一块

```
800
```

中空闲块的空闲块号和总的空块的数量，后面的以此类推。最后一个组中的

```
0
```

则表示最后一组的标志。



**成组链接法：分配算法**
分配一个空闲块
查`L`单元（空闲块数）

- 当`空闲块数 > 1 , i = L + 空闲块数`；
  从i单元得到一个空闲块号；
  把该块分配给申请者；
  空闲块数减1
- 当`空闲块数 = 1`， 取出`L + 1`单元内容（一组的第一块号或`0`）；
  其`值 = 0`无空闲块，申请者等待
  其值不等于零，把该块内容复制到专用块
  该块分配给申请者；

把专用块内容读到内存`L` 开始的区域。

**成组链表法：回收算法**
归还一块
查`L`单元的空闲块数

- 当`空闲块数 < 100`空闲块数加一；
  `j := L + 空闲块数`
  归还块号填入`j`单元
- 当`空闲块数 = 100`， 则把内存中登记的信息写入归还块中；
  把归还块号填入`L+ 1`单元；
  将`L`单元置成`1`。

# 二、文件控制块和文件目录

## 2.1 文件属性

- 文件控制块（`File Control Block：FCB`）
  为管理文件而设置的数据结构，保存管理文件所需的所有有关信息（文件属性或元数据）

- 常用属性
  文件名，文件号，文件大小，文件地址，创建时间，最后修改时间，最后访问时间，保护，口令，创建者，当前拥有者，文件类型，共享计数，各种标志（只读、隐藏、系统、归档、`ASCII`/二进制、顺序/随机访问、临时文件、锁）

- 基本文件操作

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-a7252ea315164a56.png?imageMogr2/auto-orient/strip|imageView2/2/w/501/format/webp)

  6

## 2.2 文件目录、目录项与目录文件

- 文件目录
  - 统一管理每个文件的元数据，以支持文件名到文件物理地址的转换
  - 将所有文件的管理信息组织在一起，即构成文件目录
- 目录文件
  将文件目录以文件的形式存放在磁盘上
- 目录项
  - 构成文件目录的基本单元
  - 目录项可以是`FCB`，目录是文件控制块的有序集合

## 2.3 文件目录结构的演化





![img](https://upload-images.jianshu.io/upload_images/1925650-5b31f3fd82550873.png?imageMogr2/auto-orient/strip|imageView2/2/w/708/format/webp)

7

说明：

最初是以一级目录结构，最后慢慢演化成了树形目录结构。



## 2.4 与目录相关的概念

- 路径名
  绝对路径名：从根目录开始
  相对路径：从当前目录开始
- 当前目录/工作目录
- 目录操作
  创建目录、删除目录等等

## 2.4 目录文件之间的关联



![img](https://upload-images.jianshu.io/upload_images/1925650-4764f4a10e1dc272.png?imageMogr2/auto-orient/strip|imageView2/2/w/413/format/webp)

8

# 三、文件的物理结构

文件在存储介质上的存放方式

主要解决两个问题：

- 假设一个文件被划分成`N`块，这N块在磁盘上是怎么存放的？
- 其地址（块号或簇号）在`FCB`中是怎样记录的？

## 3.1 连续（顺序）结构

- 文件的信息存放在若干连续的物理块中

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-4be8f965043db9f2.png?imageMogr2/auto-orient/strip|imageView2/2/w/608/format/webp)

  9

  在上图

  ```
  a
  ```

  中，存放者多个连续的文件，在

  ```
  b
  ```

  中有些磁盘空间被还回来了。如果有些块太小，可能就不能再利用了。在

  ```
  FCB
  ```

  中我们只需要给出文件块的首地址和块数即可。

  

- 优点
  简单
  支持顺序存取和随机存取
  所需的磁盘寻道次数和寻道时间最少
  可以同时读入多个块，检索一个块也很容易

- 缺点

  - 文件不能动态增长，因为可能后面的磁盘空间已经被占据了。如果要增长则需要给出预留空间，但是这样就导致了浪费或重新分配和移动的开销。
  - 不利于文件插入和删除
  - 产生外部碎片：可以使用紧缩技术进行整理

## 3.2 链接结构

- 一个文件的信息存放在若干不连续的物理块中，各块之间通过指针连接，前一个物理块指向下一个物理块

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-a1d865263a766d5a.png?imageMogr2/auto-orient/strip|imageView2/2/w/612/format/webp)

  10

  说明：

  在

  ```
  FCB
  ```

  中我们只需要给出第一块的块号即可。

  

- 优点

  - 提高了磁盘空间的利用率，不存在外部碎片问题
  - 有利于文件插入和删除
  - 有利于文件动态扩充

- 缺点

  - 存取速度慢，不适于随机存取
  - 可靠性问题，如指针出错
  - 更多的寻道次数和寻道时间
  - 链接指针占用一定的空间

于是我们可以对此种结构进行某种改造：文件分配表`FAT`

## 3.3 文件分配表（FAT）





![img](https://upload-images.jianshu.io/upload_images/1925650-d4101a0c24704849.png?imageMogr2/auto-orient/strip|imageView2/2/w/533/format/webp)

11

说明：

是把所有物理块的表指针都几种存放在一张表中，而不是用一个物理块的一部分来存放指针。从图中可以看到文件

```
A
```

的块号是

```
4
```

，而其下一个物理块的表项为

```
7
```

，最后到值为

```
-1
```

则表示结束。那某文件的起始块号从哪里得到？其实起始块号就记录在了

```
FCB
```

中。这种结构一般用在

```
Windows
```

中。在

```
UNIX
```

中一般采用索引结构。



## 3.4 索引结构

- 一个文件的信息存放在若干个不连续物理块中
- 系统为每个文件建立一个专用数据结构：索引表，并将这些物理块的块号存放在该索引中。
- 索引表就是磁盘块地址数组，其中地`i`个条目指向文件的第`i`块。

那索引表应该存放在何处？
这里必须知道每个文件的索引表长度是不一样的，于是不能存放在`FCB`中，因为`FCB`是固定大小的。于是我们在`FCB`中只记录索引表的地址。



![img](https://upload-images.jianshu.io/upload_images/1925650-b5881cae19c5ab90.png?imageMogr2/auto-orient/strip|imageView2/2/w/615/format/webp)

12

说明：

文件

```
B
```

的索引块号是

```
24
```

，索引表是存放在一个物理块中的。索引块中就记录了分配给这个文件的物理块号，可以看到这里我们是可以随机存取的。



- 优点
  保持了链接结构的优点，又解决了其缺点

  - 既能顺序存取，又能随机存取
  - 满足了文件动态增长、插入删除的要求
  - 能充分利用磁盘空间

- 缺点

  - 较多的寻道次数和寻道时间
  - 索引表本身带来了系统开销，如：内存、磁盘空间、存取时间

- 组织方式
  问题：索引表很大，需要多个物理块存放时怎么办？

  - 1、链接方式
    一个盘块存一个索引表，多个索引表链接起来
  - 2、多级索引方式
    将文件的索引表地址放在另一个索引表中
  - 3、综合模式
    直接索引方式与间接索引方式结合

- 多级索引与综合模式

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-071b965f9d9bd1ca.png?imageMogr2/auto-orient/strip|imageView2/2/w/681/format/webp)

  13

  说明：

  图上部分是多级索引模式，此模式中顶级索引表中都记录的是次级索引表地址。而在图下部分则是综合模式，顶级索引表中一部分记录的是直接的物理块，而另一部分是记录的次级索表块地址，即一部分是直接寻址，一部分是间接寻址。

  

## 3.5 UNIX的三级索引结构

在`UNIX`文件系统中采用的是多级索引结构（综合模式）

- 每个文件的主索引表有`15`个索引项（`FCB`中），每项两个字节

- 前`12`项直接存放文件的物理块号（直接寻址）

- 如果文件大于`12`块，则利用第`13`项指向一个物理块，在该块中存放的是一级索引表。假设扇区大小为`512`字节，物理块等于扇区块大小，一级索引表可以存放`256`个物理块号

- 对于更大的文件还可以利用第`14`项和第`15`项作为二级和三级索引表

- 问题：采用这种结构，一个文件最大可以达到多少个物理块

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-69354101232d8009.png?imageMogr2/auto-orient/strip|imageView2/2/w/767/format/webp)

  14

# 四、文件系统的实现

## 4.1 概述

- 实现文件系统需要考虑磁盘上和内存中的内容布局
- 磁盘上
  如何启动操作系统？
  磁盘是怎样管理的？怎样获取磁盘的有关信息？
  目录文件在磁盘上怎么存放？普通文件在磁盘上怎么存放？
- 内存中
  当进程使用文件时，操作系统是如何支持的？
  文件系统的内存数据结构

## 4.2 相关术语

- 磁盘分区
  把一个物理磁盘的存储空间划分为几个相互独立的部分，称为分区
- 文件卷
  磁盘上的逻辑分区，由一个或多个物理块组成。
  - 一个文件卷可以是整个磁盘或部分磁盘或跨盘（`RAID`）
  - 同一个文件卷使用同一份管理数据进行文件分配和磁盘空闲空间管理，不同的文件卷中的管理数据是相互独立的。
  - 一个文件卷上包括文件系统信息、一组文件（用户文件、目录文件）、未分配空间
  - 块或簇：一个或多个（`2`的幂次方）连续的扇区，可寻址数据库
- 格式化
  在一个文件卷上建立文件系统，即建立并初始化用于文件分配和磁盘空闲空间管理的管理数据

## 4.3 磁盘上的内容



![img](https://upload-images.jianshu.io/upload_images/1925650-b0c748b7e59ed918.png?imageMogr2/auto-orient/strip|imageView2/2/w/763/format/webp)

15

- 引导区
  包括了从该卷引导操作系统所需的信息，每个卷（分区）都有一个，通常称为扇区
- 卷信息
  包括该卷的块数、块大小、空闲块数量和指针、空闲FCB数量和指针等等
- 目录文件

## 4.4 磁盘上文件系统的布局



![img](https://upload-images.jianshu.io/upload_images/1925650-5f65f562269485ff.png?imageMogr2/auto-orient/strip|imageView2/2/w/678/format/webp)

16

## 4.5 内存中所需的数据结构（以UNIX为例）



![img](https://upload-images.jianshu.io/upload_images/1925650-6e8653becf6e2fbc.png?imageMogr2/auto-orient/strip|imageView2/2/w/588/format/webp)

17

# 五、文件系统实例（UNIX）

## 5.1 文件目录检索

访问一个文件-->两步骤

- 目录检索

  用户给出文件名-->按文件名查找到目录项/

  ```
  FCB
  ```

  根据路径名检索：

  - 全路径名：从根目录开始
  - 相对路径：从当前目录开始

- 文件寻址
  根据目录想/`FCB`中文件物理地址等信息，计算出文件中任意记录或字符在存储介质上的地址

## 5.2 目录文件实现时的改进

- 问题：如何加快目录检索？

- 一种解决方案

  目录项分解法：即把

  ```
  FCB
  ```

  分成两部分

  - 符号目录项：文件名，文件号

  - 基本目录项：除文件名外的所有字段

    

    ![img](https://upload-images.jianshu.io/upload_images/1925650-ce2d49339ed3544f.png?imageMogr2/auto-orient/strip|imageView2/2/w/702/format/webp)

    18

    说明：

    每个方格表示目录文件（由目录项组成），每个椭圆表示普通文件。如何我们采用目录项分解法，于是符号目录项中的内容就特别简单，此时目录项就变成了符号目录项；基本目录项保存在了磁盘的专用区域。

- 好处
  假设一个`FCB`占`48`个字节，物理块大小`512`字节。符号目录项占`8`字节（文件名`6`字节，文件号`2`字节），基本目录项占`48-5 = 42`字节。
  这里给出一个目录文件有`128`个目录项，在分解前则需要`13`个物理块，分解后符号目录项占`2`块，基本目录项占`11`块。总块数是不变的，但是查找一个文件的平均访问磁盘的次数分解前为`(1+13)/2=7`次，分解后为`(1+2)/2 + 1 = 2.5`次。于是就提高了文件检索的速度。

# 六、UNIX文件系统

- `FCB`= 目录项 +`i`节点

- 目录项：文件名 +`i`节点号

- 目录文件由目录项构成

- `i`节点：描述文件的相关信息

- 每个文件由一个目录项、一个

  ```
  i
  ```

  节点和若干磁盘块构成

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-444d6815fbaa19ac.png?imageMogr2/auto-orient/strip|imageView2/2/w/714/format/webp)

  19

  说明：

  上图是

  ```
  UNIX
  ```

  系统的文件布局。下面看如何查找一个文件

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-b83fd10c162c9df2.png?imageMogr2/auto-orient/strip|imageView2/2/w/676/format/webp)

  20

  说明：

  要查找的文件为

  ```
  /usr/ast/mbox
  ```

  ，根目录文件中一个点表示本目录的目录项，两个点表示父目录的目录项，每个目录项都包含文件名和

  ```
  i
  ```

  节点号。从

  ```
  i
  ```

  节点中可以知道这个文件的第一块存放在

  ```
  128
  ```

  这个位置，于是我们读取

  ```
  usr
  ```

  中的内容，从这个目录中去找

  ```
  ast
  ```

  这个文件，以此类推。

# 14、文件系统2（操作系统笔记）

![img](https://upload.jianshu.io/users/upload_avatars/1925650/7a95dfb3c842.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[yjaal](https://www.jianshu.com/u/9231f33f0db3)关注

2017.01.11 12:01:40字数 1,893阅读 356

# 一、文件系统实例（FAT）

## 1.1 Windows的FAT16文件系统

- 簇（块）大小：`1、2、4、8、16、32`或`64`扇区

- 文件系统的数据记录在“引导扇区”中

- 文件分配表`FAT`的作用
  描述簇的分配状态、标注下一簇的簇号等

- `FAT`表项：`2`字节（`16`位）

- 目录项：`32`字节

- 根目录大小固定

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-07c3190d0294a1e7.png?imageMogr2/auto-orient/strip|imageView2/2/w/859/format/webp)

  1

## 1.2 FAT文件系统：主引导记录（Main Boot Record，MBR）

- 主引导记录
  一般放在零号扇区中

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-498acad13a97de06.png?imageMogr2/auto-orient/strip|imageView2/2/w/848/format/webp)

  2

## 1.3 FAT文件系统：分区引导扇区（Dos Boot Record，DBR）





![img](https://upload-images.jianshu.io/upload_images/1925650-6447004bc059aa1a.png?imageMogr2/auto-orient/strip|imageView2/2/w/712/format/webp)

3

说明：

这里是以

```
FAT32
```

为例。



## 1.4 引导扇区（BIOS参数块）





![img](https://upload-images.jianshu.io/upload_images/1925650-fd14eb89ac34f95e.png?imageMogr2/auto-orient/strip|imageView2/2/w/697/format/webp)

4

说明：

这里我们看

```
BIOS
```

参数块，也是以

```
FAT32
```

为例。



## 1.5 引导扇区（扩展BIOS参数块EBPB）



![img](https://upload-images.jianshu.io/upload_images/1925650-af3f40feaae773a7.png?imageMogr2/auto-orient/strip|imageView2/2/w/659/format/webp)

5

## 1.6 文件分配表FAT

- 可以把文件分配表看成是一个整数数组，每个整数代表磁盘分区的一个簇号

- 状态
  未使用、坏簇、系统保留、被文件占用（下一簇簇号）、最后一簇（`0xFFFF`）

- 簇号从

  ```
  0
  ```

  开始编号，簇

  ```
  0
  ```

  和簇

  ```
  1
  ```

  是保留的。

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-a2058c54f39d0785.png?imageMogr2/auto-orient/strip|imageView2/2/w/452/format/webp)

  6

## 1.7 FAT16目录项





![img](https://upload-images.jianshu.io/upload_images/1925650-358f338f75a2e8b4.png?imageMogr2/auto-orient/strip|imageView2/2/w/605/format/webp)

7

说明：

在前面讲过，

```
UNIX
```

系统中

```
i
```

节点加上目录项就是

```
FCB
```

，而在

```
FAT
```

文件系统中

```
FCB
```

就等于目录项。

```
32
```

个字节没有用完，没用完的保留。



## 1.8 FAT32文件系统

- 在`FAT32`中，根目录区（`BOOT`区）不是固定区域、固定大小，而是数据区的一部分，采用与子目录文件相同的管理方式

- 目录项仍占`32`字节，但分为各种类型（包括：`“.”`目录项、`“..”`目录项、短文件名目录项、长文件名目录项、卷标项（根目录）、已删除目录项（第一字节为`0xE5`）等）

- 支持长文件名格式

- 支持`Unicode`

- 不支持高级容错特性，不具有内部安全特性

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-aac929b62be650e9.png?imageMogr2/auto-orient/strip|imageView2/2/w/661/format/webp)

  8

## 1.9 FAT32目录项





![img](https://upload-images.jianshu.io/upload_images/1925650-4aff42d923926b9c.png?imageMogr2/auto-orient/strip|imageView2/2/w/706/format/webp)

9

说明：

这是一个基本的目录项。



## 1.10 一般长文件名的实现方式





![img](https://upload-images.jianshu.io/upload_images/1925650-2f4ea40ad80f0585.png?imageMogr2/auto-orient/strip|imageView2/2/w/577/format/webp)

10

说明：

左边的实现是目录项的长度不固定。第一个字段给出目录项的长度，然后把固定长度的属性记录在其后，再才是文件名，因为文件名的长度是不一样的，留出足够的空间给文件名。缺点就是一个文件删除时，就留出了一块空间，而这个空间可能不能放下其他文件，这样就会产生碎片。右边的实现是由于文件名的长度不固定，所以我们希望每个目录项的大小是固定的，其中包含了一个指向文件名起始地址的指针，然后是文件的相关属性，所有的文件名都存放在另一个区域（堆）。



## 1.11 FAT32中长文件名目录项格式





![img](https://upload-images.jianshu.io/upload_images/1925650-4652537e6551948d.png?imageMogr2/auto-orient/strip|imageView2/2/w/602/format/webp)

11

说明：

其中有三处地方分别记录了文件名。前

```
5
```

个字符（采用的是

```
Unicode
```

编码，则两个字节代表一个字符）保存文件名的前

```
5
```

个字符，于是一共可以保存

```
13
```

个字符。如果一个长文件名目录项不够，则需要用第二个。在第一个字段中第

```
6
```

位来记录是否是最后一个目录项。下面看一个例子，文件名为

```
The quick brown.fox
```

，采用

```
Unicode
```

编码。



![img](https://upload-images.jianshu.io/upload_images/1925650-9ee52bad9bf9882b.png?imageMogr2/auto-orient/strip|imageView2/2/w/754/format/webp)

12

说明：

其实这样一个文件占用了三个目录项。第一个目录项就是短文件名目录项，后面的两个目录项主要保存文件名。再看一个更长的文件名文件例子：



![img](https://upload-images.jianshu.io/upload_images/1925650-3cd47dfeae6f436e.png?imageMogr2/auto-orient/strip|imageView2/2/w/631/format/webp)

13

说明：

这里的文件名更长，需要占用五个目录项。



# 二、文件操作的实现

这里主要是以`UNIX`操作系统为例。

## 2.1 文件操作的实现

- 创建文件
  建立系统与文件的联系，实质是建立文件的`FCB`
  - 在目录中为新文件建立一个目录项（在`UNIX`中还需要`i`节点），根据提供的参数及需要填写相关内容
  - 分配必要的存储空间
- 打开文件
  根据文件名目录中检索，并将该文件的目录项读入内存，建立相应的数据结构，为后续的文件操作做好准备。打开文件后一般会返回一个值，这个值一般叫文件描述符或文件句柄，之后的操作是通过文件描述符来进行的。

## 2.2 文件操作：建立文件

**create**（文件名，访问权限）

- 1、检查参数的合法性
  例如：文件名是否符合命名规则；有无重名文件，合法则进行下一步，否则报错返回。
- 2、申请空闲目录项，并填写相关内容
- 3、为文件申请磁盘块
- 4、返回

## 2.3 文件操作：打开文件

为文件读写做准备：给出文件路径名，获得文件句柄（`file handler`）或文件描述符（`file descripter`），需将该文件的目录项读到内存`fd = open`（文件路径名，打开方式）

- 1、根据文件路径名查目录，找到目录项（或`i`节点号）
- 2、根据文件号查系统打开文件表，看文件是否已被打开，如果是，则共享计数加一，否则，将目录项（或i节点）等信息填入系统打开文件表空表项，共享计数置为一。
- 3、根据打开方式、共享说明和用户身份检查访问合法性
- 4、在用户打开文件表中获取一空表项，填写打开方式等，并指向系统打开文件表对应表项，返回信息：`fd`（文件描述符，是一个非负整数，用于以后读写文件）

## 2.4 文件操作：指针定位

**seek**（`fd`， 新指针位置）：系统为每个进程打开的每个文件维护一个读写指针，即相对于文件开头的偏移地址（读写指针指向每次文件读写的开始位置 ，在每次读写完成后，读写指针按照读写的数据量自动后移相应的数值）

- 1、由`fd`查用户打开文件表，找到对应的表项
- 2、将用户打开文件表中文件读写指针位置设为新指针的位置，供后继读写命令存取该指针处文件内容。

## 2.5 文件操作：读文件

**read**（文件描述符，读指针，要读的长度，内存目的地址）

- 1、根据打开文件时得到的文件描述符，找到相应的文件控制块（目录项），确定读操作的合法性，读操作合法则进行下一步，否则出错处理。
- 2、将文件的逻辑块号转换为物理块号。根据参数中的读指针、长度与文件控制块中的信息，确定块号、块数、块内位移
- 3、申请缓冲区
- 4、启动磁盘`I/O`操作，把磁盘块中的信息读入缓冲区，再送到指定的内存区（多次读盘）
- 5、反复执行`3、4`直至读出所需数量的数据或读至文件尾

# 三、文件系统的管理

## 3.1 文件系统的可靠性

可靠性：抵御和预防各种物理性破坏和人为性破坏的能力

- 块坏问题
- 备份
  通过转储操作，形成文件或文件系统的多个副本。

## 3.2 文件系统备份

- 全量转储
  定期将所有文件拷贝到后援存储器
- 增量转储
  只转储修改过的文件，即两次备份之间的修改。减少系统开销。
- 物理转储
  从磁盘第零块开始，将所有磁盘块按序输出到磁带
- 逻辑转储
  从一个或几个指定目录开始，递归地转储子给定日期后所有更改的文件和目录

## 3.3 文件系统一致性

- 问题的产生：
  磁盘块-->内存-->写回磁盘块
  若在写回之前，系统崩溃，则文件系统出现不一致
- 解决方案
  设计一个使用程序，当系统再次启动时，运行该程序，检查磁盘块和目录系统

## 3.4 磁盘块的一致性检查





![img](https://upload-images.jianshu.io/upload_images/1925650-2f9b9818ff7458be.png?imageMogr2/auto-orient/strip|imageView2/2/w/679/format/webp)

14

说明：：

一致性检查时，检查所有的文件和空闲块，检查完之后可能会出现四种结果。第一种是一个一致性的结果，即某个磁盘块要么分配给了某个文件，要么在空闲块中。第二种结果是在空闲块中找不到，但是也没有分配给某个文件，于是我们通过在空闲块表中将磁块标记为一来解决。第三种结果是某个磁盘块在空闲块表中出现了两次，同样是不合理的，对这一位进行修改。最后一种结果是在两个文件中出现，这种情况较为复杂，我们应该在空闲块中找一个，然后将其中一个磁盘块内容拷贝到这个空闲块中，然后将使用块表中的这一位减一。



## 3.5 文件系统的写入策略

对某些文件做出了修改，那么什么时候将修改后的内容写入到文件中。这里需要考虑文件系统一致性和速度。下面有几种写入策略

- 通写（`write-through`）
  内存中的修改立即写到磁盘。缺点是速度性能差，如`FAT`文件系统。
- 延迟写（`lazy-write`）
  利用回写（`write back`）缓存的方法得到高速。其缺点就是可恢复性较差，可能会导致信息丢失
- 可恢复写（`tansaction log`）
  采用事务日志来实现文件系统的写入，既考虑安全性，又考虑速度性能，如`NTFS`

# 15、文件系统3（操作系统笔记）

![img](https://upload.jianshu.io/users/upload_avatars/1925650/7a95dfb3c842.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[yjaal](https://www.jianshu.com/u/9231f33f0db3)关注

2017.01.12 11:45:28字数 3,094阅读 331

# 四、文件系统的安全性

这里我们讨论如何确保未经授权的用户不能存取某些文件？

## 4.1 文件保护机制

- 用于提供安全性、特定的操作系统机制
- 对拥有权限的用户，应该让其进行相应的操作，否则，应禁止
- 防止其他用户冒充对文件进行操作

于是在实现的时候需要考虑用户身份验证和访问控制。对于用户身份我们可以采用比如密码、口令等方式。

## 4.2 文件的访问控制

有不同的访问控制手段，比如主动控制（使用访问控制表）和能力表（使用权限表）。

- 主动控制
  每个文件一个
  记录用户`ID`和访问权限
  用户可以是一组用户
  文件可以是一组文件
- 能力表
  每个用户一个
  记录文件名及访问权限
  用户可以是一组用户
  文件可以是一组文件

## 4.3 UNIX的文件访问控制

采用文件的二级存取控制，审查用户的身份、审查操作的合法性

- 第一级：对访问者身份的识别
  对用户分类：
  - 文件主（`owner`）
  - 文件主的同组用户（`group`）
  - 其他用户（`other`）
- 第二级：对操作权限的识别
  对操作分类：
  - 读操作（`r`）
  - 写操作（`w`）
  - 执行操作（`x`）
  - 不能执行任何操作（`-`）

# 五、文件系统的性能

## 5.1 文件系统的性能问题

- 磁盘服务：速度成为系统性能的主要瓶颈之一。因此，在设计文件系统时应尽可能减少磁盘访问次数
- 提高文件系统性能的方法：
  目录项（`FCB`）分解、当前目录、磁盘碎片整理、块高速缓存、磁盘调度、提前读取、合理分配磁盘空间、信息的优化分布、`RAID`技术等等

## 5.2 提高文件系统性能：块高速缓存（BLOCK CACHE）

又称为文件缓存、磁盘高速缓存、缓冲区高速缓存。是指在内存中为磁盘块设置的一个缓冲区，保存了磁盘中某些块的副本。当对文件系统进行操作的时候：

- 检查所有的读请求，看所需块是否在块高速缓冲中
- 如果在，则可直接进行读操作；否则，先将数据块读入块高速缓存，再拷贝到所需的地方。
- 由于访问的局部性原理，当一数据块被读入块高速缓存以满足一个`I/O`请求时，和可能将来还会再次访问到这一数据块。

## 5.3 如何实现块高速缓存

- 块高速缓存的组织方式

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-bd2f816138a58033.png?imageMogr2/auto-orient/strip|imageView2/2/w/639/format/webp)

  1

  说明：

  在块高速缓存中有若干个数据块，首先将这些块使用一个双向链表组织起来，当要访问这个链的时候就将其从此链中拿出来，然后挂接到链尾，而我们对于某个文件使用的块要检查其是否在高速缓存中，所以这里又使用块号进行散列以提高检查速度。

  

- 块高速缓存的置换问题（修改`LRU`）
  因为此缓存的空间肯定是不会很大的，所以当其满时我们需要对其进行置换。对于以后可能会再次使用的块我们将其放在链尾，而对于使用概率很小的块可能就需要将其剔除。

- 块高速缓存的写入策略
  在文件系统中，我们需要考虑该块是否会影响文件系统的一致性。这里如前面所讲，不同的操作系统采用了不同的一致性解决方案。

- 提前读取

  - 思路：每次访问磁盘，多读入一些磁盘块
  - 依据：程序执行的空间局部性原理
  - 开销：较小（只有数据传输时间）
  - 具有针对性

## 5.4 Windows的文件访问方式

**一般有下面三种方式：**

- 不使用文件缓存
  - 普通方式
  - 通过`Windows`提供的`FlushFileBuffer`函数实现
- 使用文件缓存（块高速缓存）
  - 预读取。每次读取的块大小、缓冲区大小、置换方式
  - 写回。写回时机选择、一致性问题
- 异步模式
  - 不再等待磁盘操作的完成。
  - 使处理器和`I/O`并发工作

**用户对磁盘的访问通过访问文件缓存来实现：**

- 由`Windows`的`Cache Manager`实现对缓存的控制

  - 读取数据的时候预取
  - 在`Cache`满时，根据`LRU`原则清除缓存的内容
  - 定期更新磁盘内容使其与`Cache`一致（每秒）

- `write-back`机制

  - 在用户要对磁盘写数据时，只更改

    ```
    Cache
    ```

    中的内容，由

    ```
    Cache Manager
    ```

    决定何时将更新反映到磁盘

    

    ![img](https://upload-images.jianshu.io/upload_images/1925650-4be61e9c794b3808.png?imageMogr2/auto-orient/strip|imageView2/2/w/618/format/webp)

    2

## 5.5 提高文件系统性能：合理分配磁盘空间

分配磁盘块时，把有可能顺序存取的块放在一起（尽量分配在同一柱面上，从而减少磁盘臂的移动次数和距离）



![img](https://upload-images.jianshu.io/upload_images/1925650-c605afaa04e8966a.png?imageMogr2/auto-orient/strip|imageView2/2/w/607/format/webp)

3

说明：

我们读取文件系统时，每次都要先找到

```
i
```

节点区，然后再去找到文件位置，如果

```
i
```

节点区在最外道，而相关文件在最里道，则在读取的时候磁臂就需要不断的移动，这样显示效率低下。一种解决方案如

```
(a)
```

，我们将

```
i
```

节点区和相关文件放在距离较近的磁道上；另一种是如

```
(b)
```

，首先将磁道分成了若干组，然后将i节点区也划分成若干部分，每一组磁道都有一个

```
i
```

节点区，而每个文件都和其

```
i
```

节点区在同一组，这样磁臂也不需要很大的移动。



## 5.6 提高文件系统性能：磁盘调度

当有多个访盘请求等待时，采用一定的策略，对这些请求的服务顺序调整安排，从而降低平均磁盘服务时间，达到公平、高效的目的。

- 公平
  一个IO请求在有限时间内满足
- 高效
  减少设备机械运动带来的时间开销

一次访盘时间 = 寻道时间 + 旋转延迟时间 + 传输时间

- 减少寻道时间
- 减少延迟时间

## 5.7 磁盘调度算法

例子：假设磁盘访问序列：`98、183、37、122、14、124、65、67`，这些数字表示柱面号或磁道号。读写头起始位置为`53`。请计算磁头服务序列和磁头移动总距离（道数）。下面使用几种算法进行计算：

- 1、先来先服务（`FCFS`）
  按访问请求到达的先后次序服务

  - 优点：简单、公平

  - 缺点：效率不高，相邻两次请求可能会造成最内到最外的柱面寻道，使磁头反复移动，增加了服务时间，对机械也不利。

    

    ![img](https://upload-images.jianshu.io/upload_images/1925650-f4abfeddfb46847a.png?imageMogr2/auto-orient/strip|imageView2/2/w/316/format/webp)

    4

    磁道服务序列和访问序列一致，磁头移动总距离为

    ```
    640
    ```

    ，平均

    ```
    80
    ```

    。

- 2、最短寻道时间优先（`Shortest Seek Time First`）
  优先选择距当前磁头最近的访问请求进行服务，主要考虑寻道优先。

  - 优点
    改善了磁盘平均服务时间

  - 缺点
    造成某些访问请求长期等待而得不到服务

    

    ![img](https://upload-images.jianshu.io/upload_images/1925650-e348f244a0ff68c2.png?imageMogr2/auto-orient/strip|imageView2/2/w/639/format/webp)

    5

- 3、扫描算法（`SCAN`电梯算法）
  当设备无访问请求时，磁头不动；当有访问请求时，磁头按一个方向移动，在移动过程中遇到的访问请求进行服务，然后判断该方向上是否有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复。其实是一种对距离和方向的折中算法。

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-197591327c49d19d.png?imageMogr2/auto-orient/strip|imageView2/2/w/625/format/webp)

  6

  

- 4、单向扫描算法（`C-SCAN`）
  这是对扫描算法的一种改进。

  - 总是从零号柱面开始向里扫描
  - 按柱面（磁道）位置选择访问者
  - 移动臂到达最后一个柱面后，立即带动读写磁头快速返回到零号柱面
  - 返回时不为任何的等待访问者服务
  - 返回后可再次进行扫描

主要的目的是减少了新请求的最大延迟。

- 5、

  ```
  N-step-SCAN
  ```

  策略

  - 把磁道请求队列分成长度为`N`的子队列，每一次用`SCAN`处理一个子队列
  - 在处理某一个队列时，新请求添加到其他子队列中
  - 如果最后剩下请求数小于`N`，则它们全部都将在下一次扫描时处理
  - `N`值比较大时，其性能接近`SCAN`；当`N = 1`时，即`FIFO`

主要是为了解决磁头臂的粘性问题。

- 6、

  ```
  FSCAN
  ```

  策略

  - 使用两个子队列
  - 扫描开始时，所有请求都在一个队列中，而另一个队列为空
  - 扫描过程中，所有新到的请求都放入另一个队列中
  - 对新请求的服务延迟到处理完所有老请求之后

主要是为了解决磁头臂的粘性问题。本算法及以上都是对磁臂移动的优化算法。

- 7、旋转调度算法

  根据延迟时间来决定执行次序的调度。一般有三种情况：

  - 若干等待访问请求访问同一磁头上的不同扇区
  - 若干等待访问请求访问不同磁头上的不同扇区
  - 若干等待访问请求访问不同磁头上的相同扇区
    **解决方案：**
  - 对于前两种情况：总是让首先到达读写磁头位置下的扇区先进行传送操作
  - 对于第三种情况：这些扇区同时到达读写磁头位置下，可任意选择一个读写磁头进行传送操作

## 5.8 提高文件系统性能：信息优化分布

记录在磁道上的排列方式也会影响输入输出操作的时间。



![img](https://upload-images.jianshu.io/upload_images/1925650-70350426f9484486.png?imageMogr2/auto-orient/strip|imageView2/2/w/585/format/webp)

7

说明：

如果信息是按左边那样分布的，那么如果首先读到

```
1
```

号记录，然后花

```
5ms
```

处理，但是此时磁盘已经转到了

```
4
```

号记录，于是如果我们要处理

```
2
```

号记录，则必须将

```
4、5、6、7、8
```

都旋转过去之后才能处理

```
2
```

号记录；而如果信息是按右边那样分布的，当处理完

```
1
```

号记录，而此时磁盘也刚好旋转到了

```
2
```

号记录处，这样就能极大的提高文件系统的性能。



## 5.9 提高文件系统性能：记录的成组与分解

- 记录的成组
  把若干个逻辑记录合成一组存放在一块的工作
- 进行成组操作时必须使用内存缓冲区，缓冲区的长度等于逻辑记录长度乘以成组的块因子（成组的长度）。
- 成组的目的：提高了存储空间的利用率；减少了启动外设的次数，提高系统的工作效率。
- 记录的分解
  从一组逻辑记录中把一个逻辑记录分离出来

典型的例子就是目录文件的存储。

## 5.10 提高文件系统性能：RAID技术

起始就是独立磁盘冗余阵列（`Redundant Arrays of Independent Disks`），就是将多块磁盘按照一定要求构成一个独立的存储设备。目的就是提高可靠性和性能。在实现时，需要考虑存储系统的速度、容量、容错、数据灾难发生后的数据恢复。

- 数据是如何组织的

  - 通过把多个磁盘组织在一起，作为一个逻辑卷提供磁盘跨越功能
  - 通过把数据分成多个数据块，并行写入/读出多个磁盘，以提高数据传输率（数据分条`stripe`）
  - 通过镜像或校验操作，提供容错能力（冗余信息的保存）
  - 最简单的组织方式是镜像，最复杂的是块交错校验。

- 例1：`RAID 0` - 条带化

  - 数据分布在阵列的所有磁盘上

  - 有数据请求时，同时多个磁盘并行操作

  - 充分利用总线宽带，数据吞吐率提高，驱动器负载均衡

    

    ![img](https://upload-images.jianshu.io/upload_images/1925650-a69836e28852bc3f.png?imageMogr2/auto-orient/strip|imageView2/2/w/519/format/webp)

    8

    这种方式没有冗余信息保存，即无差错控制，性能是最佳的。

- 例2：`RAID 1`-镜像

  - 最大限度保证数据安全和可恢复性

  - 所有数据同时存在与两块磁盘的相同位置

  - 磁盘利用率为

    ```
    50%
    ```

    

    ![img](https://upload-images.jianshu.io/upload_images/1925650-7af11cb7bc8e8a7e.png?imageMogr2/auto-orient/strip|imageView2/2/w/592/format/webp)

    9

    数据的安全性是最好的，但是磁盘利用率较低。

- 例3：`RAID 4`-交错块奇偶校验

  - 带奇偶校验

  - 以数据块为单位

    

    ![img](https://upload-images.jianshu.io/upload_images/1925650-0fd3dd65b34b9fea.png?imageMogr2/auto-orient/strip|imageView2/2/w/527/format/webp)

    10

    数据保存在前四块盘上，而校验信息保存在第五块盘上。

# 17、死锁（操作系统笔记）

![img](https://upload.jianshu.io/users/upload_avatars/1925650/7a95dfb3c842.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

[yjaal](https://www.jianshu.com/u/9231f33f0db3)关注

0.1342017.02.17 21:36:53字数 3,122阅读 513

# 一、死锁的基本概念

## 1.1 死锁的定义

- 一组进程中，每个进程都无限等待被该组进程中另一进程所占用的资源，因而永远无法得到的资源，这种现象称为进程死锁，这一组进程就称为死锁进程。
- 如果发生死锁，会浪费大量系统资源，甚至导致系统崩溃
- 注意：
  参与死锁的所有进程都在等待资源
  参与死锁的进程是当前系统中所有进程的子集

## 1.2 死锁的产生原因

资源数量有限、锁和信号量错误使用。

- 资源的使用方式
  “申请-分配-使用-释放”模式
- 可重用资源：可被多个进程多次使用，又可分为可抢占资源与不可抢占资源，如处理器、`I/O`部件、内存、文件、数据库、信号量等可抢占资源。
- 可消耗资源：只可使用一次、可创建和销毁的资源。如信号、中断、消息等。

## 1.3 活锁和饥饿





![img](https://upload-images.jianshu.io/upload_images/1925650-7f38b2cced1eb7ac.png?imageMogr2/auto-orient/strip|imageView2/2/w/301/format/webp)

1

说明：



- 如图，这里有两个进程都需要使用资源`1`和资源`2`，有这样一种情况，比如这两个进程都上`cpu`执行，但是进程`A`执行到第二句的时候需要使用资源`2`，而进程`B`执行到第二句的时候需要资源`1`，但是此时恰好都不能获得各自的资源，这样就进入忙等待（进入轮询看资源是否可用），这就是活锁，也就是先加锁再轮询，这样导致两个进程既无进展也没有阻塞。这和死锁的概念的区别在于死锁的时候进程不能进入`cpu`去执行。
- 饥饿：资源分配策略决定

## 1.4 产生死锁的必要条件

- 互斥使用（资源独占）：一个资源每次只能给一个进程使用
- 占有且等待（请求和保持，部分分配）：进程在申请新的资源的同时保持对原有资源的占有。
- 不可抢占（不可剥夺）：资源申请者不能强行的从资源占有着手中多去资源，资源只能由占有着自愿释放
- 循环等待
  存在一个进程等待队列`｛P1，P2，......，Pn｝`，其中`P1`等待`P2`占有的资源，`P2`等待`P3`占有的资源，......，`Pn`等待`P1`占有的资源，形成一个进程等待环路。

# 二、资源分配图（RAG：Resource Allocation Graph）

用有向图描述系统资源和进程的状态



![img](https://upload-images.jianshu.io/upload_images/1925650-7ec5363686d2427d.png?imageMogr2/auto-orient/strip|imageView2/2/w/490/format/webp)

2

## 2.1 资源分配图画法说明

- 系统由若干类资源构成，一类资源称为一个资源类；每个资源类中包含若干个同种资源，称为资源实例。

- 资源类：用方框表示。资源实例：用方框中的黑圆点表示。进程：用圆圈中加进程名表示。

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-6849e50596a20638.png?imageMogr2/auto-orient/strip|imageView2/2/w/209/format/webp)

  3

- 分配边：资源实例-->进程；申请边：进程-->资源类

## 2.2 死锁定理

- 如果资源分配图中没有环路，则系统中没有死锁；如果图中存在还礼则系统中可能存在死锁。

- 如果每个资源类中只包含一个资源实例，则环路是死锁存在的充分必要条件。例如：

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-dc9bf6e8d8d9dd83.png?imageMogr2/auto-orient/strip|imageView2/2/w/534/format/webp)

  3

## 2.3 资源分配图化简

化简步骤：

- 1、找一个非孤立、且只有分配边的进程结点，去掉分配边，将其变为孤立结点
- 2、再把相应的资源分配给一个等待该资源的进程，即将该进程的申请边变为分配边。
- 3、重复上述步骤直到找不到资源分配结点。完成之后如果所有结点都变为孤立结点则表示系统中没有死锁，否则系统存在死锁。

# 三、死锁预防

## 3.1 解决死锁的方法

- 不考虑此问题（鸵鸟算法）
- 不让死锁发生
  - 死锁预防。这是一种静态策略：即设计合理的资源分配算法，不让死锁发生
  - 死锁避免。这是一种动态策略：以不让死锁发生为目标，跟踪并评估资源分配过程，根据评估结构决策是否分配
- 让死锁发生
  死锁检测和解除

## 3.2 死锁预防（Deadlock Prevention）

- 定义：在设计系统时，通过确定资源分配算法，排除发生死锁的可能性
- 具体做法：防止产生死锁的四个必要条件中任何一个条件的发生

### 3.2.1 破坏“互斥使用/资源独占”条件

- 资源转换技术：把独占资源变为共享资源
- `SPooling`技术的引入，解决不允许任何进程直接占有打印机的问题。设计一个“守护进程/线程”负责管理打印机，进程需要打印时， 将请求发给该`daemon`，由它完成打印任务。

### 3.2.2 破坏“占有且等待”条件

- 实现方案1：要求每个进程在运行前必须一次性申请它所有求的所有资源，且仅当该进程所要资源均可满足时才给予一次性分配。当然，这种方案的资源利用率较低，容易出现“饥饿”现象。
- 实现方案2：在允许进程动态申请资源前提下规定，一个进程在申请新的资源不能立即得到满足而变为等待状态之前，必须释放已占有的全部资源，若需要再重新申请。

### 3.2.3 破坏“不可抢占”条件

- 实现方案
  当一个进程申请的资源被其他进程占用时，可以通过操作系统抢占这一资源（两个进程优先级不同）
- 局限性：适用于状态易于保存和恢复的资源。如`cpu`和内存等。

### 3.2.4 破坏“循环等待”条件

- 通过定义资源类型的线性顺序实现
- 实施方案：资源有序分配法
  把系统中所有资源编号，进程在申请资源时必须严格按资源编号的递增次序进行，否则操作系统不予分配。
- 实现时要考虑什么问题？
  如何进行编号？这里我们一般根据资源使用的频繁性来进行编号。例如解决哲学家就餐问题。
- 为什么资源有序分配法不会产生死锁？
  起始就是进程申请的资源编号必须是递增的，比如进程`P1`申请了资源`1、3、9`，而进程`P2`需要资源`1、2、5`，那么进程`P2`在申请时必须按照`1、2、5`的顺序来申请，这样就破坏了环路条件，因为在申请到资源`1`之前，后面的资源是申请不到的。

# 四、死锁避免

- 定义：在系统运行过程中，对进程发出的每一个系统能满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统发生死锁或可能发生死锁（不是安全状态），则不予分配，否则（安全状态）予以分配。
- 安全状态：如果系统中存在一个所有进程构成的安全序列`P1，P2，......，Pn`，则称系统处于安全状态。安全状态表示系统一定没有发生死锁。
- 安全序列
  一个进程序列`｛P1，P2，......，Pn｝`是安全的，如果对于每个进程`Pi(1<= i <= n)`：它以后还需要的资源数量不超过系统当前剩余资源量与所有进程`Pj(j < i)`当前占有资源量只和。
- 不安全状态：系统中不存在一个安全序列。一定会导致死锁。

# 五、死锁避免算法：银行家算法

这是`Dijkstra`在`1965`年提出的，是仿照银行发放贷款时采取的控制方式而设计的一种死锁避免算法。

- 应用条件
  1、在固定数量的进程中共享数量固定的资源。
  2、每个进程预先指定完成工作所需的最大资源数量。
  3、进程不能申请比系统中可用资源总数还多的资源。
  4、进程等待资源的时间是有限的。
  5、如果系统满足了进程对资源的最大需求，那么，进程应该在有限的时间内使用资源，然后归还给系统。

  

  ![img](https://upload-images.jianshu.io/upload_images/1925650-171ede59e8d3cd00.png?imageMogr2/auto-orient/strip|imageView2/2/w/448/format/webp)

  4

当进程`Pi`提出资源申请时，系统执行下列步骤：
（1）若`Request[i] <= Need[i]`，转（2）；否则，报错返回。
（2）若`Request[i] <= Available`，转（3）；否则，报错返回。
（3）假设系统分配了资源，则有：

```undefined
Available = Available - Request[i];
Allocation[i] = Allocation[i] + Request[i];
Need[i] = Need[i] = Request[i]
```

若系统新状态是安全的，则分配完成；若系统新状态是不安全的，则恢复原来状态，进程等待。

为了进行安全性检查，定义了数据结构：

```jsx
Work : ARRAY[1...m] of integer;
Finish : ARRAY[1...n] of Boolean;
```

安全性检查的步骤：
（1）`Work = Available； Finish = false；`
（2）寻找满足条件的`i`：

```bash
a. Finish[i] == false
b. Need[i] <= Work;
```

如果不存在，则转（4）
（3）

```bash
Work = Work + Allocation[i] ;
Finish[i] = true
```

转（2）
（4）若对所有`i，Finish[i] == true`，则系统处于安全状态，否则，系统处于不安全状态。

# 六、死锁检测与解除

- 死锁检测
  允许死锁发生，但是操作系统会不断监视系统进展情况，判断死锁是否真的发生。一旦死锁发生则采取专门的措施，解除死锁并以最小的代价恢复操作系统运行。
- 检测时机
  1、当进程由于资源请求不满足而等待时检测死锁。这里缺点是系统开销较大。
  2、定时检测
  3、系统资源利用率下降时检测死锁

## 6.1 一个简单的死锁检测算法



![img](https://upload-images.jianshu.io/upload_images/1925650-a6e4ad45dc55bd41.png?imageMogr2/auto-orient/strip|imageView2/2/w/591/format/webp)

5

## 6.2 死锁的解除

发生死锁后重要的是以最小的代价恢复系统的运行。方法如下：

- 撤销所有死锁进程，代价较大。
- 进程回退再启动，代价也较大
- 按照某种原则逐一死锁进程，直到不发生死锁
- 按照某种原则逐一抢占资源（资源被抢占的进程必须回退到之前的对应状态），直到不发生死锁 。

# 七、哲学家就餐问题

**问题描述：**

- 有五个哲学家围坐在一圆桌旁，桌中央有一盘通心粉，每人面前有一只空盘子，每两人之间放一只筷子。
- 每个哲学家的行为是思考，感到饥饿，然后吃通心粉。
- 为了吃通心粉，每个哲学家必须拿到两只筷子，并且每个人只能直接从自己的左边或右边去取筷子（筷子的互斥使用、不能出现死锁现象）

**问题模型：**
应用程序中并发线程执行时，协调处理共享资源。

## 7.1 第一种方案





![img](https://upload-images.jianshu.io/upload_images/1925650-8f0690e0a4aae7b2.png?imageMogr2/auto-orient/strip|imageView2/2/w/533/format/webp)

6

说明：

这里将筷子当作一个信号量来处理，饥饿的时候会申请筷子（

```
P
```

操作），当同时等待拿某只筷子的时候会发生死锁。



**为防止死锁发生可采取的措施：**

- 最多允许四个哲学家同时坐在桌子周围
- 仅当一个哲学家左右两边的筷子都可用时，才允许他拿筷子。
- 给所有哲学家编号，奇数号的哲学家必须首先拿左边的筷子，偶数号的哲学家反之。

## 7.2 第二种方案





![img](https://upload-images.jianshu.io/upload_images/1925650-a3153511048f11df.png?imageMogr2/auto-orient/strip|imageView2/2/w/516/format/webp)

7

说明：

这里增加了一个信号量

```
room
```

，即这个桌子上最多允许坐四个人，这样就不会发生死锁。



## 7.3 第三种方案





![img](https://upload-images.jianshu.io/upload_images/1925650-befb6c2dfd8f3c2b.png?imageMogr2/auto-orient/strip|imageView2/2/w/511/format/webp)

8



![img](https://upload-images.jianshu.io/upload_images/1925650-89af8379180aff71.png?imageMogr2/auto-orient/strip|imageView2/2/w/595/format/webp)

9

说明：

这里使用管程来解决，即哲学家拿筷子的动作是由管程管理，一次只能拿两只筷子。



# 7.4 第四种方案



![img](https://upload-images.jianshu.io/upload_images/1925650-d13259c3fa489db0.png?imageMogr2/auto-orient/strip|imageView2/2/w/509/format/webp)

10



![img](https://upload-images.jianshu.io/upload_images/1925650-d8cae77820801eba.png?imageMogr2/auto-orient/strip|imageView2/2/w/462/format/webp)

11



![img](https://upload-images.jianshu.io/upload_images/1925650-8314b8fb7764ad56.png?imageMogr2/auto-orient/strip|imageView2/2/w/339/format/webp)

12