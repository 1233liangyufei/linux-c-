# 计算机网络系统方法

## 第一章 基础

### 问题：构建网络

试想你想要构建一个网络，这个网络需要有可以扩展到甚至全球规模的潜力，并可以支持多种多样的应用，如电话回以，音频，电子回以，分发网络，数字图书馆。为了搭建这个网络我们需要那些技术块，为了将这些模块整合使之成为有效的通信网络，我们必须使用那种软件架构？这本书的目标就是回答这些问题，描述可得到的搭建材料然后展示如何利用这些组件行成一个计算机网络。

在理解如何设计一个网路前，我们应该先定义什么是网络？曾经，网络就是利用一系列导线将各个终端连接起来。其他重要的网络包括：无线电网络，电话网络，传播视频信号的有线电视网络。这些网络的共同点在于他他们只是用于处理特定种类的数据（键盘按键，声音，视频）而且他们通常连接特种设备（终端，手持接收器，电视机）

计算机网络那些方面不同于其他的这些网络？最重要就是他的通用性。计算机网络主要用于具有通用目的的可编程设备，而且它不是为了专门的特定应用而优化的像打电话，看电视。相反它具有通用性使得它可以传输不同的数据，支持更加广泛，不断增长应用。几天计算机网络比以往的单一用途网络具有更加丰富的应用。这一章节举了一些典型应用的例子，并且探讨了网络设计者们为了支持实现这些应用所必要的要素。

当我们理解了这些要求，我们如何实现？幸运的是，我们不必搭建第一个网络。另外，前人已经为我们做了很多研究。我们将要使用过去经验来指导我们的设计。这些经验包括在网络架构部分，这一部分阐明了可得到的软件与硬件并且展示了我们如何来实现一个计算机网络。

为了进一步理解网络是如何搭建的，理解如何操作和管理网络，如何开发网络应用也变得日益重要，几乎现在每个人都会使用计算机网络，家，办公室，车，因此操作网络不再是专家们才需要知道的知识，比如配置路由器。而且，随着智能手机的爆发增长，如今有着远超过去规模的网络应用。因此对于计算机网络，我们需要从多个方面来进行考虑：船舰这，操作者，应用开发者。

为了开始我们的如何构建，操作网络，写网络程序的旅程，这个章节我们需要做四件事情。

- 第一，探索不同网络应用的需求，不同人对网络的需求
- 第二，引入网络架构的概念，这构成本数的结构基础
- 第三，它介绍了一些网络实现元素的关键概念
- 第四，它阐述了评估网络表现的关键的指标

### 1.1 应用

大部分人通过应用来认识网络，万维网，邮件，社交媒体，流媒体，视频会议，即时通信，文件共享。我们作为使用者来与网络交互。互联网用户代表与互联网接触的大量群体，这其中有几种重要的特殊群体。

有一个群体他们创造网络应用——伴随着近些年智能手机迅速普及，给开发者创造网络应用提供广阔机会和巨大市场。

另一个群体操作和管理网络——大部分是一个幕后工作，这是一个极其困难而复杂的工作，随着家用网络的普及，越来越多的人在某种程度上也成为了一个网络的管理者，如家用路由器的管理与设置。

最后，那些设计和搭建互联网的人，合作创建了互联网，大部分的计算机网络参考书都是以这一类群体的角度编写的，他们主要关注如何设计和构建网络协议与网络设备，当然这一部分也是本书主要关注的部分，但是，这本书也会从考虑网络应用开发者以及网络管理与维护者的视角。

我们认为，这样的描述手法有利于我们以更加全面的角度看问题，可以理解为何网络为何有如此丰富多样的需求需要满足。而网络应用开发者如何能对于网络交互背后的底层网络的原理理解更加透彻，也会有利于他们应用程序的编写。因此在我们开始了解如何设计一个网络之前，我们线了解一下当前一些典型网络应用所支持的内容。

#### 应用的种类

万维网这一网络应用目前已经环绕整个互联网，它从一个主要由科学家与工程师使用的一个晦涩难懂的工具到如今已经成为了一个主流应用。它本身已经成为一个丰富的平台以至于很多人将它与互联网混淆，而将互联网认为是一个单一的网络应用这是十分错误的。

简单的看，这一应用为我们提供了一个近乎人类本能直觉的简单使用接口。用户浏览整个充满文字与图像的页面，然后点击他们所感兴趣的，然后就会弹出那个与之相关的页面。大部分人都知道在那些可以选择的对象背后，它绑定了一个标识符，用来跳转到另一个页面或者其他可以被查看的对象（声音，图像等）。而这个标识符称为url，这一事务提供了一种方法，可以表示你在万维网所能看到的一些可能的事务。

```
http://www.princeton.cs.edu/llp/index.html
```

是一个url，它指向一个提供了本书作者信息的网站，字符串http表明应该用超文本传输协议来下载页面,/www.princeton.cs.edu代表服务器页面的名字，llp/index.html指向了larry的主页。

我们大部分用户所不知道的是，仅仅是点击这一url地址的操作，这其中就有成千上万的信息交互，这其中的复杂程度远超这一包含的那些对象的网页的复杂程度，这其中包含六条信息，将Url地址专函为ip地址，三次信息来开启你与服务器的tcp协议的连接，四条信息来使得你的浏览器发送http get请求，服务器响应请求，四次信息来关闭tcp连接。当然这其中还不包括互联网中几百万个结点的信息传递，这仅仅是让双方知道对方的存在，为响应请求，地址转换传递信息到重点做一些准备。

而另一个广泛应用的互联网应用是音视频流的分发。流媒体在今天广泛的应用。我们频繁的打开一个页面并开启一个流会话，音视频流的传递与图像文字的传递有着很大的差别。例如，你不希望一次下载一个完整的的视频文件，这看一个视频可能需要缓存好几分钟。流媒体实现了一个信息在接收方与发送方的实时传递，可以使得接收方可以立刻收看他们所点开的音视频。

流媒体信息与传统的文字图像信息的一个主要区别就在于人们对二者的需求不同，对于文字，图像，我们可以按块，比特来读取，以间断的方式来读取，而对于流媒体文件，我们必须以连续的方式，任何不连续的方式，如跳跃的声音，延迟卡顿的视频对人机体验来说都是不能容忍的，这以区别最终影响了互联网是如何支持这两个不同应用的。

对于电话应用来说，300毫秒是人民能够感觉体验良好的上界，100毫秒的时延则是非常良好的情况。

当一个人想要打断另一个人时候，被打断的需要及时听到打断消息，决定是接受这个打断，还是继续说不管它。在这种系统中，时延太高则无法使用。将这一应用与视频对比，如果从图片被展示到视频开始需要花费好几秒钟，这个设备仍然是令人满意的。此外，交互应用通常他的信息是双向传递的，与此同时，音视频文件则主要是单方面的传递视频与音频文件。

视频回以工具自1990年代开始诞生，但是直到最近几年才开始广泛使用，并且市场上也存在很多商业级产品。仅仅是拖下一个网络页面来，便可以进行网络会议。要实现网络视频会议，我们需要解决很多问题，适应音视频在低带宽网络的传播，确保音频与视频的同步，延时较小都是提升用户体验的关键。而这些需求需要网络和协议的设计者所关注并实现。我们之后将会接触很多与多媒体应用的主题。

尽管我们仅仅举了两个例子，从网络下载页面和开展视频会议，这论证了在互联网基础上的应用的多样性，暗示了互联网设计的复杂与困难。在后面我们将机型一次更加系统完备的分类，来帮助我们对于构建，操作，使用互联网时候的设计时候进行一些指导。在结尾我们仍然谈论这两个应用，以及其他应用来论证如今互联网的无限可能。

现在，针对这短短几个典型应用的快速浏览，将会使得我们在构建支持多种应用多样性的网络时候能够更好的定位问题，明了需要解决的需求。

### 1.2 需求

我们已经立下了雄心壮志：从头到尾理解如何设计一个互联网。我们实现这一目标的方法是想一想构建真实互联网需要解决哪些问题？在每一次，我们将要使用如今使用的协议来论证我们可以使用的设计的复杂丰富性，但是我们不能单单接受这一人造产物，把它当作是老天爷赐给你的，而是要想为什么要这样设计，这会促使你理解今天为什么会这样，了解各种概念背后的底层逻辑是至关重要的，因为这就像武功一样，招式千变万化，心法确是不变的，随着互联网不断发展，新的应用层出不穷，但是它背后的原理却很长久，几乎不会发生大的改变，而在你了解了背后的逻辑之后，你在学习新的协议时候也会非常容易。抓住事情的本质很重要。



#### 权益关系者

正如前面所讲，互联网可以分为不同角度。本书第一版时，大部分人还没接入互联网，网民大部分通过办公室，学校或者拨号上网。那时候的流行应用一只手数的来。因此大部分书都是站在设计网络设备协议的角度来说的，我们会继续关注这个方面，希望本书的阅读者可以指导在将来如何设计网络协议与设备。

但是与此同时我们也会关注其他方面，网络应用开发者以及网络操作与管理员。让我们考虑一下者三个利益群体对于网络会提出的不同的要去：

- 一个应用程序员将会给他的程序列出这些要求：例如，保证应用发出的每条信息都在限制时间内无错误的传递，在不同网络中优雅的切换以保证用户可以随意走动。
- 作为一个网络管理员将会罗列一系列方便与网络管理的特性：例如，错误可以简单的隔离，可以在网络中添加新设备并正确的配置，并方便使用。
- 网络的设计者将会罗列一系列有利于成本与效率的设计：例如，网络资源得以有效利用并对用户公平分配。性能问题也是至关重要的。

本节试图提炼不同人员的需求，以更高维度的介绍网络设计主要考虑的内容，阐明网络设计需要解决的问题。

#### 可扩展的连接

显而易见，计算机网络必须提供很多电脑的互联互通。有时候构建一个仅连接特定的选择的电脑的网络也是够用的。事实上，为了隐私与安全考虑，很多私人（公司）网络，具有清晰的限制连接的电脑集合的目标（不是谁都能进来这个网）。与之对照的其他网络（因特网是一个例子）是为增长而设计，具有使得全球所有电脑都连接的潜力。一个系统被设计的具有可以任意扩展规模的特性称之为可扩展性。以因特网为模型，本书解决了可扩展性这一挑战。

为了充分理解连接的需求，我们需要近距离观察计算机是如何连接到网络上的。连接具有很多等级。在最低的级别，一个网络包含了由物理媒介（导线）连接的两个或者多台电脑，例如双绞线与光纤。我们称这种物理媒体为连接，我们通常将要连接的电脑称之为节点。（有时一个节点是一个更加专业的硬件设备而不是计算机，但是在本节讨论我们忽略二者的差别）。如图所示，物理连接有时候被限制为一对节点（例如这个连接称之为点对点），与之对应还有多个计算机共享一个网络连接的情况（称之为多路访问）。无限连接例如蜂窝网络与wifi网络，是多路访问重要例子。通常多路访问连接具有有限的规模，因为受覆盖物理距离限制和他们所能连接的节点数量限制。

如果计算机网络被限制在所有结点都通过物理媒介来直接连接的这种情况，那么要不它所连接的计算机将十分有限，要不每个电脑互联互通所需要连接的导线将会变得难以管理而且成本高昂。更进一步，两个结点之间的连接必须通过物理连接直接相连也是不必要的，间接连接也可以做到这一目的。考虑下面两个电脑通过间接连接互通的例子。

下图展示了一些结点的集合，每个集合连接了一个或者更多点对点网络。节点之间通过至少两个link，运行着软件转发上一个连接的信息给下一个连接。如果我们将其系统的组织后，这些转发节点将构成交换网络。交换网络通常有几种表现形式。最常见的两个就是电路交换和包交换。前者在电话系统广泛使用，后者在计算机网络上有压倒性的主流地位，也是本书关注的焦点。电路交换再光网络领域卷土重来，这在逐渐增长的网络规模上变得至关重要。包交换最大特点就是信息传输的离散性，以块为单位传输。这些块对应于应用中的文件，电子邮件，图像。我们吧每个块称之为一个包或者信息，之后我们将会使用这一术语。

包交换通常使用一种称之为存储转发的策略。就像名字所说的，每个在存储转发网络中的节点受到来自上一个连接发送过来的一个完整的包，将其存储于内部存储中，然后转发给下一个连接。与此对照的，电路交换网路通过几个节点构建一个用于传输数据的专用电路。在下一节中我们将要探讨，决定我们使用包交换网络而不是电路网络的主要原因是因为效率问题。

图2中的区别两个节点的云内部也是一个网络（通常称之为交换器，主要功能是存储转发数据）而且云外面也使用网络（他们通常称为主机，他们为用户提供支持并运行应应用程序）。我们知道云是计算机网络最有名的标识。通常我们使用云来代表任意的网络，不管它是一个点对点网络，多路访问网络，或者包交换网络。因此在图中你看到云，你可以把她当作任何本书所覆盖的一种网络。

网络另一种间接连接方式展示于图3.在这种情况下一系列独立的网络连接组成一个互联网。按照互联网会议的管理普遍的互联网我们使用小写字母internet,当前真实使用的TCP/IP协议网络称位因特网Internet。一个连接不同网络的结点的结点称之为路由或者网关，她的作用与交换机类似，转发上一个结点的信息到下一个。记住互联网也可以被看所是一种网络的形式。因此我们可以听过小网络来形成更大的网络。因此我们可以递归的使用来构建一个更大的网络，通过把小云组建更大的云。我们可以说这种不同网络连接组成更大网络的思想是互联网革命的基础。如今网络扩展到全球规模拥有几十亿个结点也是早期互联网优秀设计架构的结果。

仅仅因为一些列主机直接或者间接的并不意味着我们已经成功提供了一种主机对主机的连接。最后的需求是每个结点必须知道它想要和谁通信，就像打电话得号码。我们通过给每个结点提供一个地址来解决这个问题。地址是一个用来标识结点地址的标识符，网络使用地址来讲其与其他结点来区分开来，它具体规定了目的结点的地址。如果信息的发送接收方不是直接相连通，交换机和路由器使用地址来传输信息直到目的结点。这种利用地址来选择如何传递信息，找到需要转发的下一个结点的方式称位路由。

在前面介绍地址和路由时候我们假定源结点想要发送结点给单一目的结点（称单播）。然而在通常的设想中，我们可能也需要结点广播一条信息给网络中所有的结点，或者源节点想要发送信息给一组结点但不是整个网络，称之为组播。因此除了结点的特定地址外，网络也需要提供广播，多播与组播地址。

要点：

我们主要讨论了我们可以通过具有两个或多个结点的物理连接网络来递归的搭建一个更大的网络。换句话说，我们可以嵌套组网，在多层网络的底层我们可以看到由物理传输介质来来连接。提供网络连接的一个关键挑战就是为每个结点提供一个网络可达的地址，包括广播与多播，而且利用这个目的地址来寻找路径传输给目的结点。

#### 经济有效的资源共享

如前面所说，本书主要关注包交换网络。这一部分解释了计算机网络的一个重点需求——效率，这使得包交换称为我们的选择。

给你一个嵌套组织的间接型网络，这是可能的不同结点相互发送信息。当然，我们想要不仅仅支持一对通信，我们想要所有的主机都能交换信息。问题是网络内所有的主机都想要交换信息，尤其是这同时发生时候咋办？如果这还不是最困难的，当几个共享连接的主机他们如何共享一个连接？

为了理解主机们如何共享网络，我们需要引入一个基础的概念，多路复用，这意味着系统资源可以被多个用户所共享。在最只管的级别，多路复用可以被解释为类似于一个时分复用系统，每个处理器被多个作业所共享，每个作业都认为它独立占有处理器。类似的，多个用户发送的数据也可以通过网络的物理链路实现多路复用。

为了了解这如何工作的，我们看一下图4，左边三个发送结点通过只有一条物理链路的交换机来传输给右边三个接收结点。在在这种情况下，三条链路通过交换机多路复用在一条物理链路上，

有不同的方法来实现物理链路的多路复用。一个普遍的方法是同步时分复用STDM,它将时间平均划分为等份，以一种轮转的方式，给每个数据流一个在物理信道发送信息的机会。换句话说在时间片1，发送机1给接收机1发，时间片2，2给2发，以此类推，循环往复。另一个方法是频分复用，这一·思想是不同的信息流使用不同的频率传输，这一方式类似于电视或者广播，不同的频道以不同的频率来传输信息。

尽管这两种方式十分易懂，但是他们存在一些缺点，那就是资源没有得到充分利用。一个连接不管它传输信息没有都要占用部分资源，如时间片或者频率，在计算机连接时，时间规模可能是很大的，想象你打开一个页面可能需要花费几秒钟，这浪费是惊人的。而且，这两种形式最大连接是固定的，时间片于频率划分也是固定的，我们重新赋值时间片大小和增加一个时间片在stdm中或者增加一个频率在tdm中都是不现实的。

为了解决上述多路复用的缺点，我们在本书中最常使用的一个方法是统计多路复用。统计多路复用十分简单，主要有两个要点。它类似于时间共享， 来自一个流的第一个数据通过物理链路传输，然后传输来自另一个流的数据。不像stdm，每个数据传输是根据需要而不是预先设置好的时间片。因此只有一条信息在信道时候无需等待时间片轮转到这，可以直接分配给它，这种思想给包交换提升了效率。

然后，存在一个问题，统计时分复用没有机制来确保所有流最终得以通过物理连接传输。也就是说，一旦一个信息开始传输，我们需要一些手段来限制这种传输，以便可以切换到别的信息流而不是被一个任务一直占用。因此定义了一个每个流占用信道时间使用的上界。这个有限大小的数据块称之为包，来区分于应用程序想要传输的任意大小的数据。源节点可能将数据拆分为不同的包，接受方将组织这些包重新还原为原始的信息。

换句话说，每个流在物理链路上发送一系列分组，并且逐个分组地决定下一个要发送哪个流。请注意，如果只有一个流有数据要发送，那么它可以一个接一个地发送一系列数据包; 但是，如果不止一个流有数据要发送，那么它们的数据包在链路上交错。[图4](https://book.systemsapproach.org/foundation/requirements.html#mux)描绘了将来自多个源的分组多路复用到单个共享链路上的交换机。

关于决定共享链路种，决定那个包将要发送有不同的方法。例如，在由通过链路互连的交换机组成的网络中，[如图4中的](https://book.systemsapproach.org/foundation/requirements.html#mux)链路，交换机做出决定，哪个将数据包传输到共享链路的。（正如我们稍后将看到的，并非所有分组交换网络实际上都涉及交换机，并且它们可能使用其他机制来确定下一个链路进入链路。）分组交换网络中的每个交换机在数据包上独立做出此决定。网络设计师面临的一个问题是如何以公平的方式做出这个决定。例如，可以将交换机设计为以先进先出（FIFO）为来转发包。另一种方法是以循环流转的方式来决定下一个转发哪个包组。可以这样做以确保某些流可以占用特定份额' 带宽或保证他们的延迟不会超过特定的时间。网络尝试将带宽分配给特定流，有时被称为支持*服务质量*（QoS）。

另外，请注意[图4](https://book.systemsapproach.org/foundation/requirements.html#mux) 中由于交换机必须将三个输入数据包流复用到一个输出链路上，因此这是可能存在的，交换机可能受到了很多包而没有将其及时转发。在这种情况下，交换机被迫将这些数据包缓在其内存中。如果交换机接收数据包的速度超过了它可以发送的速度，那么交换机最终会用尽缓冲区空间，并且必须丢弃一些数据包。当交换机在这种状态下工作时，称它很*拥挤*。

重点

最重要的是，统计复用为多个用户（例如，主机到主机数据流）定义了一种经济有效的方式，以细粒度的方式共享网络资源（链路和节点）。它将数据包定义为用于将网络的链路分配给不同流的粒度，每个交换机能够基于每个数据包调度其连接的物理链路的使用。公平地将链路容量分配给不同的流并在发生拥塞时处理拥塞是统计复用的关键挑战。

#### 支持公共服务

前面的讨论侧重于在一组主机之间提供经济高效的连接所涉及的挑战，但将计算机网络视为在一组计算机之间简单地传送数据包的思想是过于简单化的。将网络视为为一组分布式的在这些计算机上进行通信的应用程序进程提供方法更为准确。换句话说，计算机网络的下一个要求是在连接到网络的主机上运行的应用程序必须能够进行通信。从应用程序开发人员的角度来看，网络需要让他或她的生活更容易。

当两个应用程序需要相互通信时，除了简单地将消息从一个主机发送到另一个主机之外，必须发生许多复杂的事情。一种选择是应用程序设计人员将所有复杂的功能集成到每个应用程序中。但是，由于许多应用程序需要通用的事务，因此更合理的方式是将其抽象出来，形成一个公共服务，因此实现这些公共服务一次然后让应用程序设计者使用这些服务构建应用程序更合乎逻辑。网络设计者面临的挑战是确定正确的公共服务集。目标是在不过度约束应用程序设计者的情况下从应用程序中隐藏网络的复杂性。多么类似于操作系统对硬件的抽象，抽象与封装贯穿整个计算机领域的伟大思想。隐藏细节，关注重点，提供灵活的选择，而不死板。

直观地，我们将网络视为提供逻辑*通道*，应用程序级进程可以相互通信; 每个通道提供该应用程序所需的一组服务。换句话说，就像我们使用云来抽象地表示一组计算机之间的连接一样，我们现在将通道视为将一个进程连接到另一个进程。[图5](https://book.systemsapproach.org/foundation/requirements.html#channel)显示了通过逻辑通道进行通信的一对应用程序级进程，该逻辑通道又在连接一组主机的云之上实现。我们可以将通道视为连接两个应用程序的管道，发送应用程序可以将数据放在管道的一端，并期望数据经由网络传送到管道另一端的接收信息的应用程序。

挑战在于认识到渠道应该为应用程序提供哪些功能。例如，应用程序是否需要保证通过通道发送的消息是否已传送，是必须保证信息的传达，或者可以允许某些消息无法到达？信息是否必须按照发送信息的顺序到达收件人进程，或者收件人是否不关心信息的到达顺序？网络是否需要确保没有第三方能够窃听频道，或者隐私不是一个问题？通常，网络提供各种不同类型的服务，每个应用选择最能满足其需求的类型。本节的其余部分说明了定义有用服务所涉及的思路。

#### 识别共同的沟通模式

设计抽象通道包括首先了解代表性应用程序集合的通信需求，然后提取它们的通用通信要求，最后在网络中结合满足这些要求的功能。抽象提取通用。

网络上最早的应用程序之一是文件传输程序，如文件传输协议（FTP）或网络文件系统（NFS）。虽然许多细节各不相同 - 例如，整个文件是通过网络传输，还是只在给定时间读取/写入文件的单个块 - 远程文件访问的通信组件的特征是被抽象为一个进程。请求访问文件的进程称为 *客户端*，支持访问该文件的进程称为 *服务器*。

读取文件涉及客户端向服务器发送请求消息，服务器返回包含需要数据的进行响应。写入以相反的方式工作 - 客户端发送包含要写入服务器的数据，服务器响应一条确认已写入磁盘的消息。

数字图书馆是比文件传输更复杂的应用程序，但它需要类似的通信服务。例如，*计算机协会*（ACM）运营着一个大型的计算机科学文献数字图书馆

```pseudo
http://portal.acm.org/dl.cfm
```

该库具有广泛的搜索和浏览功能，可帮助用户找到他们想要的文章，但最终它的大部分内容都是响应用户对文件的请求，例如期刊文章的电子副本。

以使用文件访问程序，数字图书馆和之前描述的两个视频应用程序（视频会议和视频点播）作为样本，我们可能决定提供以下两种类型的频道：*请求/回复*频道和*消息流* 频道。请求/回复通道将由文件传输和数字库应用程序使用。它将保证一方发送的每条消息都被另一方接收，并且每条消息只传送一份副本。请求/回复通道还可以保护数据的隐私性和完整性，以便未授权方不能读取或修改在客户端和服务器进程之间交换的数据。

视频点播和视频会议应用程序则使用消息流通道，它支持单向和双向传输并支持不同的延迟要求。消息流通道不需要保证发送信息的完整性，因为即使没有接收到某些视频帧，视频应用程序也可以运行。但是，它需要确保传送的那些消息以与它们被发送的顺序相同的方式到达，以避免不按顺序显示帧，这视频还能看吗？与请求/回复信道一样，消息流信道可能希望确保视频数据的隐私性和完整性。最后，消息流通道可能需要支持多播，以便多方可以参与电话会议或查看视频。

虽然网络设计人员通常会认为可以为最多应用程序提供服务的最少数量的抽象类型，但是尝试太少抽象来是很危险的。简单地说，根据锤子效应，如果你有锤子，那么一切看起来都像钉子。例如，如果您拥有的只是消息流和请求/回复通道，那么即使两种类型都没有难以满足应用程序所需，也很容易将它们用于下一个应用程序，这是非常低效的。因此，只要应用程序员正在发明新的应用程序，网络设计人员可能会发明新类型的抽象并向现有抽象添加选项。

还要注意的是究竟*什么*功能由给定的通道提供，我们应该在每个抽象提供什么样的功能。在许多情况下，最简单的方法是将底层网络的主机到主机连接视为简单地提供*位管道*，在终端主机上提供所有高级通信语义。这种方法的优点是它使交换机尽可能简单地保持在网络中间 ,它们只是转发数据包 ，这样的设计要求终端主机承担支持进程间处理通道的大部分负担，这是很臃肿的。替代方案是将附加功能集成到交换机上，从而允许终端主机成为“哑”设备（例如，电话手机）。我们将看到这样一个问题：各种网络服务如何在分组交换机和终端主机（设备）之间进行分区，这是网络设计中反复出现的问题。

#### 可靠的消息传递

正如刚刚考虑的示例所示，可靠的消息传递是网络可以提供的最重要的功能之一。然而，在没有理解网络如何失败的情况下，很难确定如何提供这种可靠性。首先要认识到的是，计算机网络并不存在于一个完美的世界中。机器崩溃，重新启动，光纤被切断，电气干扰破坏了正在传输的数据中的位，交换机耗尽缓存空间，管理硬件的软件有时候也可能包含错误，有时会将数据包转发丢了。因此，网络的主要要求是从某些类型的故障中恢复，以便应用程序不必处理它们甚至不必知道它们。

网络设计人员不得不担心三种常见的故障类别。首先，当通过物理链路传输分组时， 可以将*比特错误*引入数据中; 也就是说，1变为0，*反之亦然*。有时单个bit被破坏，但通常会发生*突发错误*- 几个连续的位被破坏。由于外部力量（例如雷击，电压不稳和微波炉）会干扰数据传输，因此通常会发生误码。好消息是这种比特错误相当罕见，平均只影响每10个中的一个^ 6至10^ 7个 上在铜线上，10个的^ 12到10^ 14从发生一次在光纤网络种。正如我们将看到的，有些技术可以高效率地检测这些误码。一旦检测到，有时可以纠正这样的错误 - 如果我们知道哪个位或哪些位被破坏，我们可以简单地翻转它们 - 而在其他情况下损坏是如此糟糕以至于必须丢弃整个数据包。在这种情况下，可以期望发送方重新发送该分组。

第二类故障发生在数据包而不是比特级别; 也就是说，网络丢失了一个完整的数据包。这可能发生的一个原因是数据包包含不可纠正的位错误，因此必须被丢弃。然而，更可能的原因是，必须处理数据包的交换机将其丢弃- 例如，将其从一个链路转发到另一个链路的交换机 - 如此负载过大以至于无法存储数据包，因此被迫放弃它。这是刚才讨论的拥堵问题。另一个不太常见的情况是，在处理数据包的其中一个节点上运行的软件会出错而转发错误。例如，它可能错误地将数据包转发到错误的链路上，因此数据包永远不会找到最终目的地。

第三类故障发生在节点和链路级别; 也就是说，物理链接被切断，或者计算机连接到崩溃。这可能是由崩溃的电脑，电源故障或鲁莽的保洁操作员造成的。由于网络设备配置错误导致的故障也很常见。虽然最终可以纠正任何这些故障，但它们可能会在很长一段时间内对网络产生巨大影响。但是，他们不会完全使得网络瘫痪。例如，在分组交换网络中，有时可以绕故障节点或链路进行路由。处理这种第三类故障的困难之一是区分失败的计算机和仅仅很慢的计算机

重点

从这个讨论中脱离出来的关键思想是，定义有用的抽象来理解应用程序的需求，也用来识别底层技术的局限性。面临的挑战是填补应用程序期望的内容与底层技术可以提供的内容之间的差距。这有时被称为 *语义差距。*

#### 可管理性

最终的要求似乎被忽视或者经常被搁置（就像我们在这里做的那样），就是需要管理网络。管理网络包括随着网络的增长而升级设备以承载更多流量或覆盖更多用户，在出现问题或性能不理想时对网络进行故障排除，以及添加新功能以支持新应用程序。

这个要求部分与上面讨论的可扩展性问题有关 - 因为互联网已经扩展到支持数十亿用户和至少数亿个主机，保持整个事情正确运行并正确配置新设备的挑战增加了很多。在网络中配置单个路由器通常是受过训练的专家的任务; 配置数千个路由器并弄清楚为什么这样大小的网络没有按预期运行可能成为超越任何单个人的任务。此外，为了使网络的操作可扩展且成本有效，网络运营商通常需要许多管理任务自动化或至少由相对不熟练的人员执行。

使网络更易于管理的一种方法是避免更改。一旦网络正常工作，只需*不要触摸它！*这种思维方式暴露了*稳定性*和*特征速度*之间的基本张力：新功能引入网络的速率。支持稳定性是电信行业（更不用说大学系统管理员和企业IT部门）多年来采用的方法，使其成为您可以在任何地方找到的最缓慢的移动和风险规避行业之一。但是最近云的爆炸已经改变了这种动态平衡，因此必须使稳定性和特征速度更加平衡。云对网络的影响是整本书中反复出现的一个主题，我们在每章末尾的*Perspectives*部分都特别注意这一主题。就目前而言，足以说管理快速发展的网络可以说*是*当今网络*的*核心挑战。

### 1.3 架构

前一部分提出了网络设计的需求

- 通用，成本节省，公平，稳定连接的网络
- 在单一时间保持固定，具有扩展性可以适应底层技术的变化以及应用程序需求的变化。
- 方便于管理

为了解决上述问题，构建一个网络蓝图——网络架构，用来指导网络的设计与实现。介绍网络架构的共同思想，解释网络分层的含义，介绍广泛使用的两种分层方法——OSI(7层)和因特网架构。

#### 分层与协议

抽象——隐藏内部细节，提供外部接口，管理复杂性的神器。

抽象，定义一个模型，关注系统的重要部分，集成模型的对象封装为接口可以供系统其他方面使用。隐藏这些对象是如何实现的细节。挑战在于这个抽象可以提供用户足够他们需要的抽象，这与我们通道的抽象是一样的，我们为应用程序提供抽象，对程序编写者隐藏其中的细节。

- 硬件
- 主机到主机连接
- 进程到进程连接
- 应用程序

抽象自然导致了分层，尤其在网络系统当中。

一般的想法是，您从底层硬件提供的服务开始，然后添加一系列层，每个层提供更高（更抽象）的服务级别。高层提供的服务是根据低层提供的服务实现的。‘

分层的好处

- 便于管理，你不需要用一个软件来管理所有的一切。其次你可以将问题分解，不同层解决不同的问题。
- 模块化设计，更加灵活，当添加新服务时候可以复用其他层的功能。

分层可能不是线性的，在每个层可能提供了多种抽象，每个抽象都为更高层提供不同的服务。

网络系统层的抽象对象称之为协议。协议提供一种通信服务来用于交换信息。

协议定义了本地导出的通信服务（服务接口），以及管理协议与其对等方交换以实现服务（对等接口）的消息的一组规则。

除了硬件级别对等体通过物理介质之间相连，其他层都是间接的。每个协议通信时候都向下转到较低界别的协议与之通信。

协议规范以文字伪代码等方式来描述，不同的程序员则可以以不同的方式来实现协议，只要复合规范。

#### 封装

在每个层次传递信息时候会打上包头用以传递包相关的信息，每个层次都会重复拆包，打包的过程。

#### 多路复用与多路分解

回想一下，分组交换的基本思想是在单个物理链路上复用多个数据流。同样的想法适用于协议图，而不仅仅是切换节点。例如，在 [图4中](https://book.systemsapproach.org/foundation/architecture.html#protgraph)，我们可以将RRP视为实现逻辑通信信道，来自两个不同应用程序的消息在源主机上通过此通道进行多路复用，然后再解复用回目标主机上的相应应用程序。

实际上，这只是意味着RRP附加到其消息的标头包含一个标识符，该标识符记录消息所属的应用程序。我们称这个标识符为RRP的 *解复用密钥*，或简称为*demux密钥*。在源主机上，RRP在其标头中包含适当的demux密钥。当消息传递到目标主机上的RRP时，它会剥离其标头，检查解复用密钥，并将消息解复用到正确的应用程序。

RRP在支持多路复用方面并不是唯一的; 几乎每个协议都实现了这种机制 例如，HHP有自己的demux密钥，用于确定哪些消息传递给RRP以及哪些消息传递给MSP。但是，协议之间没有统一的协议 - 即使是在单一网络架构中的协议 - 究竟是什么构成了解复用密钥。某些协议使用8位字段（意味着它们只能支持256个高级协议），而其他协议使用16位或32位字段。此外，一些协议在其报头中具有单个解复用字段，而其他协议具有一对解复用字段。在前一种情况下，在通信的两侧使用相同的解复用密钥，而在后一种情况下，每一侧使用不同的密钥来标识要将消息传递到的高级协议（或应用程序）。

### 7层OSI模型

从底部开始并处理，*物理*层处理通过通信链路传输bit。然后，*数据链路*层将比特流收集到称为*帧* 。网络适配器以及在节点操作系统中运行的设备驱动程序通常实现数据链路级别。这意味着帧，而不是原始位，实际上传递给主机。*网络*层处理的分组交换网络中节点之间的路由。在该层，节点之间交换的数据单元通常称为*分组*。较低的三层在所有网络节点上实现，包括网络内的交换机和连接到网络外部的主机。然后，*传输*层实现了我们迄今为止所调用的 *进程到进程通道*。这里，交换的数据单元通常称为*消息*。传输层和更高层通常仅在终端主机上运行，而不在中间交换机或路由器上运行。

关于前三层的定义的一致性较少，部分原因是它们并非总是存在。应用层协议包括诸如超文本传输协议（HTTP）之类的东西，它是万维网的基础，并且使Web浏览器能够从Web服务器请求页面。

TCP/IP

互联网架构是从早期的分组交换网络（称为ARPANET）的经验演变而来的。互联网和ARPANET均由美国国防部研究和开发资助机构之一的高级研究计划局（ARPA）资助。互联网和ARPANET在OSI架构之前就已存在，从构建它们获得的经验是对OSI参考模型的主要影响。

互联网通常使用4层模型。最低级别是各种各样的网络协议，表示为NET_11，NET_22，依此类推。实际上，这些协议通过硬件（例如，网络适配器）和软件（例如，网络设备驱动器）的组合来实现。例如，您可能会在此层找到以太网或无线协议（例如802.11 Wi-Fi标准）。（这些协议实际上可能涉及多个子层，但是互联网架构并未假定它们的任何内容。）第二层由单个协议组成 -*互联网协议*（IP）。这是支持将多种网络技术互连到单个逻辑互联网络中的协议。第三层包含两个主要协议 -*传输控制协议*（TCP）和*用户数据报协议*（UDP）。TCP和UDP为应用程序提供备用逻辑通道：TCP提供可靠的字节流通道，UDP提供不可靠的数据报传送通道（*数据报*可以被认为是消息的同义词）。在因特网语言中，TCP和UDP有时被称为*端到端* 协议，尽管将它们称为*传输*协议同样正确 。

在传输层上运行的是一系列应用程序协议，例如HTTP，FTP，Telnet（远程登录）和简单邮件传输协议（SMTP），它们可以实现流行应用程序的互操作。要了解应用程序层协议和应用程序之间的区别，请考虑所有可用或不可用的万维网浏览器（例如，Firefox，Chrome，Safari，Netscape，Mosaic，Internet Explorer）。存在类似的大量不同的Web服务器实现。您可以使用这些应用程序中的任何一个访问Web上的特定站点的原因是它们都符合相同的应用程序层协议：HTTP。令人困惑的是，相同的术语有时适用于它使用的应用程序和应用程序层协议（例如，大多数在网络领域积极工作的人都熟悉Internet体系结构和7层OSI体系结构，并且对于体系结构之间的层映射存在一致意见。Internet的应用层被认为是第7层，其传输层是第4层，IP（网络互联或网络）层是第3层，IP下面的链路或子网层是第2层。

Internet体系结构有三个值得强调的功能。

- 互联网架构并不意味着严格的分层。应用程序可以自由地绕过定义的传输层并直接使用IP或其中一个底层网络。事实上，程序员可以自由定义在任何现有协议之上运行的新通道抽象或应用程序。

- 其次，如果仔细观察中的协议图 ，你会注意到顶部有一个沙漏形状，中间是窄的，底部是宽的。这种形状实际上反映了建筑的核心理念。也就是说，IP充当架构的焦点 - 它定义了在广泛的网络集合之间交换数据包的常用方法。在IP之上，可以有任意多个传输协议，每个传输协议为应用程序提供不同的信道抽象。因此，从主机到主机传递消息的问题与提供有用的进程到进程通信服务的问题完全分开。在IP之下，该架构允许任意多种不同的网络技术，从以太网到无线到单点到点链路。

- 互联网体系结构（或更准确地说，IETF文化）的最终属性是，为了将新协议正式包含在体系结构中，必须同时具有协议规范和至少一个（最好是两个）代表规范的实现。IETF采用标准需要工作实现的存在。设计社区的这种文化假设有助于确保可以有效地实现架构的协议。也许互联网文化对工作软件的价值最好的例外是IETF会议上常见的T恤上的引用：

*我们拒绝国王，总统和投票。我们相信粗略的共识和运行代码。* **（大卫克拉克）**

重点

在互联网架构的这三个属性中，沙漏设计理念非常重要，可以重复使用。沙漏的窄腰代表了一套最小且精心挑选的全球功能，允许更高级别的应用程序和更低级别的通信技术共存，共享功能并快速发展。窄腰模型对于互联网快速适应新用户需求和不断变化的技术的能力至关重要。

### 1.4软件

网络架构和协议规范是必不可少的，但良好的蓝图不足以解释互联网的巨大成功：连接到互联网的计算机数量已经呈指数增长近30年（虽然很难得到准确的数字） 。截至2017年底，互联网用户数估计约为41亿，约占全球人口的一半。

是什么解释了互联网的成功？当然有许多因素（包括一个好的架构），但是使互联网取得巨大成功的一个原因是它的大部分功能都是由通用计算机上运行的软件提供的。这样做的意义在于，只需要一小部分编程就可以轻松添加新功能。结果，新的应用程序和服务以惊人的速度出现。

一个相关因素是商用机器中可用的计算能力的大幅增加。虽然计算机网络原则上一直能够传输任何类型的信息，例如数字语音样本，数字化图像等，但如果发送和接收数据的计算机太慢而无法做任何有用的事情，这种潜力就不是特别有趣了。有了这些信息。实际上，今天所有的计算机都能够以非常实用的速度和分辨率播放数字化的音频和视频。

自本书第一版出现以来的几年里，网络应用程序的编写已经成为一种更为主流的活动，而不仅仅是针对少数专家的工作。许多因素已经发挥作用，包括更好的工具，使非专业人士的工作更容易，以及开放智能手机应用等新市场。

需要注意的是，了解如何实现网络软件是理解计算机网络的重要部分，虽然你可能不必实现像IP这样的低级协议，但你很可能写一个应用程序级协议 ，编写一个“杀手级应用程序”，将导致难以想象的名声和财富。为了帮助您入门，本节介绍了在Internet上实现网络应用程序所涉及的一些问题。通常，这样的程序同时是应用程序（被设计为与用户交互）和协议（通过网络与对等方通信）。

#### 应用程序编程接口（套接字）

实现网络应用程序时的起点是网络导出的接口。由于大多数网络协议都在软件中（特别是协议栈中的那些），并且几乎所有计算机系统都将其网络协议实现为操作系统的一部分，因此当我们谈到“由网络导出”的接口时，我们通常指的是到操作系统提供给其网络子系统的接口。此接口通常称为网络*应用程序编程接口*（API）。

尽管每个操作系统都可以自由定义自己的网络API（并且大多数都有），但随着时间的推移，某些API已经得到广泛支持; 也就是说，它们已被移植到除其本机系统之外的操作系统。这是最初由Unix的Berkeley发行版提供的*套接字接口*所发生的，现在几乎所有流行的操作系统都支持它，并且是特定于语言的接口的基础，例如Java或Python套接字库。行业范围内对单个API的支持的优势在于，应用程序可以轻松地从一个操作系统移植到另一个操作系统，开发人员可以轻松地为多个操作系统编写应用程序。

> 不想在Java-v-Python-v-Go辩论中选择方面，并且因为它仍然是网络内部的首选语言，本书中给出的所有代码示例都是用C语言编写的，并且直接使用OS级接口。

在描述套接字接口之前，重要的是要记住两个问题。每个协议都提供一组特定的 *服务*，API提供了一种*语法，*通过该*语法*可以在特定的计算机系统上调用这些服务。然后，实现负责将由API定义的有形操作集和对象映射到协议定义的抽象服务集。如果您已经很好地定义了接口，那么就可以使用接口的语法来调用许多不同协议的服务。这种普遍性当然是套接字接口的目标。

毫无疑问，套接字接口的主要抽象是 *套接字*。考虑套接字的好方法是本地应用程序进程连接到网络的点。该接口定义了创建套接字，将套接字连接到网络，通过套接字发送/接收消息以及关闭套接字的操作。为了简化讨论，我们将仅限于展示如何使用TCP套接字。

第一步是创建一个套接字，完成以下操作：

```c
int socket(int domain, int type, int protocol)
```

此操作采用三个参数的原因是套接字接口设计得足够通用以支持任何底层协议套件。具体来说， `domain`参数指定 将要使用的协议*族*：`PF_INET`表示Internet系列，`PF_UNIX`表示Unix管道设施，并 `PF_PACKET`表示直接访问网络接口（即，它绕过TCP / IP协议栈）。`type` 参数表明了通信的语义。 `SOCK_STREAM`用于表示字节流。 `SOCK_DGRAM`是一种替代方案，表示面向消息的服务，例如UDP提供的服务。该 `protocol`参数标识将要使用的特定协议。在我们的例子中，这个论点是`UNSPEC` 因为TCP 的组合`PF_INET`和 `SOCK_STREAM`暗示TCP。最后，返回值 `socket`是新创建的套接字的*句柄* - 也就是我们将来可以引用套接字的标识符。它作为此套接字上的后续操作的参数给出。

下一步取决于您是客户还是服务器。在服务器计算机上，应用程序进程执行*被动*打开 - 服务器表示它已准备好接受连接，但它实际上并不建立连接。服务器通过调用以下三个操作来完成此操作：

```c
int bind(int socket, struct sockaddr *address, int addr_len)
int listen(int socket, int backlog)
int accept(int socket, struct sockaddr *address, int *addr_len)
```

`bind`顾名思义，该操作将新创建的绑定绑定`socket`到指定的操作`address`。这是*本地*参与者 - 服务器的网络地址。请注意，与Internet协议一起使用时， `address`是包含服务器的IP地址和TCP端口号的数据结构。端口用于间接识别进程。它们是一种*解复用密钥*。端口号通常是一些特定于所提供服务的众所周知的号码; 例如，Web服务器通常接受端口80上的连接。

`listen`然后，该操作定义指定的挂起数量`socket`。最后， `accept`操作执行被动打开。这是一个阻塞操作，在远程参与者建立连接之前不会返回，当它完成时，它返回一个与此刚建立的连接相对应的*新*套接字，该`address`参数包含 *远程*参与者的地址。注意， `accept`返回时，作为参数给出的原始套接字仍然存在并且仍然对应于被动打开; 它用于将来的调用`accept`。

在客户端计算机上，应用程序进程执行 *活动*打开; 也就是说，它通过调用以下单个操作来说明它想与谁通信：

```c
int connect(int socket, struct sockaddr *address, int addr_len)
```

在TCP成功建立连接之前，此操作不会返回，此时应用程序可以自由开始发送数据。在这种情况下， `address`包含远程参与者的地址。实际上，客户端通常只指定远程参与者的地址，并让系统填写本地信息。服务器通常在一个众所周知的端口上侦听消息，而客户端通常不关心它自己使用哪个端口; 操作系统只选择一个未使用的。

建立连接后，应用程序进程将调用以下两个操作来发送和接收数据：

```c
int send(int socket, char *message, int msg_len, int flags)
int recv(int socket, char *buffer, int buf_len, int flags)
```

第一个操作发送给定`message` 的指定的`socket`，而第二个操作从指定的接收`socket`到给定的消息`buffer`。两个操作都采用一组 `flags`控制操作的某些细节。

#### 示例应用

我们现在展示一个简单的客户端/服务器程序的实现，该程序使用套接字接口通过TCP连接发送消息。该程序还使用其他Unix网络实用程序，我们将继续介绍。我们的应用程序允许一台机器上的用户键入并向另一台机器上的用户发送文本。它是Unix `talk`程序的简化版本，类似于即时消息应用程序核心的程序。

### 客户

我们从客户端开始，它将远程计算机的名称作为参数。它调用Unix实用程序将此名称转换为远程主机的IP地址。下一步是构造`sin`套接字接口所期望的地址数据结构（）。请注意，此数据结构指定我们将使用套接字连接到Internet（`AF_INET`）。在我们的示例中，我们使用TCP端口5432作为众所周知的服务器端口; 这恰好是一个尚未分配给任何其他Internet服务的端口。设置连接的最后一步是调用`socket`和`connect`。一旦操作返回，就建立连接并且客户端程序进入其主循环，主循环从标准输入读取文本并通过套接字发送。

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

#define SERVER_PORT 5432
#define MAX_LINE 256

int
main(int argc, char * argv[])
{
  FILE *fp;
  struct hostent *hp;
  struct sockaddr_in sin;
  char *host;
  char buf[MAX_LINE];
  int s;
  int len;

  if (argc==2) {
    host = argv[1];
  }
  else {
    fprintf(stderr, "usage: simplex-talk host\n");
    exit(1);
  }

  /* translate host name into peer's IP address */
  hp = gethostbyname(host);
  if (!hp) {
    fprintf(stderr, "simplex-talk: unknown host: %s\n", host);
    exit(1);
  }

  /* build address data structure */
  bzero((char *)&sin, sizeof(sin));
  sin.sin_family = AF_INET;
  bcopy(hp->h_addr, (char *)&sin.sin_addr, hp->h_length);
  sin.sin_port = htons(SERVER_PORT);

  /* active open */
  if ((s = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
    perror("simplex-talk: socket");
    exit(1);
  }
  if (connect(s, (struct sockaddr *)&sin, sizeof(sin)) < 0)
  {
    perror("simplex-talk: connect");
    close(s);
    exit(1);
  }
  /* main loop: get and send lines of text */
  while (fgets(buf, sizeof(buf), stdin)) {
    buf[MAX_LINE-1] = '\0';
    len = strlen(buf) + 1;
    send(s, buf, len, 0);
  }
}
```

### 服务器

服务器同样简单。它首先通过填写自己的端口号（`SERVER_PORT`）来构造地址数据结构。通过不指定IP地址，应用程序愿意接受任何本地主机的IP地址上的连接。接下来，服务器执行被动打开所涉及的预备步骤; 它创建套接字，将其绑定到本地地址，并设置允许的最大挂起连接数。最后，主循环等待远程主机尝试连接，当它执行连接时，它接收并打印出到达连接的字符。

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

#define SERVER_PORT  5432
#define MAX_PENDING  5
#define MAX_LINE     256

int
main()
{
  struct sockaddr_in sin;
  char buf[MAX_LINE];
  int len;
  int s, new_s;

  /* build address data structure */
  bzero((char *)&sin, sizeof(sin));
  sin.sin_family = AF_INET;
  sin.sin_addr.s_addr = INADDR_ANY;
  sin.sin_port = htons(SERVER_PORT);

  /* setup passive open */
  if ((s = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
    perror("simplex-talk: socket");
    exit(1);
  }
  if ((bind(s, (struct sockaddr *)&sin, sizeof(sin))) < 0) {
    perror("simplex-talk: bind");
    exit(1);
  }
  listen(s, MAX_PENDING);

 /* wait for connection, then receive and print text */
  while(1) {
    if ((new_s = accept(s, (struct sockaddr *)&sin, &len)) < 0) {
      perror("simplex-talk: accept");
      exit(1);
    }
    while (len = recv(new_s, buf, sizeof(buf), 0))
      fputs(buf, stdout);
    close(new_s);
  }
}
```

内容[应用程序编程接口（套接字）](https://book.systemsapproach.org/foundation/software.html#application-programming-interface-sockets)[示例应用](https://book.systemsapproach.org/foundation/software.html#example-application)

### 1.5性能

到目前为止，我们主要关注网络的功能方面。然而，与任何计算机系统一样，计算机网络也可以性能良好。这是因为网络有效性通常直接取决于网络传递数据的效率。虽然旧的编程格言“首先使其正确，然后使其快速”仍然是正确的，但在网络中，通常需要“设计性能”。因此，了解影响网络性能的各种因素非常重要。

#### 带宽和延迟

网络性能以两种基本方式测量：*带宽* （也称为*吞吐量*）和*延迟*（也称为*延迟*）。网络的带宽由在一段时间内可以通过网络传输的比特数给出。例如，网络可能具有1000万比特/秒（Mbps）的带宽，这意味着它能够每秒传送1000万比特。根据传输每一位数据所需的时间来考虑带宽有时是有用的。例如，在10 Mbps网络上，它需要0.1微秒（\亩*μ* S）来发送每个比特。

带宽和吞吐量是微妙的不同术语。首先，带宽实际上是频带宽度的度量。例如，传统的语音级电话线支持300至3300Hz的频带; 据说它的带宽为3300 Hz - 300 Hz = 3000 Hz。如果您看到在以赫兹为单位测量的情况下使用的*带宽*，那么它可能指的是可以容纳的信号范围。

当我们谈论通信链路的带宽时，我们通常指的是可以在链路上传输的每秒比特数。这有时也称为*数据速率。*我们可以说以太网链路的带宽是10 Mbps。但是，也可以在链路上可用的最大数据速率和我们实际上可以通过链路实际传输的每秒位数之间进行有用的区分。我们倾向于使用“ *吞吐量”*这个词 来指代*测量的性能*一个系统。因此，由于各种低效率的实现，通过具有10Mbps带宽的链路连接的一对节点可以实现仅2Mbps的吞吐量。这意味着一台主机上的应用程序可以以2 Mbps的速度向另一台主机发送数据。

最后，我们经常讨论应用程序的带宽*要求*。这是它需要通过网络传输以实现可接受的每秒位数。对于某些应用程序，这可能是“我能得到的任何东西”; 对于其他人，它可能是一些固定的数字（最好不超过可用的链路带宽）; 而对于其他人来说，它可能是一个随时间变化的数字。我们将在本节后面提供有关此主题的更多信息。

虽然您可以谈论整个网络的带宽，但有时您希望更精确，例如，关注单个物理链路或逻辑进程到进程通道的带宽。在物理层面，带宽不断提高，看不到尽头。直观地说，如果你把第二个时间想象成一个距离，你可以用一个标尺和带宽来衡量这个距离适合多少位，那么你可以把每个位都想象成一个宽度的脉冲。例如，1-Mbps链路上的每个比特都是1\m*μ*的广泛，而每个2-Mbps链路上的位为0.5\亩*μ*的广泛，如在示出的 [图1中](https://book.systemsapproach.org/foundation/performance.html#bit-width)。发送和接收技术越复杂，每个比特就越窄，因此带宽就越高。对于逻辑进程到进程通道，带宽也受其他因素的影响，包括实现通道的软件必须处理并可能转换每个数据位的次数。

![img](https://book.systemsapproach.org/foundation/figures/f01-16-9780123850591.png)

在特定带宽发送的比特可以被认为具有一些宽度：（a）以1Mbps发送的比特（每个比特是1微秒宽）; （b）以2 Mbps发送的比特（每个比特是0.5微秒宽）。

第二个性能指标（延迟）对应于消息从网络的一端传输到另一端的时间。（与带宽一样，我们可以关注单个链路或端到端信道的延迟。）延迟严格按时间进行测量。例如，横贯大陆网络的延迟可能为24毫秒（ms）; 也就是说，从北美的一个海岸到另一个海岸需要24毫秒的信息。在许多情况下，更重要的是要知道将消息从网络的一端发送到另一端并返回，而不是单向延迟需要多长时间。我们称之为*网络的往返时间*（RTT）。

我们经常将延迟视为具有三个组件。首先，存在光速传播延迟。发生这种延迟是因为没有任何东西，包括导线上的一点，可以比光速更快地传播。如果你知道两点之间的距离，你可以计算光速延迟，虽然你必须要小心，因为光以不同的速度穿过不同的媒体：它以3.0的速度传播\倍× 10^ 8米/秒，在真空，2.3× 10^ 8米/秒在铜电缆，和2.0\ 10^ 8米/秒的光纤。其次，传输一个数据单元需要一定的时间。这是网络带宽和承载数据的数据包大小的函数。第三，网络内部可能存在排队延迟，因为分组交换机通常需要将数据包存储一段时间才能在出站链路上转发它们。因此，我们可以将总延迟定义为

```c
Latency = Propagation + Transmit + Queue
Propagation =  Distance/SpeedOfLight
Transmit = Size/Bandwidth
```

`Distance`数据将在其上传播的线的长度在哪里，是该线上`SpeedOfLight`的有效光速，`Size`是数据包的大小，以及`Bandwidth`数据包传输的带宽。注意，如果消息只包含一个比特并且我们正在谈论单个链路（而不是整个网络），则`Transmit`和`Queue`条款不相关，并且延迟仅对应于传播延迟。

带宽和延迟相结合，以定义给定链路或信道的性能特征。然而，它们的相对重要性取决于应用。对于某些应用，延迟比带宽重要。例如，向服务器发送1字节消息并接收1字节消息的客户端是延迟占主要性能因素。假设准备响应时没有涉及严重的计算，那么应用程序在具有100毫秒RTT的跨洲频道上的执行速度将大于在具有1毫秒RTT的室内频道上执行的情况。然而，通道是1 Mbps还是100 Mbps是相对无关紧要的，因为前者暗示传输byte（`Transimt`）的时间是8\*μ* s，并且后者意味着 `Transmit`= 0.08\*μ*秒。

相反，考虑一个被要求获取25兆字节（MB）图像的数字图书馆程序 - 可用的带宽越多，它能够将图像返回给用户的速度就越快。这里，信道的带宽主导了性能。为此，假设信道的带宽为10 Mbps。传输图像需要20秒（25\倍× 10^ 6 \次6 ×8位/（10 \倍× 10^ 66 Mbps的= 20秒），使得如果图像是在1毫秒的信道或一个100-ms通道的另一侧它相对不重要; 20.001秒响应时间和20.1秒响应时间之间的差异可以忽略不计。

![img](https://book.systemsapproach.org/foundation/figures/f01-17-9780123850591.png)各种对象大小和链接速度的感知等待时间（响应时间）与往返时间。

[图2](https://book.systemsapproach.org/foundation/performance.html#latency)让您了解延迟或带宽如何在不同情况下支配性能。该图显示了跨越网络移动各种大小（1字节，2 KB，1 MB）对象所需的时间，RTT范围为1到100 ms，链路速度为1.5或10 Mbps。我们使用对数标度来显示相对性能。对于1字节对象（例如，击键），延迟几乎完全等于RTT，因此您无法区分1.5 Mbps网络和10 Mbps网络。对于2 KB对象（例如，电子邮件消息），链接速度在1毫秒RTT网络上产生很大差异，但在100毫秒RTT网络上差异可以忽略不计。对于1 MB的对象（比如数字图像），RTT没有区别 - 链接速度在整个RTT范围内主导性能。

请注意，在本书中，我们以通用方式使用*延迟*和*延迟*这两个术语来表示执行特定功能所需的时间，例如传递消息或移动对象。当我们指的是信号从链路的一端传播到另一端的特定时间量时，我们使用术语*传播延迟*。此外，我们在讨论的背景下明确指出我们是指单向延迟还是往返时间。

另外，计算机变得如此之快，以至于当我们将它们连接到网络时，至少在比喻方面考虑  *指令*有时是有用的。考虑当能够每秒执行1000亿条指令的计算机在具有100毫秒RTT的信道上发送消息时会发生什么。（为了使数学运算更容易，假设消息覆盖5000英里的距离。）如果该计算机闲置整个100毫秒等待回复消息，那么它已经丧失了执行100亿条指令或200万条指令的能力每英里。最好还是值得通过网络来证明这种浪费。

#### 延迟x带宽产品

讨论这两个指标的乘积也很有用，通常称为*延迟* \倍× *带宽产品*。直观地说，如果我们将一对过程之间的通道看作一个空心管道（ [见图3](https://book.systemsapproach.org/foundation/performance.html#pipe)），其中延迟对应于管道的长度，带宽给出管道的直径，那么延迟 \倍× bandwidth product给出管道的容量 - 在任何给定时刻可以通过管道传输的最大位数。换句话说，如果延迟（在时间上测量）对应于管道的长度，则给定每个钻头的宽度（也在时间上测量），您可以计算管道中适合的钻头数量。例如，具有50ms单向延迟和45Mbps带宽的跨大陆信道能够保持大约280 KB的数据。换句话说，这个示例通道（管道）拥有与20世纪80年代早期的个人计算机存储器一样多的字节。

![img](https://book.systemsapproach.org/foundation/figures/f01-18-9780123850591.png)网络作为管道。

延误 \倍×带宽产品在构建高性能网络时很重要，因为它对应于发送器在第一个比特到达接收器之前必须发送的比特数。如果发送方期望接收方以某种方式发信号通知比特开始到达，并且此信号需要另一个信道延迟传播回发送方，则发送方可以发送一个*RTT* \倍× 从接收器听到之前的数据*带宽*值一切都很好。管道中的位被称为“飞行中”，这意味着如果接收方告诉发送方停止发送，它可能最多接收一个RTT\倍×在发送者设法响应之前，带宽的数据价值。在上面的示例中，该金额对应于5.5\倍× 10^ 66个的数据比特（671 KB）。另一方面，如果发送者没有填充管道 - 即，不发送整个RTT\倍×带宽产品在停止等待信号之前的数据价值 - 发送方将无法充分利用网络。

请注意，大多数时候我们对RTT场景感兴趣，我们简单地将其称为延迟 \倍×带宽乘积，没有明确地说“延迟”是RTT（即，将单向延迟乘以2）。通常，是否“延迟”延迟\倍×带宽意味着单向延迟或RTT由上下文清楚。 [表1](https://book.systemsapproach.org/foundation/performance.html#delay-bw)显示了RTT的一些示例\倍×一些典型网络链路的带宽产品。



示例延迟x带宽产品。

| 链接类型 |  带宽   |  单向距离  |       RTT       | RTT x带宽 |
| :------: | :-----: | :--------: | :-------------: | :-------: |
| 无线网络 | 54 Mbps |   50公尺   | 0.33 \亩*μ*小号 |   18位    |
|   卫星   | 1 Gbps  | 35,000公里 |     230毫秒     |  230 Mb   |
| 越野纤维 | 10 Gbps | 4,000公里  |     40毫秒      |  400 Mb   |

#### 高速网络

看似持续增加的带宽使网络设计人员开始考虑在极限内发生的事情，或者换句话说，对于拥有无限带宽的网络设计会有什么影响。

尽管高速网络带来了应用程序可用带宽的巨大变化，但在许多方面，它们对我们如何思考网络的影响来自于带宽增加时*不会*改变的因素：光速。引用“ *星际迷航* ”中的Scotty *，* “你可以改变物理定律。” 换句话说，“高速”并不意味着延迟以与带宽相同的速率改善; 1-Gbps链路的横贯大陆RTT与1-Mbps链路的100 ms相同。

要了解面对固定延迟时不断增加的带宽的重要性，请考虑通过1 Mbps网络传输1 MB文件与1 Gbps网络传输所需的内容，两者的RTT均为100 ms 。在1-Mbps网络的情况下，传输文件需要80次往返时间; 在每个RTT期间，发送1.25％的文件。相比之下，相同的1 MB文件甚至没有接近填充1个RTT的1-Gbps链路，其延迟x带宽乘积为12.5 MB。

[图4](https://book.systemsapproach.org/foundation/performance.html#bw-lat)说明了两个网络之间的差异。实际上，1 MB文件看起来像需要通过1 Mbps网络传输的数据流，而它看起来像是1 Gbps网络上的单个数据包。为了帮助推动这一点，请考虑1 MB的文件是1-Gbps网络，1-KB *数据包* 是1-Mbps网络。

![img](https://book.systemsapproach.org/foundation/figures/f01-19-9780123850591.png)带宽和延迟之间的关系。1 MB的文件将填充1 Mbps链路80次，但只填充1-Gbps链路的1/12。

考虑这种情况的另一种方法是，在高速网络上的每个RTT期间可以传输更多数据，以至于单个RTT变得大量时间。因此，虽然您不会考虑文件传输采用101 RTT而不是100 RTT之间的差异（相对差异仅为1％），但突然1 RTT和2 RTT之间的差异显着 - 增加100％。换句话说，延迟而不是吞吐量开始主导我们对网络设计的思考。带宽很大时候，延迟称为了影响网络设计的主导因素。

理解吞吐量和延迟之间关系的最佳方法可能是回归基础。通过简单的关系可以在网络上实现有效的端到端吞吐量

吞吐量= TransferSize / TransferTime

其中不仅包括本节前面所述的单向元素，还包括请求或设置传输所需的任何额外时间。通常，我们将此关系表示为

TransferTime = RTT + 1 / Bandwidth x TransferSize

我们在此计算中使用来计算通过网络发送的请求消息以及发回的数据。例如，考虑用户想要以1 Gbps的速度获取1 MB文件，往返时间为100 ms的情况。这包括1 MB的传输时间（1/1 Gbps）\倍× 1 MB = 8 ms）和100 ms RTT，总传输时间为108 ms。这意味着有效吞吐量将是

1 MB / 108 ms = 74.1 Mbps

不是1 Gbps。显然，传输大量数据有助于提高有效吞吐量，在极限情况下，无限大的传输大小将导致有效吞吐量接近网络带宽。另一方面，必须承受超过1个RTT（例如，重传丢失的数据包）将损害有限大小的任何传输的有效吞吐量，并且对于小型传输将是最明显的。

由于延时原因，即使无限带宽的吞吐量也会受到延时的影响，传输时间不可能低于延时。

应用程序性能需求

本节中的讨论采用了以网络为中心的性能观点; 也就是说，我们已经讨论了给定链接、支持的内容。未说明的假设是应用程序具有简单的需求 - 它们需要与网络一样多的带宽。对于检索250-MB图像的上述数字图书馆程序来说，情况确实如此; 可用带宽越多，程序将图像返回给用户的速度就越快。

但是，某些应用程序能够说明所需带宽的上限。视频应用是一个很好的例子。假设有人想要传输一个标准电视屏幕大小四分之一的视频; 也就是说，它的分辨率为352 x 240像素。如果每个像素由24位信息表示，就像24位颜色的情况一样，那么每个帧的大小将是

（352 \次240 \次24）/ 8 = 247.5 KB（3 5 2 × 2 4 0 × 2 4 ）/ 8 = 2 4 7 。5 *K* *B.*

如果应用程序需要支持每秒30帧的帧速率，那么它可能要求75 Mbps的吞吐率。网络提供更多带宽的能力对于这样的应用是不感兴趣的，因为它在给定的时间段内仅具有如此多的数据要传输。

不幸的是，情况并不像这个例子所暗示的那么简单。因为视频流中任何两个相邻帧之间的差异通常很小，所以可以通过仅发送相邻帧之间的差异来压缩视频。每个帧也可以被压缩，因为并非图像中的所有细节都容易被人眼察觉。压缩视频不以恒定速率流动，而是根据诸如图像中的动作量和细节以及所使用的压缩算法等因素随时间变化。因此，可以说平均带宽要求是多少，但瞬时速率可以更多或更少。

关键问题是计算平均值的时间间隔。假设这个示例视频应用程序可以压缩到平均只需要2 Mbps的程度。如果它在1秒间隔内发送1兆比特，在接下来的1秒间隔内发送3兆比特，那么在2秒间隔内它以2 Mbps的平均速率发送; 然而，对于一个被设计为在任何一秒钟内支持不超过2兆比特的信道，这将没有价值的。显然，仅仅了解应用程序的平均带宽需求并不总是足够的。

然而，通常，可以对像这样的应用可能传输的突发的大小设置上限。可以通过维持一段时间的某个峰值速率来描述突发。或者，它可以被描述为在恢复到平均速率或某个较低速率之前可以以峰值速率发送的字节数。如果此峰值速率高于可用信道容量，则必须在某处缓冲多余数据，以便稍后传输。知道可以发送多大的突发允许网络设计者分配足够的缓冲容量来保持突发。

类似于应用程序带宽需求的方式可能不是“它可以得到的”，应用程序的延迟要求可能比“尽可能少的延迟”更复杂。在延迟的情况下，有时无论网络的单向延迟是100毫秒还是500毫秒，因为从数据包到数据包的延迟有多大。延迟的变化称为*抖动*。

考虑源每33毫秒发送一次数据包的情况，就像视频应用每秒发送30次帧的情况一样。如果数据包到达目的地的距离恰好相隔33毫秒，那么我们可以推断出网络中每个数据包所经历的延迟完全相同。然而，如果数据包到达目的地之间的间隔 - 有时称为 *数据包间间隙* - 变量，那么数据包序列所经历的延迟也必须是可变的，并且据说网络已经引入了抖动。数据包流，[如图5](https://book.systemsapproach.org/foundation/performance.html#jitter)所示 。这种变化通常不会在单个物理链路中引入，但是当数据包在多跳分组交换网络中经历不同的排队延迟时会发生这种变化。此排队延迟对应于本节前面定义的延迟组件，该组件随时间变化。

![img](https://book.systemsapproach.org/foundation/figures/f01-20-9780123850591.png)网络引起的抖动。

为了理解抖动的相关性，假设通过网络传输的数据包包含视频帧，并且为了在屏幕上显示这些帧，接收器需要每33 ms接收一个新帧。如果一个帧提前到达，那么它可以简单地由接收器保存，直到它有时间显示它。不幸的是，如果一帧到达较晚，那么接收器将不会及时更新屏幕所需的帧，并且视频质量将受损; 它不会顺利。请注意，没有必要消除抖动，只知道它有多糟糕。这样做的原因是，如果接收者知道数据包可以经历的延迟的上限和下限，则可以延迟开始播放视频的时间（即，显示第一帧）足够长，以确保将来它总是有一个框架可以在需要时显示。接收器通过将帧存储在缓冲器中来延迟帧，从而有效地平滑抖动。

内容[带宽和延迟](https://book.systemsapproach.org/foundation/performance.html#bandwidth-and-latency)[延迟x带宽产品](https://book.systemsapproach.org/foundation/performance.html#delay-x-bandwidth-product)[高速网络](https://book.systemsapproach.org/foundation/performance.html#high-speed-networks)[应用程序性能需求](https://book.systemsapproach.org/foundation/performance.html#application-performance-needs)

### 1.6更广泛的视角

#### 特征速度

本章介绍计算机网络中的一些利益相关者 - 网络设计人员，应用程序开发人员，最终用户和网络运营商 - 以帮助激发塑造网络设计和构建方式的技术要求。这假设所有设计决策都纯粹是技术性的，但当然，通常情况并非如此。从市场力量，政府政策到道德考虑等许多其他因素也会影响网络的设计和建设。

其中，市场是最具影响力的，并且对应于网络运营商（例如AT＆T，康卡斯特，Verizon，DT，NTT，中国移动），网络设备供应商（例如，思科，瞻博网络，爱立信，诺基亚，华为）之间的相互作用），应用程序和服务提供商（例如，Facebook，谷歌，亚马逊，微软，苹果，Netflix，Spotify），当然还有订户和客户（即个人，还有企业和企业）。他们之间的界限并不总是清晰，许多公司扮演着多重角色。最值得注意的例子是大型云提供商，他们（a）使用商品组件构建自己的网络设备，（b）部署和运营自己的网络，（c）提供最终用户服务和应用程序。

当您在技术设计过程中考虑这些其他因素时，您会发现在故事的教科书版本中有一些隐含的假设需要重新评估。一个是设计网络是一次性活动。构建一次并永久使用它（硬件升级，以便用户可以享受最新性能改进带来的好处）。第二，构建网络的工作大部分与运营网络的工作分开。这些假设都不是正确的。

网络的设计显然在不断发展，多年来我们在每本新版教科书中记录了这些变化。在多年来测量的时间轴上做到这一点在历史上已经足够好了，但是任何已经下载并使用最新智能手机应用程序的人都知道，按照今天的标准，以前任何事情都会变得非常缓慢。进化设计必须成为决策过程的一部分。

在第二点，构建网络的公司几乎总是与运营它们的公司相同。它们统称为 *网络运营商*，它们包括上面列出的公司。但是，如果我们再次向云寻求灵感，我们会发现开发和运营在公司层面并不正确，但它也是最快速发展的云计算公司组织其工程团队的方式：围绕*DevOps*模型。（如果您不熟悉DevOps，我们建议您阅读*网站可靠性工程：Google如何运行生产系统*以了解它是如何实施的。）

这一切都意味着计算机网络正在进行重大转型，网络运营商试图同时加快创新步伐（有时称为特征速度），并继续提供可靠的服务（保持稳定性）。他们越来越多地通过采用云提供商的最佳实践来实现这一目标，这可以概括为具有两个主要主题：（1）利用商用硬件并将所有智能转 移到软件中;（2）采用敏捷的工程流程打破降低开发和运营之间的障碍。

这种转换有时被称为网络的“云化”或“软化”，但是通过另一个名称，它被称为 *软件定义网络*（SDN）。无论你怎么称呼它，这种新方法都是一个改变游戏规则的方式，而不是我们如何解决框架，路由，分段/重组，数据包调度，拥塞控制，安全等基本技术挑战，但就其而言网络发展到支持新功能的速度有多快

这种转变非常重要，我们将在每章末尾的“ *更广泛的视角”*部分再次讨论 。正如这些讨论将探讨的那样，网络行业中发生的事情部分是关于技术，还部分涉及许多其他非技术因素，所有这些都证明了互联网在我们生活中的深度嵌入。