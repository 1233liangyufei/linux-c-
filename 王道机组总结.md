# 第一章

1. 计算机器件：**电子管，晶体管，中小规模集成电路，大规模集成电路**
2. 微型处理器以**微处理器**发展为标志
3. 计算机上直接执行的语言：**机器语言**
4. 助记符编写语言：**汇编语言**
5. **正则语言**：编译原理复合正则文法的语言
6. **解释语言**：边翻译边执行
7. **编译**：高级语言到汇编语言
8. **汇编**：汇编语言到机器语言
9. **二进制**原因：电子器件性能决定
10. **计算机系统**包括：软件和硬件都有
11. **主机**包括：运算，存储，控制器
12. 冯诺依曼机是控制流驱动的，存储程序思想
13. 冯诺依曼机特点：地址访问，顺序执行指令
14. 相联存储器特点：存储器内容选址
15. cpu区分数据和指令的依据：指令周期的不同阶段，取指阶段与执行阶段，而不是操作吗的译码结果，这是确定了数据指令后的操作
16. 软件的功能和硬件的功能在逻辑上是等效的，但是不是等价的。切记
17. 存放想要执行指令的寄存器是IR指令寄存器，
18. PC存放下一条指令的地址
19. MAR想要访问的存储单元地址
20. MDR存储单元取来的数据
21. 地址译码器是主存部分，不属于cpu
22. 指令寄存器，地址寄存器，通用寄存器都是cpu组成部分
23. MAR 地址吗长度 MDR存储字长
24. 运算器包括 alu 数据总线 状态寄存器，
25. 地址寄存器用来保存cpu访问内存的地址
26. 速度：寄存器，cache sram,内存 dram，外存
27. 地址空间和地址总线长度有关 2^(地址线长度) 2^16 = 65536
28. 程序运行时候在主存上
29. 文本处理软件是应用软件
30. 连接程序 服务性程序
31. 操作系统 系统软件
32. 编译程序 语言处理程序
33. 解释程序，解释一条执行一条，执行速度较慢
34. 高级语言到目标代码文件 编译程序
35. 源程序    通过**编译程序**   变为汇编源程序
36. 汇编源程序 通过**汇编程序**  到目标程序 
37. 目标程序 通过**链接程序**到可执行程序
38. **翻译程序**：编译程序和解释程序
39. 汇编程序可以操作寄存器
40. 向后兼容就是新机器可以运行以前的系统
41. cpu 运算控制器 不包括存储器
42. 系统软件：数据库 编译 操作系统
43. 相联存储器，可地址，可内容寻址，普通的只能按地址寻址
44. 计算机6层关系：上层是下层的功能扩展，下层是上层基础
45. 硬件只能直接执行机器语言
46. 二进制：电路简单，运算容易，物理实现容易
47. **存储程序设计原理**

指令按代码形式事先输入计算机主存，按其在存储器的首地址执行第一条指令，以后按该程序的规定执行其他指令，直到程序执行结束

5大功能：

- 数据传输
- 数据存储
- 数据处理
- 操作控制
- 操作判断

48. 缩短程序时间的措施：

- 提高cpu时钟频率 主频
- 优化数据通路结构，数据通路就是是cpu内部寄存器数据交换功能，这可以提高数据吞吐量
- 程序编译优化  优化后指令序列更加合理或者条数更少

49. 名词

- mips 每秒执行几个百万指令
- MFLOPS 每秒多少百玩浮点数运算
- CPI 执行一条指令平均时钟数

50. 存储字长：存放在一个存储单元的二进制代码位数
51. 机器字长 数据运算基本单位
52. 磁盘 永久存放数据程序的设备
53. 数据字长是总线一次并行传输的信息位数，可以不等于MDR
54. 计算机的位数是机器字长，一次处理的二进制数长度，寄存器判断机器字长
55. 操作系统的位数是寻址位数
56. 科学计算性能参数 MFLOPS
57. 用户透明寄存器 IR MAR MDR 
58. 可见的寄存器PC 状态 通用
59. 时钟周期是计算机的最小单位，cpu周期也叫机器周期，由多个时钟周期组成
60. cpi与系统结构，指令集有关系，与时钟周期无关
61. 用户观点，性能 吞吐量
62. 提高性能途径：并行处理技术
63. 兼容：软件**或**硬件的通用性，同一系列通用
64. 会计电算化：数据处理应用
65. 计算精度：机器字长
66. mips = 主频Mhz/cpi
67. 64k 等于 2的16次方 地址总线16位

数据总线宽度32位 mar16 mdr32

因为指令字长等于存储字长等于机器字长 ir acc mq x32位

68. 指令周期 = 1/mips us
69. 每条指令时钟周期数= 指令周期/时钟周期








# 第二章

## 第一节

1. 进制转换

将其他进制转化为十进制

2. 16进制加法

类似于10进制，逢16进1

3. 进制转换

整数部分除基数取余法，小数部分，乘基取整法

4. 整数可以表示范围

无符号数表示范围 0-2^n-1

有符号 -2^n-1 -- 2^n-1 -1

5. 进制转换的精度问题

整数部分任何进制相互都可以准确转换

而小数部分可能在一个进制下是有限小数，另一个进制成了无限小数无法准确表示

二进制小数都可以以十进制准确表述，**但是十进制小数却不一定可以表示为二进制小数**

6. 判断8421码合法

8421 用一个4位的2进制数来表示，而4位二进制数可以表示16个数字，多于需要的10个数字，因此出现大于等于0的情况是非法的

1010 1011 1100 1101 1110 1111 这6个不行

6. 8421码的加法

8421转换10进制很方便，最好转为10进制加再转回来

0011 1000  38

0010 0011  23

38+23 = 61 

0110 0001

8. ascii码

ascii码有128个，需要7位来存储，但是字节为单位，占用1个字节8bit，空出的最高位留为0

9. 大端小端

小端 最低有效字节存在最小的位置

01234567H

int的起始地址就是int的存放地址，小端存放最低有效位 67H

10. 校验码

- 任意两个码字之间最少变化的二进制位数称为码距，码距等于2的数据检验码具备纠错能力
- 码距越大，检错纠错能力越强
- 奇偶检验只能检错不能纠错
- 海明码可以检错，可以纠错
- crc利用除法建立数据和检验位的关系

11. 奇偶检验码

对于偶检验码 最后一位凑一个数凑成偶数个1 如果收到的信息还是偶数个1，那么要不不出错，要不偶数错

奇偶检验可以检测奇数的错误 1 3 5

14. 设置奇偶检验码

41H 二进制 A100 0001 F 100 0110 

增加啊偶校验于最高位 1100 0110  C6H

15. 海明码检验位设置

n + 8  < 2^n n为5

16. 海明 发现2位错 纠正1位错
17. crc纠错方法：

- 请求重发
- 删除数据
- 余数自动修正

18. 大量数据的检验 crc

20. 海明码于crc

海明码编码 先利用 n + 8  < 2^n 计算需要4位，再加一个全校验位，将编码后的写出来，校验位空出来，p1校验二进制下个位1位置的数，p2校验二进制下十位1的数字，其他同理，p13是全部的偶检验码

crc编码 

模二除法的方法

crc用多项式左移r位除以生成多项式G x 得到的余数为校验码

## 第二节

1. 32位机器 int 32位 short 16位

x 127 0111 1111 扩展32位 0000007FH

y -9 1001 补码 0111 符号扩展 FFF7H

x+y y强制类型转换为32位FFFFFFF7H

0000007FH

FFFFFFF7H

数据的截取于保留，精度的丢失

数据转换不确定性，长的转短的会截断，long到short，只保留低位，误差很大

2. 数据的溢出

8位寄存器-128-127范围

r1 = 1111 1110  111 1110 000 0010   真值 -2

r2 = 1111 0010  111 0010 000 1110  真值 -14

r3 = 1001 0000  001 0000 111 0000 真值-(64+32+16)=-112

r4 = 1111 1000 111 1000 000 1000 真值 -8

r3*r2 = -112 * -14 超过128 溢出

3. 小端存储

边界对齐

int 32

char 8

short 16

00000000000000000000000000000000

int

00000000                     0000000000000

char                              short

这么存放

首地址0xC008 指向int最低位

273

273 =0x111 首地址指向最后一个字节0x11

内存按字节编址 8+6 = E

因此为0xC00E

4. 类型转换

无符号数 0填充 65535 FFFFH 65530 FFFA

5. 类型转换

short 到 unsighed short

内容不变，解释变了 -32767 

32767 转2进制 7FFF 补码 1000000000000000000000000000001

2^15+1 = 32768+1 = 32769

6. 真值表示唯一 补码 移码
7. 正数补码原码相同
8. 负数小数的补码与正数相同 1 0010110

取反加1 符号位不变

9. 求原码符号位取反
10. n位表示数据 2^n
11. 定点小数表示范围 -1+2^-n ——1-2^-n
12. 原码整数范围 -2^n+1 -- 2^n-1 原码是对称的 正负数相同
13. 补码左移 符号位不变，数值位左移，后面添0
14. 补码右移 添符号位补空
15. 补码 0唯一 减法可以加法实现 符号位参加运算
16. 最大值2^n-1 -1
17. 二者差值0.2 带特殊值n=1 值0.2可得
18. -2^n-1
19. 最小负数1.0000 真值为-1
20. 移码与补码表示范围相同
21. 移码补码符号位相反，其他位相同
22. 移码表示阶数 补码表示定点整数
23. 负数补码表示 -1/2 补码1.1000 小于这个 x1为0，其余随意
24. -32 补码 1 100000 大于-32 x1为1 后面至少有不为0的，否则全0相等了
25. <-16 x10 后面任意

24. 找规律 -0.75 010
25. 循环左移，左移的那位进入标志寄存器
26. 1011 1010 原码左移右移都补0

算术左移 1111 0100 F4

算术右移  1001 1101 9D

算术左移和逻辑左移一样都是右边补0

[算术右移](https://www.baidu.com/s?wd=%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)符号位要一起移动，并且在左边补上符号位，逻辑右移很简单，只要将二进制数整体右移

27. 补码

右移补符号位

1011 1010

1101 1101 DD

28. 当且仅当是充要条件 >=0都成立
29. 1000 1111 1010 0000
30. 双符号位 单符号位 都的溢出判断电路 异或门实现
31. 正数原码反码补码相同
32. 模4容易检验加减法的溢出问题
33. **模4只需要1个符号位，alu需要两个符号位**

33. -66 BD
34. 9BH -101
35. -0 原码100000000反码111111111
36. 11111111   移码 

127 原码 01111111

127 补码  移码补码最高位不同，其余相同

37. 11111111 -1     补码

38. 移码0000000是最小的 且是给负数

39. 反码

40. 移码000000 相反数会溢出

41. 正数相加 溢出 双符号位 01 负溢出 10

42. 双符号位 10 01 才溢出

43. 10 负溢出

44. 最高位符号位不同时候 溢出

45. 补码加法 左移右移

46. 103- -25 = 128 溢出

47. 原码一位乘法 符号位与数值分开运算

48. n数值位 补码一位乘法 n移位 n+1 加法

    原码 n移位和加法都是n

49. 原码一位乘法 符号位不参与运算

50. 原码乘法 符号位 异或

51. N*2+1=2N+1 加倍 加一个符号位

52. 加减交替法 只有最终余数是负数 才恢复余数

53. 补码除法 异号相除看够不够减，然后上商，够商0，不够商1

54. 主存地址 无符号数

55. 补码最小整数 1 

56. 10000011

57. 小端 字节编址 32位 6位 从低地址向高地址 22

58. x 1111 1111 1111 1111 1111 1111 1110 1111

-33

41H 65

-33 - 65 = -98 

1100010

001 1110  9E

58. 32位 小端 -64小端

题意知道 地址递减 不知道为啥

59. 1101 1000  算术唯一 符号位不全
60. 逻辑移位 直接移位

## 第二题

8000 0004H

无符号 1000 0000 0000 0000 0000 0000 0000 0100 

2^31^+ 2^2^   x/2 =   2^30^ +2^1^ 

0010 0000 0000 0000 0000 0000 0000 0010

4000 0002H

2x 2^32^ +2^3^ 

溢出 0000 0008H

(2) 补码 x 

1000 0000 0000 0000 0000 0000 0000 0100 

1111 1111 1111 1111 1111 1111 1111 1100

-(x^31^ -4)   x/2  -(x^30^ -2) 右移 1100 。。。0010

C000 0002H

2x  -(x^32^ -8) 溢出8000 0008H

2. 

8位寄存器

R1 x 86H 134

R5 z1 x-y (134-246)%256= 144 90H

R6 x+y = (134+246) %144 = 124 7CH

m = 1000 0110   -6=128 = 122 m-n 90H -112

(3) 能 n位加法器实现模2n次方整数加法运算无符号整数 ab 用加法器实现 a-b a+ -b实现

a+b  补  = a补 + b补

也可以加法器实现

(4)溢出判断 符号位相同 且和与初值相反

最后一条溢出了

3.  0.1011 + 1.1110 =0.1001

0.1011 - 1.1110 = 0.1101

4. 定点小数补码的和等于和的补码 证明
5. 1 0010 答案什么鬼
6. 1011 0011 1110  0.1110
7. BCH     B0H

​    -148 6CH  96+12= 108

溢出 1 sf 0 正数 进位 1 有进位

12 0CH 溢出0 不溢出 sf 0 正数 cf1 进位

## 2.3 选择题

1. 强制转换 类型提升

char int long double

2. 浮点数加法

00 111 00 11101

00 101 00 10100

对阶 7-5 = 2

Y 00111 00101

尾数相加 00 11101  + 0000101 = 01 00010  右规

规格化 01 000 00 10001

阶码 01 溢出

3. 强制转换精度变化

int32位 float只保存23+1位仍然会有损失精度

但是785 只有10位不到，可以无损

f和d相加时候要对阶，有效位舍去而损失精度

4. 浮点数表示

C184 0000H

5. 浮点数表示范围

2^128^ - 2^104^  254-127(2-2^-23)

6. 阶码多 尾数少 范围大 精度差

7. 基数大 范围大 精度低

8. 变形补码，两个二进制位来表示数字符号位，其余补码相同，不能避免溢出

   定点与浮点都会溢出

9. 补码 规格化1.0xxxx才是规格化数
10. 63  补码范围-1 —— 1-2^-8^   * 2^63^ 
11. 原码 正数规格化0.1xxxx 负数1.1xxxx
12. 对接不存在阶码减小
13. 尾数原码
14. ieee 754 原码
15. 隐藏位+1 2-2^52^  阶数1023
16. 1100 0110 0100 0000 0000 0000 0000 0000

阶数1000 0011 - 01111111 = 4 

17. 13 1.5
18. 基数预定
19. 1111 0000 0000 0000 0000 0000 0000 0000

20. 移码 补码 原码 浮点数
21. 规格化 精度
22. 下溢 太小了
23. 浮点数计算
24. 最大表示的数
25. 小阶段到大阶段 右移
26. 负数规格化 0.0xxxxx
27. 4  01

机器数反码 负数左移最高位丢0 右移最低位丢0错误 影响精度

双符号位只有低符号位进行移位操作

30. 舍入是浮点数的概念 浮点数舍入 对阶 规格化

舍入未必误差

31. 对阶是小到大 右规和舍入过程阶码+1会上溢，尾数溢出不一定溢出
32. 1 * 2^-126^ 

## 第二题 大题

浮点数溢出 上溢 下溢

阶码 上溢出：正数超过了最大值，负数同理，软件故障

阶码下溢出 负指数比最小允许值还小，浮点数下溢出 置为0

尾数溢出 最高有效位有进位 溢出 右归 阶码+1，因此阶码溢出才会导致数字溢出

非规格化尾数 左归

2. -(2^30 +2^29 +2^28+ 2^20 + 2^14)

2^.........

4. 基数不表示

非2基数的左归操作

6. 右规1 左归不定

## 2.4 小题

1. 加法不光与当前位数值有关，也和低位传过来的数有关

2. alu组合逻辑电路

3. 串行加法器 传递延迟影响最大

4. 进位 g = XY p 二者异或

5. 不懂

6. 地址寄存器 常见错误选项

7. 傻逼题

8. 加速

   

    

大题不会

二进制 物理 数学 逻辑

精度问题

移码 比较方便




