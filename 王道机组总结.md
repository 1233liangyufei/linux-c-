# 第一章

1. 计算机器件：**电子管，晶体管，中小规模集成电路，大规模集成电路**
2. 微型处理器以**微处理器**发展为标志
3. 计算机上直接执行的语言：**机器语言**
4. 助记符编写语言：**汇编语言**
5. **正则语言**：编译原理复合正则文法的语言
6. **解释语言**：边翻译边执行
7. **编译**：高级语言到汇编语言
8. **汇编**：汇编语言到机器语言
9. **二进制**原因：电子器件性能决定
10. **计算机系统**包括：软件和硬件都有
11. **主机**包括：运算，存储，控制器
12. 冯诺依曼机是控制流驱动的，存储程序思想
13. 冯诺依曼机特点：地址访问，顺序执行指令
14. 相联存储器特点：存储器内容选址
15. cpu区分数据和指令的依据：指令周期的不同阶段，取指阶段与执行阶段，而不是操作吗的译码结果，这是确定了数据指令后的操作
16. 软件的功能和硬件的功能在逻辑上是等效的，但是不是等价的。切记
17. 存放想要执行指令的寄存器是IR指令寄存器，
18. PC存放下一条指令的地址
19. MAR想要访问的存储单元地址
20. MDR存储单元取来的数据
21. 地址译码器是主存部分，不属于cpu
22. 指令寄存器，地址寄存器，通用寄存器都是cpu组成部分
23. MAR 地址吗长度 MDR存储字长
24. 运算器包括 alu 数据总线 状态寄存器，
25. 地址寄存器用来保存cpu访问内存的地址
26. 速度：寄存器，cache sram,内存 dram，外存
27. 地址空间和地址总线长度有关 2^(地址线长度) 2^16 = 65536
28. 程序运行时候在主存上
29. 文本处理软件是应用软件
30. 连接程序 服务性程序
31. 操作系统 系统软件
32. 编译程序 语言处理程序
33. 解释程序，解释一条执行一条，执行速度较慢
34. 高级语言到目标代码文件 编译程序
35. 源程序    通过**编译程序**   变为汇编源程序
36. 汇编源程序 通过**汇编程序**  到目标程序 
37. 目标程序 通过**链接程序**到可执行程序
38. **翻译程序**：编译程序和解释程序
39. 汇编程序可以操作寄存器
40. 向后兼容就是新机器可以运行以前的系统
41. cpu 运算控制器 不包括存储器
42. 系统软件：数据库 编译 操作系统
43. 相联存储器，可地址，可内容寻址，普通的只能按地址寻址
44. 计算机6层关系：上层是下层的功能扩展，下层是上层基础
45. 硬件只能直接执行机器语言
46. 二进制：电路简单，运算容易，物理实现容易
47. **存储程序设计原理**

指令按代码形式事先输入计算机主存，按其在存储器的首地址执行第一条指令，以后按该程序的规定执行其他指令，直到程序执行结束

5大功能：

- 数据传输
- 数据存储
- 数据处理
- 操作控制
- 操作判断

48. 缩短程序时间的措施：

- 提高cpu时钟频率 主频
- 优化数据通路结构，数据通路就是是cpu内部寄存器数据交换功能，这可以提高数据吞吐量
- 程序编译优化  优化后指令序列更加合理或者条数更少

49. 名词

- mips 每秒执行几个百万指令
- MFLOPS 每秒多少百玩浮点数运算
- CPI 执行一条指令平均时钟数

50. 存储字长：存放在一个存储单元的二进制代码位数
51. 机器字长 数据运算基本单位
52. 磁盘 永久存放数据程序的设备
53. 数据字长是总线一次并行传输的信息位数，可以不等于MDR
54. 计算机的位数是机器字长，一次处理的二进制数长度，寄存器判断机器字长
55. 操作系统的位数是寻址位数
56. 科学计算性能参数 MFLOPS
57. 用户透明寄存器 IR MAR MDR 
58. 可见的寄存器PC 状态 通用
59. 时钟周期是计算机的最小单位，cpu周期也叫机器周期，由多个时钟周期组成
60. cpi与系统结构，指令集有关系，与时钟周期无关
61. 用户观点，性能 吞吐量
62. 提高性能途径：并行处理技术
63. 兼容：软件**或**硬件的通用性，同一系列通用
64. 会计电算化：数据处理应用
65. 计算精度：机器字长
66. mips = 主频Mhz/cpi
67. 64k 等于 2的16次方 地址总线16位

数据总线宽度32位 mar16 mdr32

因为指令字长等于存储字长等于机器字长 ir acc mq x32位

68. 指令周期 = 1/mips us
69. 每条指令时钟周期数= 指令周期/时钟周期








# 第二章

## 第一节

1. 进制转换

将其他进制转化为十进制

2. 16进制加法

类似于10进制，逢16进1

3. 进制转换

整数部分除基数取余法，小数部分，乘基取整法

4. 整数可以表示范围

无符号数表示范围 0-2^n-1

有符号 -2^n-1 -- 2^n-1 -1

5. 进制转换的精度问题

整数部分任何进制相互都可以准确转换

而小数部分可能在一个进制下是有限小数，另一个进制成了无限小数无法准确表示

二进制小数都可以以十进制准确表述，**但是十进制小数却不一定可以表示为二进制小数**

6. 判断8421码合法

8421 用一个4位的2进制数来表示，而4位二进制数可以表示16个数字，多于需要的10个数字，因此出现大于等于0的情况是非法的

1010 1011 1100 1101 1110 1111 这6个不行

6. 8421码的加法

8421转换10进制很方便，最好转为10进制加再转回来

0011 1000  38

0010 0011  23

38+23 = 61 

0110 0001

8. ascii码

ascii码有128个，需要7位来存储，但是字节为单位，占用1个字节8bit，空出的最高位留为0

9. 大端小端

小端 最低有效字节存在最小的位置

01234567H

int的起始地址就是int的存放地址，小端存放最低有效位 67H

10. 校验码

- 任意两个码字之间最少变化的二进制位数称为码距，码距等于2的数据检验码具备纠错能力
- 码距越大，检错纠错能力越强
- 奇偶检验只能检错不能纠错
- 海明码可以检错，可以纠错
- crc利用除法建立数据和检验位的关系

11. 奇偶检验码

对于偶检验码 最后一位凑一个数凑成偶数个1 如果收到的信息还是偶数个1，那么要不不出错，要不偶数错

奇偶检验可以检测奇数的错误 1 3 5

14. 设置奇偶检验码

41H 二进制 A100 0001 F 100 0110 

增加啊偶校验于最高位 1100 0110  C6H

15. 海明码检验位设置

n + 8  < 2^n n为5

16. 海明 发现2位错 纠正1位错
17. crc纠错方法：

- 请求重发
- 删除数据
- 余数自动修正

18. 大量数据的检验 crc

20. 海明码于crc

海明码编码 先利用 n + 8  < 2^n 计算需要4位，再加一个全校验位，将编码后的写出来，校验位空出来，p1校验二进制下个位1位置的数，p2校验二进制下十位1的数字，其他同理，p13是全部的偶检验码

crc编码 

模二除法的方法

crc用多项式左移r位除以生成多项式G x 得到的余数为校验码

## 第二节

1. 32位机器 int 32位 short 16位

x 127 0111 1111 扩展32位 0000007FH

y -9 1001 补码 0111 符号扩展 FFF7H

x+y y强制类型转换为32位FFFFFFF7H

0000007FH

FFFFFFF7H

数据的截取于保留，精度的丢失

数据转换不确定性，长的转短的会截断，long到short，只保留低位，误差很大

2. 数据的溢出

8位寄存器-128-127范围

r1 = 1111 1110  111 1110 000 0010   真值 -2

r2 = 1111 0010  111 0010 000 1110  真值 -14

r3 = 1001 0000  001 0000 111 0000 真值-(64+32+16)=-112

r4 = 1111 1000 111 1000 000 1000 真值 -8

r3*r2 = -112 * -14 超过128 溢出

3. 小端存储

边界对齐

int 32

char 8

short 16

00000000000000000000000000000000

int

00000000                     0000000000000

char                              short

这么存放

首地址0xC008 指向int最低位

273

273 =0x111 首地址指向最后一个字节0x11

内存按字节编址 8+6 = E

因此为0xC00E

4. 类型转换

无符号数 0填充 65535 FFFFH 65530 FFFA

5. 类型转换

short 到 unsighed short

内容不变，解释变了 -32767 

32767 转2进制 7FFF 补码 1000000000000000000000000000001

2^15+1 = 32768+1 = 32769

6. 真值表示唯一 补码 移码
7. 正数补码原码相同
8. 负数小数的补码与正数相同 1 0010110

取反加1 符号位不变

9. 求原码符号位取反
10. n位表示数据 2^n
11. 定点小数表示范围 -1+2^-n ——1-2^-n
12. 原码整数范围 -2^n+1 -- 2^n-1 原码是对称的 正负数相同
13. 补码左移 符号位不变，数值位左移，后面添0
14. 补码右移 添符号位补空
15. 补码 0唯一 减法可以加法实现 符号位参加运算
16. 最大值2^n-1 -1
17. 二者差值0.2 带特殊值n=1 值0.2可得
18. -2^n-1
19. 最小负数1.0000 真值为-1
20. 移码与补码表示范围相同
21. 移码补码符号位相反，其他位相同
22. 移码表示阶数 补码表示定点整数
23. 负数补码表示 -1/2 补码1.1000 小于这个 x1为0，其余随意
24. -32 补码 1 100000 大于-32 x1为1 后面至少有不为0的，否则全0相等了
25. <-16 x10 后面任意

24. 找规律 -0.75 010
25. 循环左移，左移的那位进入标志寄存器
26. 1011 1010 原码左移右移都补0

算术左移 1111 0100 F4

算术右移  1001 1101 9D

算术左移和逻辑左移一样都是右边补0

[算术右移](https://www.baidu.com/s?wd=%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)符号位要一起移动，并且在左边补上符号位，逻辑右移很简单，只要将二进制数整体右移

27. 补码

右移补符号位

1011 1010

1101 1101 DD

28. 当且仅当是充要条件 >=0都成立
29. 1000 1111 1010 0000
30. 双符号位 单符号位 都的溢出判断电路 异或门实现
31. 正数原码反码补码相同
32. 模4容易检验加减法的溢出问题
33. **模4只需要1个符号位，alu需要两个符号位**

33. -66 BD
34. 9BH -101
35. -0 原码100000000反码111111111
36. 11111111   移码 

127 原码 01111111

127 补码  移码补码最高位不同，其余相同

37. 11111111 -1     补码

38. 移码0000000是最小的 且是给负数

39. 反码

40. 移码000000 相反数会溢出

41. 正数相加 溢出 双符号位 01 负溢出 10

42. 双符号位 10 01 才溢出

43. 10 负溢出

44. 最高位符号位不同时候 溢出

45. 补码加法 左移右移

46. 103- -25 = 128 溢出

47. 原码一位乘法 符号位与数值分开运算

48. n数值位 补码一位乘法 n移位 n+1 加法

    原码 n移位和加法都是n

49. 原码一位乘法 符号位不参与运算

50. 原码乘法 符号位 异或

51. N*2+1=2N+1 加倍 加一个符号位

52. 加减交替法 只有最终余数是负数 才恢复余数

53. 补码除法 异号相除看够不够减，然后上商，够商0，不够商1

54. 主存地址 无符号数

55. 补码最小整数 1 

56. 10000011

57. 小端 字节编址 32位 6位 从低地址向高地址 22

58. x 1111 1111 1111 1111 1111 1111 1110 1111

-33

41H 65

-33 - 65 = -98 

1100010

001 1110  9E

58. 32位 小端 -64小端

题意知道 地址递减 不知道为啥

59. 1101 1000  算术唯一 符号位不全
60. 逻辑移位 直接移位

## 第二题

8000 0004H

无符号 1000 0000 0000 0000 0000 0000 0000 0100 

2^31^+ 2^2^   x/2 =   2^30^ +2^1^ 

0010 0000 0000 0000 0000 0000 0000 0010

4000 0002H

2x 2^32^ +2^3^ 

溢出 0000 0008H

(2) 补码 x 

1000 0000 0000 0000 0000 0000 0000 0100 

1111 1111 1111 1111 1111 1111 1111 1100

-(x^31^ -4)   x/2  -(x^30^ -2) 右移 1100 。。。0010

C000 0002H

2x  -(x^32^ -8) 溢出8000 0008H

2. 

8位寄存器

R1 x 86H 134

R5 z1 x-y (134-246)%256= 144 90H

R6 x+y = (134+246) %144 = 124 7CH

m = 1000 0110   -6=128 = 122 m-n 90H -112

(3) 能 n位加法器实现模2n次方整数加法运算无符号整数 ab 用加法器实现 a-b a+ -b实现

a+b  补  = a补 + b补

也可以加法器实现

(4)溢出判断 符号位相同 且和与初值相反

最后一条溢出了

3.  0.1011 + 1.1110 =0.1001

0.1011 - 1.1110 = 0.1101

4. 定点小数补码的和等于和的补码 证明
5. 1 0010 答案什么鬼
6. 1011 0011 1110  0.1110
7. BCH     B0H

​    -148 6CH  96+12= 108

溢出 1 sf 0 正数 进位 1 有进位

12 0CH 溢出0 不溢出 sf 0 正数 cf1 进位

## 2.3 选择题

1. 强制转换 类型提升

char int long double

2. 浮点数加法

00 111 00 11101

00 101 00 10100

对阶 7-5 = 2

Y 00111 00101

尾数相加 00 11101  + 0000101 = 01 00010  右规

规格化 01 000 00 10001

阶码 01 溢出

3. 强制转换精度变化

int32位 float只保存23+1位仍然会有损失精度

但是785 只有10位不到，可以无损

f和d相加时候要对阶，有效位舍去而损失精度

4. 浮点数表示

C184 0000H

5. 浮点数表示范围

2^128^ - 2^104^  254-127(2-2^-23)

6. 阶码多 尾数少 范围大 精度差

7. 基数大 范围大 精度低

8. 变形补码，两个二进制位来表示数字符号位，其余补码相同，不能避免溢出

   定点与浮点都会溢出

9. 补码 规格化1.0xxxx才是规格化数
10. 63  补码范围-1 —— 1-2^-8^   * 2^63^ 
11. 原码 正数规格化0.1xxxx 负数1.1xxxx
12. 对接不存在阶码减小
13. 尾数原码
14. ieee 754 原码
15. 隐藏位+1 2-2^52^  阶数1023
16. 1100 0110 0100 0000 0000 0000 0000 0000

阶数1000 0011 - 01111111 = 4 

17. 13 1.5
18. 基数预定
19. 1111 0000 0000 0000 0000 0000 0000 0000

20. 移码 补码 原码 浮点数
21. 规格化 精度
22. 下溢 太小了
23. 浮点数计算
24. 最大表示的数
25. 小阶段到大阶段 右移
26. 负数规格化 0.0xxxxx
27. 4  01

机器数反码 负数左移最高位丢0 右移最低位丢0错误 影响精度

双符号位只有低符号位进行移位操作

30. 舍入是浮点数的概念 浮点数舍入 对阶 规格化

舍入未必误差

31. 对阶是小到大 右规和舍入过程阶码+1会上溢，尾数溢出不一定溢出
32. 1 * 2^-126^ 

## 第二题 大题

浮点数溢出 上溢 下溢

阶码 上溢出：正数超过了最大值，负数同理，软件故障

阶码下溢出 负指数比最小允许值还小，浮点数下溢出 置为0

尾数溢出 最高有效位有进位 溢出 右归 阶码+1，因此阶码溢出才会导致数字溢出

非规格化尾数 左归

2. -(2^30 +2^29 +2^28+ 2^20 + 2^14)

2^.........

4. 基数不表示

非2基数的左归操作

6. 右规1 左归不定

## 2.4 小题

1. 加法不光与当前位数值有关，也和低位传过来的数有关

2. alu组合逻辑电路

3. 串行加法器 传递延迟影响最大

4. 进位 g = XY p 二者异或

5. 不懂

6. 地址寄存器 常见错误选项

7. 傻逼题

8. 加速

   

    

大题不会

二进制 物理 数学 逻辑

精度问题

移码 比较方便

# 第三章

## 3.1小题

1. 随机存储 ram rom  如dram sram eprom

顺序存储 cd rom光盘 光盘存储器不是rom因此是顺序访问

2. 磁盘属于 DAM **直接存取存储器**
3. - 存取时间：存储器读出或写入一次信息的平均时间
   - 存取周期：连续两次访问存储器所必须的最短时间间隔 =存取时间+复原时间，sram复原时间是存储信息的稳定时间，dram是刷新的一次存取时间
4. 机器字长32位 半字寻址 一个单元16位 2B  总可寻址单元16/2 = 8M =2^23^ 
5. 相联存储器   内容寻址 地址寻址
6. 操作系统 需要引导程序 位于rom 程序允许需要ram
7. cpu不能直接访问硬盘
8. 2B/250ns = 1/125 10^9^ =8* 10^6^ 
9. 16M 可寻址单元的计算

## 3.2小题

1. 存储器分级 容量速度价格的折中
2. 存储系统 cache 主存 外存
3. cache 主存 主存与cpu 速度不匹配
4. 速度 寄存器 cache 内存
5. 命中率 100x+1000(1-x)<= 1.15 *100

x+10-10x<=1.15

x 0.99

6. cpu可以直接访问主存
   1. 贮存辅存仅对应用程序员透明
   2. cpu可以直接访问内存

## 大题

1. 平均12 命中率90 顶层5 中层多少

12 = 5 *0.9 + x*0.1 

x = 75ns

2. 命中率100/100+1900 = 95%

0.95 * 50 + 0.05 * 250 = 60ns

效率 = 50 /60 = 83.3%

## 3.3小题

1. 1024 10 8 10+8=18 再加上片选和读写控制 1+2 =18+3=21
2. 32k 15地址 16 数据
3. 存储单元16 数据线16
4. dram按行刷新
5. 集中刷新必定死时间 异步刷新缩短了死时间，但是仍然有，
   1. 分散刷新 一段读写 一段刷新 不存在死时间
6. 集成度 dram好 速度 sram好 dram刷新
7. ram易失去性存储
8. sram靠双稳态电路两个状态表示0 1
   1. dram靠电容电荷存储信息
9. 地址复用 地址线减半 选片需要行列 2根 读写2根 8+5+2+2 = 17
10. 4m =22根地址线 8数据线dram地址复用 11根 19根
11. ram刷新 rom不刷新
12. 闪存
    1. 信息可读可写 写入要擦除数据 写速度更慢
    2. mos 管 半导体存储器
    3. 掉电信息还在 非容易丢失性
    4. 随机访问
13. cache ram易失
14. **u盘只读存储器 rom**
15. eprom可以改写，但是改写麻烦，有次数限制 不能做ram
16. 动态半导体
    1. 动态 会放电 需要刷新
    2. 刷新需要一个存储周期
17. sdram

## 3.3大题

1. 50刷新

1024*768 * 3 *72 =169869 KB/s

总带宽*2 = 339.738MB/s

提高刷新率：

高速dram

多体交叉存储结构

显示器内部总线加倍

双端口存储器 刷新 更新 分离

2.异步刷新 

刷新间隔2ms

刷新时间间隔是 2ms/行数64 = 32.35us  32us

集中刷新

2ms内刷新64行 存取周期0.1us

6.4us内刷新 6.4/2000 = 0.32%

## 3.4 小题

1. 选择ram rom

4kb rom 一块2kB 需要2块 字扩展

60KB 一片2KB 30块 字位扩展

2. 字位扩展

字位扩展 4列芯片总共

一片 2k那么长   2^11的寻址范围

第一个 0000    07FF

第二个 0800    0FFF

第三个 1000     17FF

第四行 1800    1FFF

3. 2000 = 2^13   8K  还剩56K 4KB = 13块
4. 地址mar地址应该和主存地址空间一样，方便扩容，而不是和当前的主存储器大小一致 64MB =26位
5. 位 8 字 4
6. 4B编址单位 位扩展到32位即可
7. 256KB 2 18B 字寻址 2B 寻址单元 2 17次方
8. 16*2 8 *2 21 16
9.  16/4 = 4 2*4 = 8
10. 地址线 24 16M 
    1. 32/8=4
    2. 16/0.5 = 32
    3. 4*32 = 128
11. 地址线放在低位 4-15 字位扩展 行扩2倍 列扩展4倍  需要2位来输出 A23
12. 400 = 1K   四片组成 256 * 8 bit
13. 40000   2^18   一片 2^ 14   相除 16片
14. 地址线15 片选地址 3位 18长度

111000000000000000到111111111111111

38000 3fffff

15.  不会 按照电路选项的信号输入进去是1 则可以寻址，否则不可以
16. 行刷新 小的好 行列不要差别太多

## 3.4大题

mar存放cpu访问的内存单元地址，或存放cpu写入的内存单元地址

数据寄存器mdr内存读出的信息或者写入的信息

字节编址 1M * 8 数据寄存器8 地址寄存器20

编址范围00000H FFFFFH

字编址    256K * 32   数据寄存器32 地址寄存器 18 范围 00000H 3FFFFH

2. 选片

(1)4M 22地址线 32数据线 按字编址 不需要转换

(2)4/0.5 *32/8 = 32片

(2)地址线作用：0-18 512K 19位来寻址

19 20 21 8组 3位地址线来决定

3. 64片

异步刷新 2/64 =31us

4. 256*32

18根

## 3.5小题

1. 地址码相同 访问同一个地址 会冲突
2. 交叉存储器 模块 并行
3. 至少需要110/10 因此是大于等于
4. 四体并行 低位交叉 64K * 32  4个模块 128位 
5. 不会
6. 高位交叉没有既不想 ，地位交叉满足局部性原理，连续访问存在概率上的可能性，双端口可以同时访问同一单元
7. 冲突 相邻四次 同一个模块则冲突

8. 不会

## 3.5大题

1. 32*4 =128

不对 还需要400ns传输

2. 200ns 200/4 = 50ns 32位 32/50 = 640b =60MB/s

不会，并行性很差，没有利用局部性原理

单体4字 平均速度加快 灵活性不足 缓存加大

四端口扩容不容易扩容 且无法同时读写同一存储单元

多提结构允许同一周期多个存储体写入操作

3. 

17 9   37 17  13 37 8 4 41 13

## 3.6单选

1. B cache也是和内存一样的内容
2.  32    129/32=4  
3.  3

5. 主存字 cache块
6. 命中 写回 不命中 写分配
   1. 命中 全写法 不命中 非写分配
7. 起码4/20 =0.2 大于的只有30
8. 二进制 低14位就是
9. 局部性 lru
10. 64 * 12+1
11. c不会
12. 010011000
13. 4KB 16/4 = 4 4*2=8 1/8=12.5%
14. 主存 
    1. 只有再虚拟存储器种，cpu发出的才是虚拟地址
15. 指令数据分离  指令流水线资源
16. 循环具有时间局部性  
17. 页号3位 13位

物理地址 32=2 5次方 15位

## 3.6大题

1. 读写策略设置

写回法减少访存 但是存在不一致隐患 直通法符合一致性

对安全要求不高 写回法

对安全要求高 直通法

2. 64B块内 6位 cache128 43组 组号5位 剩余 32-5-6 =21位
3. 总位数包括标记项总位数和数据块总位数

标记块包括标记字段 有效位 脏位

主存tag 21位 组号5 块内6

标记项目总数 128 * 21+1+1 =2944位 数据块 128*64 *8 =65536位

cache总数 2944+65536=68480

3. 

256内存 8cache 64B

i j

320

(1) 地址长度 28

块内地址6 chache 3 28-6-3 =19

还有一个标记位

cache8行  8*（64+20/8） = 532B

320 4B 320+124=44411011 1100 6

3. 数组256 256 4B  2^18^ /64 = 2^12块访问

16次访问 失效12次 每块第一个没命中 命中率 2^16 - 2^12 / 2^16 = 93.75

命中率 0 

4.

cache 16*8 * 16/8 = 256B

主存 16 * 256 * 2B = 8192B

主存 4+ 8 =12位

cache 4+3 =7

组相连 前面0-4 我5号 33H 装入5块 1011000B 101块号 1000块内地址

36 368命中 58H

5. 

(1) 64KB/128B =512行 512/4 =128组

(2) 每行一个 512标记相 

主存标记长度就是标记位长度 128组 行长128B 标记位长度 32-7-7=18位

(3) lru需要两个替换控制位 1个有效位 18+2+1位、512*21=10752

写回 加一致性控制位 512*22 =11264

6. 

1/800Mhz =1.25ns

1/200Mhz =5 ns

带宽 = 4B * 200 = 800MB/s

cache 32B 一个读写突发传送事务读取一个主存

一次地址 和32B数据传送 1 总线舟曲传输地址 40/5启动一个工作体 

第一个体 花费 40ns 传输8个时钟周期 40

总计85

(3)

命中 4*1.25 = 5ns

1.2 * 5% * 85 =5.1ns

一条 4 + 5.1 = 10.1

bp 10.1 * 100 = 1010

7.

页8KB A B 32-13 = 19

D = 13

C = 24-13 =11

主存块 64B 

G=6 2路组相连 128B 供 512组 F = 9 E = 24-6-9=9

cache 011 =3

000001000

3. 缺页访问硬盘 cache不命中访问内存 缺页开销大
4. 写策略需要写快速和慢速存储器，写磁盘开销大 cache主存 直接写 主存外存 回写

8. 简单

## 3.7小题

1. 虚存利用局部性原理，需要程序具有局部性，顺序执行更好
2. 局部性 时间局部性  空间局部性  
3. 主存交换 段页式 页式 都是页位单位
4. tlb是page副本

cache命中 在cache中 页面调入内存 page命中 tle不一定命中

cache未命中，命中 page一定命中

5. b 标记位换页框号
6. 虚存 系统程序员可见 普通不可见
7. 地址映射 操作系统完成
8. 虚存 扩大内存
9. 虚存 局部性

页太小 页表太大 操作缓慢

页太大 虚存页面变少 主存页也很大 换入换出麻烦，速度慢

段式 程序逻辑 便于编译 管理 保护 多道程序适合

10. 块表 组相连 慢表 内存 慢表命中高
11. cache直接读 写入cache内存 访存1次
12. 块大小 16B 块内地址4位 

4K *32 =128K位

4K字 每个块16B 4字 总cache2 ^ 10行 标记位10个

32-10-4=18

18+1+1 =20

20K的标记容量

## 3.7大题

1.

虚地址 24 页号 12 

主存 20   页号 8

cache 32B 5位 cache8行 3 主存子块 20-3-5 = 12

001H 04H页框

物理地址 04C60H 

主存映射 3行 有效位1 标记不等于高12位 未命中

命中

2. 简单
3. 简单
4. 简单
5. 20 3 5 28位

tle全相联 sram 读写快 成本高

cache

2路组相连

每组 1个lru位 1个脏位 28位地址 tag20 组索引3 块内5 8组 2行 32B 总容量 8 * 2 (20+1 +1+1  +32* 8 )=4464b =558b

(4) 0040040

不命中

3

















